class Real64 : CommonPrimitiveMethods<<Real64>> [primitive]
  GLOBAL METHODS
    method create( value:Real64 )->Real64
      return value

  METHODS
    method abs->Real64
      if (this >= 0) return this
      else           return -this

    method acos->Real64
      return native("acos($this)")->Real64

    method atan->Real64
      return native("atan($this)")->Real64

    method atan2( x:Real64 )->Real64
      # Equivalent to atan2(this,x)
      return native("atan2($this,$x)")->Real64

    method asin->Real64
      return native("asin($this)")->Real64

    method ceiling->Real64
      return native("ceil($this)")->Real64

    method cos->Real64
      return native("cos($this)")->Real64

    method exp->Real64
      return native("exp($this)")->Real64

    method floor->Real64
      return native("floor($this)")->Real64

    method integer_bits->Int64
      return native("*((RogueInt64*)&$this)")->Int64

    method is_infinite->Logical
      # Returns true for positive OR negative infinity
      return (this == this) and (this - this != 0)

    method is_NaN->Logical
      return (this != this)

    method lerp( a:Int32, b:Int32 )->Int32
      # Assumes this Real64 is a progress value in the 0.0 to 1.0 range.
      # Returns the position from 'a' to 'b' based on this progress.
      return a + (b-a) * this

    method lerp( a:Real64, b:Real64 )->Real64
      # Assumes this Real64 is a progress value in the 0.0 to 1.0 range.
      # Returns the position from 'a' to 'b' based on this progress.
      return a + (b-a) * this

    method log->Real64
      return native("log($this)")->Real64

    method log2->Real64
      return native("log2($this)")->Real64

    method log10->Real64
      return native("log10($this)")->Real64

    method operator%( other:Real64 )->Real64
      local q = this / other
      return this - q.floor * other

    method sin->Real64
      return native("sin($this)")->Real64

    method sqrt->Real64
      return native("sqrt($this)")->Real64

    method tan->Real64
      return native("tan($this)")->Real64

    method to->String
      return String().[ print(this) ]

endClass

class Real32 : CommonPrimitiveMethods<<Real32>> [primitive]
  GLOBAL METHODS
    method create( value:Real32 )->Real32
      return value

  METHODS
    method abs->Real32
      if (this >= 0) return this
      else           return -this

    method acos->Real32
      return native("acosf($this)")->Real32

    method atan->Real32
      return native("atanf($this)")->Real32

    method atan2( x:Real32 )->Real32
      # Equivalent to atan2(this,x)
      return native("atan2f($this,$x)")->Real32

    method asin->Real32
      return native("asinf($this)")->Real32

    method ceiling->Real32
      return native("ceilf($this)")->Real32

    method cos->Real32
      return native("cosf($this)")->Real32

    method exp->Real32
      return native("expf($this)")->Real32

    method floor->Real32
      return native("floorf($this)")->Real32

    method integer_bits->Int64
      return native("*((RogueInt64*)&$this)")->Int64

    method is_infinite->Logical
      # Returns true for positive OR negative infinity
      return (this == this) and (this - this != 0)

    method is_NaN->Logical
      return (this != this)

    method lerp( a:Int32, b:Int32 )->Int32
      # Assumes this Real32 is a progress value in the 0.0 to 1.0 range.
      # Returns the position from 'a' to 'b' based on this progress.
      return a + (b-a) * this

    method lerp( a:Real32, b:Real32 )->Real32
      # Assumes this Real32 is a progress value in the 0.0 to 1.0 range.
      # Returns the position from 'a' to 'b' based on this progress.
      return a + (b-a) * this

    method log->Real32
      return native("logf($this)")->Real32

    method log2->Real32
      return native("log2f($this)")->Real32

    method log10->Real32
      return native("log10f($this)")->Real32

    method operator%( other:Real32 )->Real32
      local q = this / other
      return this - q.floor * other

    method sin->Real32
      return native("sinf($this)")->Real32

    method sqrt->Real32
      return native("sqrtf($this)")->Real32

    method tan->Real32
      return native("tanf($this)")->Real32

    method to->String
      return String().[ print(this) ]

endClass

class Int64 : CommonPrimitiveMethods<<Int64>> [primitive]
  GLOBAL METHODS
    method create( value:Int64 )->Int64
      return value

    method maximum->Int64
      return 0x7FFF_FFFF_FFFF_FFFF

    method minimum->Int64
      return 0x8000_0000_0000_0000

  METHODS
    method operator%( other:Int64 )->Int64
      if ((not this and not other) or other == 1) return 0

      local r = native("$this % $other")->Int64
      if ((this ~ other) < 0)
        if (r) return r + other
        else   return 0
      else
        return r
      endIf

    method operator:>>:( bits:Int64 )->Int64
      if (bits <= 0) return this

      --bits
      if (bits) return ((this :>>>: 1) & 0x7fffFFFFffffFFFF) :>>>: bits
      else      return (this :>>>: 1) & 0x7fffFFFFffffFFFF
#{
    method print_in_power2_base( base:Int32, digits=16:Int32, buffer:PrintWriter )->PrintWriter
      local bits = 0
      local temp = base
      while (temp > 1) ++bits; temp = temp:>>>:1

      local remaining = this :>>: bits
      if (digits > 1 or remaining) remaining.print_in_power2_base( base, digits-1, buffer )
      buffer.print( (this & (base-1)).to_digit )
      return buffer
}#

    method real_bits->Real64
      return native("*((RogueReal64*)&$this)")->Real64

    method to->String
      which (this)
        case -1: return "-1"
        case  0: return "0"
        case  1: return "1"
        case  2: return "2"
        case  3: return "3"
        case  4: return "4"
        case  5: return "5"
        case  6: return "6"
        case  7: return "7"
        case  8: return "8"
        case  9: return "9"
        others:  return String().[ print(this) ]
      endWhich
endClass

class Int32 : CommonPrimitiveMethods<<Int32>> [primitive]
  GLOBAL METHODS
    method create( value:Int32 )->Int32
      return value

    #method from_value( value:Value )->Int32
      #return value->Int32

    method maximum->Int32
      return 2147483647

    method minimum->Int32
      return 0x8000_0000

  METHODS
    method abs->Int32
      if (this >= 0) return this
      else           return -this

    method real_bits->Real32
      return native("*((RogueReal32*)&$this)")->Real32

      #{
    method digit_count->Int32
      use buffer = StringBuilder.pool
        return buffer.print( this ).count
      endUse

    method format( fmt:String )->String
      return Int64( this ).format( fmt, 32 )

    method hash_code->Int32
      return this

    method introspector->Introspector
      return BoxedIntrospector<<Int32>>( this->Object )

    method is_power_of_two->Logical
      return ((this & (this-1)) == 0)

    method left_justified( spaces:Int32, fill=' ':Character )->String
      return this->String.left_justified( spaces, fill )
      }#

    method operator%( other:Int32 )->Int32
      if ((not this and not other) or other == 1) return 0

      local r = native("$this % $other")->Int32
      if ((this ~ other) < 0)
        if (r) return r + other
        else   return 0
      else
        return r
      endIf

    method operator:>>:( bits:Int32 )->Int32
      if (bits <= 0) return this

      --bits
      if (bits) return ((this :>>>: 1) & 0x7fffFFFF) :>>>: bits
      else      return (this :>>>: 1) & 0x7fffFFFF

      #{
    method progress( a:Int32, b:Int32 )->Real64
      # Returns the progress of this number along the interval from a to b.
      # Examples:
      #   2.progress(1,5) -> 0.25
      #   2.progress(5,1) -> 0.75
      if (a == b) return 1.0
      return Real64(this-a) / Real64(b-a)

    method required_bit_count->Int32
      if (this < 0)
        if (this < 0xC000_0000) return 32
        local bits = 1
        local threshold = -1
        while (this < threshold)
          ++bits
          threshold = threshold :<<: 1
        endWhile
        return bits
      endIf

      if (this & 0x8000_0000) return 32
      if (this & 0x4000_0000) return 31
      local bits = 1
      while ((1:<<:bits) <= this) ++bits
      return bits

    method right_justified( spaces:Int32, fill=' ':Character )->String
      return this->String.right_justified( spaces, fill )

    method rol( nbits:Int32 )->Int32
      if (nbits <= 0) return this
      nbits &= 31
      return (this :<<: nbits) | (this :>>: (32-nbits))

    method ror( nbits:Int32 )->Int32
      if (nbits <= 0) return this
      nbits &= 31
      return (this :>>: nbits) | (this :<<: (32-nbits))
      }#

    method sqrt->Int32
      return native("sqrt($this)")->Int32

      #{
    method th->String
      return this->Int64.th

    method to->Int64 [macro]
      return native "((RogueInt64)$this)"

    method to->Int64( unsigned:Logical )
      if (unsigned) return this & 0x0FFFFffff
      else          return this->Int64

    method to->Object
      return Boxed<<Int32>>(this)
      }#

    method to->String
      which (this)
        case -1: return "-1"
        case  0: return "0"
        case  1: return "1"
        case  2: return "2"
        case  3: return "3"
        case  4: return "4"
        case  5: return "5"
        case  6: return "6"
        case  7: return "7"
        case  8: return "8"
        case  9: return "9"
        others:  return String().[ print(this) ]
      endWhich

      #{
    method to->String( digits=0:Int32, &hex, &octal, &binary )
      if (hex)    return to_hex_string( which{digits||8} )
      if (octal)  return to_octal_string( which{digits||11} )
      if (binary) return to_binary_string( which{digits||32} )
      return this

    method to->Value
      return Value( this )

    method to_digit( &base64 )->Character
      if (base64)
        if (this >= 0  and this <= 25) return (this + 'A')->Character
        if (this >= 26 and this <= 51) return ((this-26) + 'a')->Character
        if (this >= 52 and this <= 61) return ((this-52) + '0')->Character
        if (this == 62) return '+'
        if (this == 63) return '/'
        return '='
      else
        if (this >= 0 and this <= 9)   return (this + '0')->Character
        if (this >= 10 and this <= 35) return ((this - 10) + ('A'))->Character
        return '0'
      endIf

    method to_binary_string( digits=32:Int32 )->String
      return (this->Int64 & 0x00FFFFFFFF).print_in_power2_base( 2, digits, StringBuilder() )->String

    method to_hex_character->Character
      if (this < 0 or this > 35) return '0'
      if (this <= 9) return Character( '0' + this )
      return Character( 'A' + (this-10) )

    method to_hex_string( digits=8:Int32 )->String
      return (this->Int64 & 0x00FFFFFFFF).print_in_power2_base( 16, digits, StringBuilder() )->String

    method to_octal_string( digits=11:Int32 )->String
      return (this->Int64 & 0x00FFFFFFFF).print_in_power2_base( 8, digits, StringBuilder() )->String

    method to_power_of_two->Int32
      if (this & 0xC0000000 or not this) return this
      local p2 = 1
      while (p2 < this) p2 = p2 :<<: 1
      return p2

    method sign->Int32
      return which{ this>0:1 || this<0:-1 || 0 }

      unitTest assert( 5.sign  == 1 )
      unitTest assert( 0.sign  == 0 )
      unitTest assert( -5.sign == -1 )
      }#
endClass

class Character [primitive]
  GLOBAL METHODS
    method create( value:Int32 )->Character
      return value->Character

  METHODS
    method is_letter->Logical
      return (this >= 'a' and this <= 'z') or
             (this >= 'A' and this <= 'Z')

    method is_lowercase->Logical
      return (this >= 'a' and this <= 'z')

    method is_uppercase->Logical
      return (this >= 'A' and this <= 'Z')

    method operator%( other:Character )->Int32
      return this->Int32 % other->Int32

    method operator:>>:( bits:Int32 )->Int32
      return this->Int32 :>>: bits

#{
    method print_escaped_ascii( writer:PrintWriter, additional_characters_to_escape="":String )
      which (this)
        case '\\': writer.print( "\\\\" )
        case '\0': writer.print( "\\0" )
        case '\b': writer.print( "\\b" )
        case '\e': writer.print( "\\e" )
        case '\f': writer.print( "\\f" )
        case '\n': writer.print( "\\n" )
        case '\r': writer.print( "\\r" )
        case '\t': writer.print( "\\t" )
        case '\v': writer.print( "\\v" )
        others
          if (additional_characters_to_escape.contains(this))
            writer.print( "\\" ).print( this )
          elseIf (this >= 256)
            writer.print( "\\[" )
            this->Int64.print_in_power2_base( 16, 3, writer )
            writer.print( ']' )
          elseIf (this < 32 or this >= 127)
            writer.print( "\\x" )
            this->Int64.print_in_power2_base( 16, 2, writer )
          else
            writer.print( this )
          endIf
      endWhich
}#

    method to_lowercase->Character
      if (not is_uppercase) return this
      return Character( this + ('a'-'A') )

    method to_uppercase->Character
      if (not is_lowercase) return this
      return Character( this + ('A'-'a') )

    method to->String
      which (this)
        case   0: return "\0"
        case   8: return "\b"
        case   9: return "\t"
        case  10: return "\n"
        case  11: return "\v"
        case  12: return "\f"
        case  13: return "\r"
        case  27: return "\e"
        case  32: return " "
        case  33: return "!"
        case  34: return ''"''
        case  35: return "#"
        case  36: return "$"
        case  37: return "%"
        case  38: return "&"
        case  39: return "'"
        case  40: return "("
        case  41: return ")"
        case  42: return "*"
        case  43: return "+"
        case  44: return ","
        case  45: return "-"
        case  46: return "."
        case  47: return "/"
        case  48: return "0"
        case  49: return "1"
        case  50: return "2"
        case  51: return "3"
        case  52: return "4"
        case  53: return "5"
        case  54: return "6"
        case  55: return "7"
        case  56: return "8"
        case  57: return "9"
        case  58: return ":"
        case  59: return ";"
        case  60: return "<"
        case  61: return "="
        case  62: return ">"
        case  63: return "?"
        case  64: return "@"
        case  65: return "A"
        case  66: return "B"
        case  67: return "C"
        case  68: return "D"
        case  69: return "E"
        case  70: return "F"
        case  71: return "G"
        case  72: return "H"
        case  73: return "I"
        case  74: return "J"
        case  75: return "K"
        case  76: return "L"
        case  77: return "M"
        case  78: return "N"
        case  79: return "O"
        case  80: return "P"
        case  81: return "Q"
        case  82: return "R"
        case  83: return "S"
        case  84: return "T"
        case  85: return "U"
        case  86: return "V"
        case  87: return "W"
        case  88: return "X"
        case  89: return "Y"
        case  90: return "Z"
        case  91: return "["
        case  92: return "\\"
        case  93: return "]"
        case  94: return "^"
        case  95: return "_"
        case  96: return "`"
        case  97: return "a"
        case  98: return "b"
        case  99: return "c"
        case 100: return "d"
        case 101: return "e"
        case 102: return "f"
        case 103: return "g"
        case 104: return "h"
        case 105: return "i"
        case 106: return "j"
        case 107: return "k"
        case 108: return "l"
        case 109: return "m"
        case 110: return "n"
        case 111: return "o"
        case 112: return "p"
        case 113: return "q"
        case 114: return "r"
        case 115: return "s"
        case 116: return "t"
        case 117: return "u"
        case 118: return "v"
        case 119: return "w"
        case 120: return "x"
        case 121: return "y"
        case 122: return "z"
        case 123: return "{"
        case 124: return "|"
        case 125: return "}"
        case 126: return "~"
        others
          return String().[ print(this) ]
      endWhich

endClass

class Byte : CommonPrimitiveMethods<<Byte>> [primitive]
  METHODS
    method operator%( other:Byte )->Byte
      return (this->Int32 % other->Int32)->Byte

    method operator:>>:( bits:Int32 )->Byte
      return (this->Int32 :>>: bits)->Byte

    method to->String
      return this->Int32->String
endClass

class Logical [primitive]
  METHODS
    method description->String
      return this->String

    method to->String
      return which{ this:"true" || "false" }
endClass

class CommonPrimitiveMethods<<$DataType>> [aspect]
  METHODS
    method clamped( low:$DataType, high:$DataType )->$DataType
      if (this < low)  return low
      if (this > high) return high
      return this

    method clamped_low( low:$DataType )->$DataType
      if (this < low) return low
      return this

    method clamped_high( high:$DataType )->$DataType
      if (this > high) return high
      return this

    method description->String
      return this->String

    method or_larger( other:$DataType )->$DataType
      return which{ this>=other:this || other }

    method or_smaller( other:$DataType )->$DataType
      return which{ this<=other:this || other }

endClass

