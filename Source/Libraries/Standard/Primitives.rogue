class Real64 : CommonPrimitiveMethods<<Real64>> [primitive]
  GLOBAL METHODS
    method create( value:Real64 )->Real64
      return value

  METHODS
    method abs->Real64
      if (this >= 0) return this
      else           return -this

    method acos->Real64
      return native("acos($this)")->Real64

    method atan->Real64
      return native("atan($this)")->Real64

    method atan2( x:Real64 )->Real64
      # Equivalent to atan2(this,x)
      return native("atan2($this,$x)")->Real64

    method asin->Real64
      return native("asin($this)")->Real64

    method ceiling->Real64
      return native("ceil($this)")->Real64

    method cos->Real64
      return native("cos($this)")->Real64

    method exp->Real64
      return native("exp($this)")->Real64

    method floor->Real64
      return native("floor($this)")->Real64

    method integer_bits->Int64
      return native("*((RogueInt64*)&$this)")->Int64

    method is_infinite->Logical
      # Returns true for positive OR negative infinity
      return (this == this) and (this - this != 0)

    method is_NaN->Logical
      return (this != this)

    method lerp( a:Int32, b:Int32 )->Int32
      # Assumes this Real64 is a progress value in the 0.0 to 1.0 range.
      # Returns the position from 'a' to 'b' based on this progress.
      return a + (b-a) * this

    method lerp( a:Real64, b:Real64 )->Real64
      # Assumes this Real64 is a progress value in the 0.0 to 1.0 range.
      # Returns the position from 'a' to 'b' based on this progress.
      return a + (b-a) * this

    method log->Real64
      return native("log($this)")->Real64

    method log2->Real64
      return native("log2($this)")->Real64

    method log10->Real64
      return native("log10($this)")->Real64

    method operator%( other:Real64 )->Real64
      local q = this / other
      return this - q.floor * other

    method sin->Real64
      return native("sin($this)")->Real64

    method sqrt->Real64
      return native("sqrt($this)")->Real64

    method tan->Real64
      return native("tan($this)")->Real64

    method to->String
      return String().[ print(this) ]

endClass

class Real32 : CommonPrimitiveMethods<<Real32>> [primitive]
  GLOBAL METHODS
    method create( value:Real32 )->Real32
      return value

  METHODS
    method abs->Real32
      if (this >= 0) return this
      else           return -this

    method acos->Real32
      return native("acosf($this)")->Real32

    method atan->Real32
      return native("atanf($this)")->Real32

    method atan2( x:Real32 )->Real32
      # Equivalent to atan2(this,x)
      return native("atan2f($this,$x)")->Real32

    method asin->Real32
      return native("asinf($this)")->Real32

    method ceiling->Real32
      return native("ceilf($this)")->Real32

    method cos->Real32
      return native("cosf($this)")->Real32

    method exp->Real32
      return native("expf($this)")->Real32

    method floor->Real32
      return native("floorf($this)")->Real32

    method integer_bits->Int64
      return native("*((RogueInt64*)&$this)")->Int64

    method is_infinite->Logical
      # Returns true for positive OR negative infinity
      return (this == this) and (this - this != 0)

    method is_NaN->Logical
      return (this != this)

    method lerp( a:Int32, b:Int32 )->Int32
      # Assumes this Real32 is a progress value in the 0.0 to 1.0 range.
      # Returns the position from 'a' to 'b' based on this progress.
      return a + (b-a) * this

    method lerp( a:Real32, b:Real32 )->Real32
      # Assumes this Real32 is a progress value in the 0.0 to 1.0 range.
      # Returns the position from 'a' to 'b' based on this progress.
      return a + (b-a) * this

    method log->Real32
      return native("logf($this)")->Real32

    method log2->Real32
      return native("log2f($this)")->Real32

    method log10->Real32
      return native("log10f($this)")->Real32

    method operator%( other:Real32 )->Real32
      local q = this / other
      return this - q.floor * other

    method sin->Real32
      return native("sinf($this)")->Real32

    method sqrt->Real32
      return native("sqrtf($this)")->Real32

    method tan->Real32
      return native("tanf($this)")->Real32

    method to->String
      return String().[ print(this) ]

endClass

class Int64 : CommonPrimitiveMethods<<Int64>> [primitive]
  GLOBAL METHODS
    method create( value:Int64 )->Int64
      return value

    method maximum->Int64
      return 0x7FFF_FFFF_FFFF_FFFF

    method minimum->Int64
      return 0x8000_0000_0000_0000

  METHODS
    #{
    method format( fmt:String, bits=64:Int32 )->String
      # fmt
      #   Semi-C-style "$%,0N" - attributes can come in any order
      #   '$' - make hexadecimal
      #   '%' - make binary
      #   ',' - add commas (decimal formatting only)
      #   '0' - pad with 0's instead of spaces
      #   'N' - Minimum digits
      local is_hex = false
      local is_binary = false
      local add_commas = false
      local zero_fill = false
      local number_start : Int32?
      forEach (ch at index in fmt)
        which (ch)
          case '$': is_hex = true
          case '%': is_binary = true
          case ',': add_commas = true
          case '0': zero_fill = true
          others:   number_start = index; escapeForEach
        endWhich
      endForEach

      local digits = 0
      if (number_start.exists) digits = fmt.from( number_start.value )

      if (is_hex)
        add_commas = false
        if (this < 0)
          digits = bits / 4
        else
          local n = 1
          local value = this :>>>: 4
          while (value) ++n; value = value :>>>: 4
          digits = digits.or_larger( n )
        endIf

      elseIf (is_binary)
        add_commas = false
        if (this < 0)
          digits = bits
        else
          local n = 1
          local value = this :>>>: 1
          while (value) ++n; value = value :>>>: 1
          digits = digits.or_larger( n )
        endIf

      endIf

      if (zero_fill) add_commas = false

      local result : String
      if (is_hex)        result = this->String( digits, &hex )
      elseIf (is_binary) result = this->String( digits, &binary )
      else               result = this->String

      if (zero_fill) result = result.right_justified( digits, '0' )

      if (add_commas)
        local work = result
        result = ""
        while (work.count > 3)
          if (result.count) result = ',' + result
          result = work.rightmost( 3 ) + result
          work = work.leftmost( -3 )
        endWhile
        if (work.count)
          if (result.count) result = work + ',' + result
          else              result = work
        endIf
      endIf

      if (result.begins_with("-,"))
        result = '-' + result.rightmost(-2)
      endIf

      if (not zero_fill) result = result.right_justified( digits, ' ' )

      return result
    }#

    method operator%( other:Int64 )->Int64
      if ((not this and not other) or other == 1) return 0

      local r = native("$this % $other")->Int64
      if ((this ~ other) < 0)
        if (r) return r + other
        else   return 0
      else
        return r
      endIf

    method operator:>>:( bits:Int64 )->Int64
      if (bits <= 0) return this

      --bits
      if (bits) return ((this :>>>: 1) & 0x7fffFFFFffffFFFF) :>>>: bits
      else      return (this :>>>: 1) & 0x7fffFFFFffffFFFF

    method print_power_of_2( base:Int32, digits:Int32, buffer:PrintWriter )->PrintWriter
      local bits = 0
      local temp = base
      while (temp > 1) ++bits; temp = temp:>>>:1

      local remaining = this :>>: bits
      if (digits > 1 or remaining) remaining.print_power_of_2( base, digits-1, buffer )
      buffer.print( (this & (base-1))->Int32.to_digit )
      return buffer

    method real_bits->Real64
      return native("*((RogueReal64*)&$this)")->Real64

    method to->String
      which (this)
        case -1: return "-1"
        case  0: return "0"
        case  1: return "1"
        case  2: return "2"
        case  3: return "3"
        case  4: return "4"
        case  5: return "5"
        case  6: return "6"
        case  7: return "7"
        case  8: return "8"
        case  9: return "9"
        others:  return String().[ print(this) ]
      endWhich

    method to->String( digits=0:Int32, &binary, &hex, &octal )
      if (binary) return print_power_of_2(  2, which{digits||64}, String() )->(as String)
      if (hex)    return print_power_of_2( 16, which{digits||16}, String() )->(as String)
      if (octal)  return print_power_of_2(  8, which{digits||22}, String() )->(as String)
      return this->String
endClass

class Int32 : CommonPrimitiveMethods<<Int32>> [primitive]
  GLOBAL METHODS
    method create( value:Int32 )->Int32
      return value

    #method from_value( value:Value )->Int32
      #return value->Int32

    method maximum->Int32
      return 2147483647

    method minimum->Int32
      return 0x8000_0000

  METHODS
    method abs->Int32
      if (this >= 0) return this
      else           return -this

    method real_bits->Real32
      return native("*((RogueReal32*)&$this)")->Real32

      #{
    method digit_count->Int32
      use buffer = StringBuilder.pool
        return buffer.print( this ).count
      endUse

    method format( fmt:String )->String
      return Int64( this ).format( fmt, 32 )

    method hash_code->Int32
      return this

    method introspector->Introspector
      return BoxedIntrospector<<Int32>>( this->Object )

    method is_power_of_two->Logical
      return ((this & (this-1)) == 0)

    method left_justified( spaces:Int32, fill=' ':Character )->String
      return this->String.left_justified( spaces, fill )
      }#

    method operator%( other:Int32 )->Int32
      if ((not this and not other) or other == 1) return 0

      local r = native("$this % $other")->Int32
      if ((this ~ other) < 0)
        if (r) return r + other
        else   return 0
      else
        return r
      endIf

    method operator:>>:( bits:Int32 )->Int32
      if (bits <= 0) return this

      --bits
      if (bits) return ((this :>>>: 1) & 0x7fffFFFF) :>>>: bits
      else      return (this :>>>: 1) & 0x7fffFFFF

    method print_power_of_2( base:Int32, digits:Int32, buffer:PrintWriter )->PrintWriter
      local bits = 0
      local temp = base
      while (temp > 1) ++bits; temp = temp:>>>:1

      local remaining = this :>>: bits
      if (digits > 1 or remaining) remaining.print_power_of_2( base, digits-1, buffer )
      buffer.print( (this & (base-1)).to_digit )
      return buffer

      #{
    method progress( a:Int32, b:Int32 )->Real64
      # Returns the progress of this number along the interval from a to b.
      # Examples:
      #   2.progress(1,5) -> 0.25
      #   2.progress(5,1) -> 0.75
      if (a == b) return 1.0
      return Real64(this-a) / Real64(b-a)

    method required_bit_count->Int32
      if (this < 0)
        if (this < 0xC000_0000) return 32
        local bits = 1
        local threshold = -1
        while (this < threshold)
          ++bits
          threshold = threshold :<<: 1
        endWhile
        return bits
      endIf

      if (this & 0x8000_0000) return 32
      if (this & 0x4000_0000) return 31
      local bits = 1
      while ((1:<<:bits) <= this) ++bits
      return bits

    method right_justified( spaces:Int32, fill=' ':Character )->String
      return this->String.right_justified( spaces, fill )

    method rol( nbits:Int32 )->Int32
      if (nbits <= 0) return this
      nbits &= 31
      return (this :<<: nbits) | (this :>>: (32-nbits))

    method ror( nbits:Int32 )->Int32
      if (nbits <= 0) return this
      nbits &= 31
      return (this :>>: nbits) | (this :<<: (32-nbits))
      }#

    method sqrt->Int32
      return native("sqrt($this)")->Int32

      #{
    method th->String
      return this->Int64.th

    method to->Int64 [macro]
      return native "((RogueInt64)$this)"

    method to->Int64( unsigned:Logical )
      if (unsigned) return this & 0x0FFFFffff
      else          return this->Int64

    method to->Object
      return Boxed<<Int32>>(this)
      }#

    method to->String
      which (this)
        case -1: return "-1"
        case  0: return "0"
        case  1: return "1"
        case  2: return "2"
        case  3: return "3"
        case  4: return "4"
        case  5: return "5"
        case  6: return "6"
        case  7: return "7"
        case  8: return "8"
        case  9: return "9"
        others:  return String().[ print(this) ]
      endWhich

    method to->String( digits=0:Int32, &binary, &hex, &octal )
      if (binary) return print_power_of_2(  2, which{digits||32}, String() )->(as String)
      if (hex)    return print_power_of_2( 16, which{digits|| 8}, String() )->(as String)
      if (octal)  return print_power_of_2(  8, which{digits||11}, String() )->(as String)
      return this->String

      #{
    method to->Value
      return Value( this )
      }#

    method to_digit( &base64 )->Character
      if (base64)
        if (this >= 0  and this <= 25) return (this + 'A')->Character
        if (this >= 26 and this <= 51) return ((this-26) + 'a')->Character
        if (this >= 52 and this <= 61) return ((this-52) + '0')->Character
        if (this == 62) return '+'
        if (this == 63) return '/'
        return '='
      else
        if (this >= 0 and this <= 9)   return (this + '0')->Character
        if (this >= 10 and this <= 35) return ((this - 10) + ('A'))->Character
        return '0'
      endIf

      #{
    method to_power_of_two->Int32
      if (this & 0xC0000000 or not this) return this
      local p2 = 1
      while (p2 < this) p2 = p2 :<<: 1
      return p2

    method sign->Int32
      return which{ this>0:1 || this<0:-1 || 0 }

      unitTest assert( 5.sign  == 1 )
      unitTest assert( 0.sign  == 0 )
      unitTest assert( -5.sign == -1 )
      }#
endClass

class Character [primitive]
  GLOBAL METHODS
    method create( value:Int32 )->Character
      return value->Character

  METHODS
    method is_letter->Logical
      return (this >= 'a' and this <= 'z') or
             (this >= 'A' and this <= 'Z')

    method is_lowercase->Logical
      return (this >= 'a' and this <= 'z')

    method is_number( base=10:Int32 )->Logical
      return to_number(base)?

    method is_uppercase->Logical
      return (this >= 'A' and this <= 'Z')

    method operator%( other:Character )->Int32
      return this->Int32 % other->Int32

    method operator:>>:( bits:Int32 )->Int32
      return this->Int32 :>>: bits

#{
    method print_escaped_ascii( writer:PrintWriter, additional_characters_to_escape="":String )
      which (this)
        case '\\': writer.print( "\\\\" )
        case '\0': writer.print( "\\0" )
        case '\b': writer.print( "\\b" )
        case '\e': writer.print( "\\e" )
        case '\f': writer.print( "\\f" )
        case '\n': writer.print( "\\n" )
        case '\r': writer.print( "\\r" )
        case '\t': writer.print( "\\t" )
        case '\v': writer.print( "\\v" )
        others
          if (additional_characters_to_escape.contains(this))
            writer.print( "\\" ).print( this )
          elseIf (this >= 256)
            writer.print( "\\[" )
            this->Int64.print_power_of_2( 16, 3, writer )
            writer.print( ']' )
          elseIf (this < 32 or this >= 127)
            writer.print( "\\x" )
            this->Int64.print_power_of_2( 16, 2, writer )
          else
            writer.print( this )
          endIf
      endWhich
}#

    method to_lowercase->Character
      if (not is_uppercase) return this
      return Character( this + ('a'-'A') )

    method to_number( base=10:Int32 )->Int32?
      local value : Int32
      if (this >= '0' and this <= '9')     value = this - '0'
      elseIf (this >= 'A' and this <= 'Z') value = 10 + (this - 'A')
      elseIf (this >= 'a' and this <= 'z') value = 10 + (this - 'a')
      else return null

      if (value < base) return value
      else              return null

    method to_uppercase->Character
      if (not is_lowercase) return this
      return Character( this + ('A'-'a') )

    method to->String
      which (this)
        case   0: return "\0"
        case   8: return "\b"
        case   9: return "\t"
        case  10: return "\n"
        case  11: return "\v"
        case  12: return "\f"
        case  13: return "\r"
        case  27: return "\e"
        case  32: return " "
        case  33: return "!"
        case  34: return ''"''
        case  35: return "#"
        case  36: return "$"
        case  37: return "%"
        case  38: return "&"
        case  39: return "'"
        case  40: return "("
        case  41: return ")"
        case  42: return "*"
        case  43: return "+"
        case  44: return ","
        case  45: return "-"
        case  46: return "."
        case  47: return "/"
        case  48: return "0"
        case  49: return "1"
        case  50: return "2"
        case  51: return "3"
        case  52: return "4"
        case  53: return "5"
        case  54: return "6"
        case  55: return "7"
        case  56: return "8"
        case  57: return "9"
        case  58: return ":"
        case  59: return ";"
        case  60: return "<"
        case  61: return "="
        case  62: return ">"
        case  63: return "?"
        case  64: return "@"
        case  65: return "A"
        case  66: return "B"
        case  67: return "C"
        case  68: return "D"
        case  69: return "E"
        case  70: return "F"
        case  71: return "G"
        case  72: return "H"
        case  73: return "I"
        case  74: return "J"
        case  75: return "K"
        case  76: return "L"
        case  77: return "M"
        case  78: return "N"
        case  79: return "O"
        case  80: return "P"
        case  81: return "Q"
        case  82: return "R"
        case  83: return "S"
        case  84: return "T"
        case  85: return "U"
        case  86: return "V"
        case  87: return "W"
        case  88: return "X"
        case  89: return "Y"
        case  90: return "Z"
        case  91: return "["
        case  92: return "\\"
        case  93: return "]"
        case  94: return "^"
        case  95: return "_"
        case  96: return "`"
        case  97: return "a"
        case  98: return "b"
        case  99: return "c"
        case 100: return "d"
        case 101: return "e"
        case 102: return "f"
        case 103: return "g"
        case 104: return "h"
        case 105: return "i"
        case 106: return "j"
        case 107: return "k"
        case 108: return "l"
        case 109: return "m"
        case 110: return "n"
        case 111: return "o"
        case 112: return "p"
        case 113: return "q"
        case 114: return "r"
        case 115: return "s"
        case 116: return "t"
        case 117: return "u"
        case 118: return "v"
        case 119: return "w"
        case 120: return "x"
        case 121: return "y"
        case 122: return "z"
        case 123: return "{"
        case 124: return "|"
        case 125: return "}"
        case 126: return "~"
        others
          return String().[ print(this) ]
      endWhich

    method to->String( digits=0:Int32, &binary, &hex, &octal )
      return this->Int32->String( &=digits, &=binary, &=hex, &=octal )
endClass

class Byte : CommonPrimitiveMethods<<Byte>> [primitive]
  METHODS
    method operator%( other:Byte )->Byte
      return (this->Int32 % other->Int32)->Byte

    method operator:>>:( bits:Int32 )->Byte
      return (this->Int32 :>>: bits)->Byte

    method to->String
      return this->Int32->String

    method to->String( digits=0:Int32, &binary, &hex, &octal )
      if (binary) return this->Int32.print_power_of_2(  2, which{digits||8}, String() )->(as String)
      if (hex)    return this->Int32.print_power_of_2( 16, which{digits||2}, String() )->(as String)
      if (octal)  return this->Int32.print_power_of_2(  8, which{digits||3}, String() )->(as String)
      return this->String
endClass

class Logical [primitive]
  METHODS
    method description->String
      return this->String

    method to->String
      return which{ this:"true" || "false" }
endClass

class CommonPrimitiveMethods<<$DataType>> [aspect]
  METHODS
    method clamped( low:$DataType, high:$DataType )->$DataType
      if (this < low)  return low
      if (this > high) return high
      return this

    method clamped_low( low:$DataType )->$DataType
      if (this < low) return low
      return this

    method clamped_high( high:$DataType )->$DataType
      if (this > high) return high
      return this

    method description->String
      return this->String

    method or_larger( other:$DataType )->$DataType
      return which{ this>=other:this || other }

    method or_smaller( other:$DataType )->$DataType
      return which{ this<=other:this || other }

endClass

