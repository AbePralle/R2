class MethodInfo
  GLOBAL PROPERTIES
    method_table : MethodInfo[]

  PROPERTIES
    method_index    : Int32
    call_index      : Int32
    is_global       : Logical
    type_context    : TypeInfo
    name            : String
    signature       : String
    parameter_types = TypeInfo[]
    return_type     : TypeInfo
    attributes      : Int64

  GLOBAL METHODS
    method init_class
      method_table = Dim<<MethodInfo>>( native("Rogue_method_count")->Int32 )

    method create( method_index:Int32, is_global=false:Logical )->MethodInfo
      local m = method_table[method_index]
      if (m) return m

      m = MethodInfo()
      m.method_index = method_index
      m.is_global = is_global
      local data_index = native("Rogue_method_info[$method_index]")->Int32

      m.type_context = TypeInfo[ native("Rogue_method_data[$data_index]")->Int32 ]
      m.name = native("Rogue_string_table[ Rogue_method_data[++$data_index] ]")->String

      local n = native("Rogue_method_data[++$data_index]")->Int32
      m.parameter_types.reserve( n )
      loop n
        m.parameter_types.add( TypeInfo[ native("Rogue_method_data[++$data_index]")->Int32 ] )
      endLoop
      local return_type_index = native("Rogue_method_data[++$data_index]")->Int32
      if (return_type_index >= 0) m.return_type = TypeInfo[return_type_index]

      m.call_index = native("Rogue_method_data[++$data_index]")->Int32
      m.attributes = native("Rogue_method_data[++$data_index]")->Int32
      m.attributes = (m.attributes:<<:32) | ((native("Rogue_method_data[++$data_index]")->Int32->Int64) & 0xFFFF_FFFF)

      local sig_len = m.name.count + 2           # name()
      sig_len += (m.parameter_types.count - 1)   # commas
      sig_len += (forEach in m.parameter_types).name.count  # param type names
      if (m.return_type)
        sig_len += m.return_type.name.count + 2  # ->ReturnType
      endIf

      local sig = String(sig_len)
      sig.print m.name
      sig.print '('
      forEach (param_type at i in m.parameter_types)
        if (i > 0) sig.print ','
        sig.print param_type.module_name
        sig.print "::"
        sig.print param_type.name
      endForEach
      sig.print ')'
      m.signature = sig

      method_table[method_index] = m
      return m

  METHODS
    method init
      noAction

    method call( context_or_args=undefined:Value )->Value
      # Call this global or object method.
      #
      # context_or_args
      #   Global methods: a single arg, a @[list], or 'undefined'.
      #   Object methods: call context
      if (is_global)
        return call_global_method( call_index, native("(RogueInt64)Rogue_method_pointers[$method_index]")->Int64, context_or_args )
      else
        return call_object_method( call_index, native("(RogueInt64)Rogue_method_pointers[$method_index]")->Int64, context_or_args, undefined )
      endIf

    method call( context:Value, args:Value )->Value
      # Call this object method.
      #
      # context
      #   The context object to call the method on.
      #
      # args
      #   A single arg, a @[list], or 'undefined'.
      return call_object_method( call_index, native("(RogueInt64)Rogue_method_pointers[$method_index]")->Int64, context, args )

    method to->String
      return signature

  GLOBAL METHODS
    method call_global_method( call_index:Int32, fnptr:Int64, args:Value )->Value [essential]
      # args
      #   A single arg, a @[list], or 'undefined'.

      # <Compiler will insert generated code here>

      return undefined

    method call_object_method( call_index:Int32, fnptr:Int64, context:Value, args:Value )->Value [essential]
      # context
      #   The context object to call the method on.
      #
      # args
      #   A single arg, a @[list], or 'undefined'.

      # <Compiler will insert generated code here>

      return undefined
endClass

