uses Geometry

class Value [compound]
  DEFINITIONS
    # Internal use.
    TYPE_UNDEFINED =  0
    TYPE_NULL      =  1
    TYPE_LOGICAL   =  2
    TYPE_BYTE      =  3
    TYPE_CHARACTER =  4
    TYPE_INT32     =  5
    TYPE_INT64     =  6
    TYPE_REAL32    =  7
    TYPE_REAL64    =  8
    TYPE_XY        =  9
    TYPE_BOX       = 10
    TYPE_OBJECT    = 11
    TYPE_STRING    = 12
    TYPE_LIST      = 13
    TYPE_TABLE     = 14

  PROPERTIES
    # All properties should be considered INTERNAL USE ONLY because they are
    # tricky - .type must be checked to know which property is valid.
    type      : Int32
    object    : Object # Can't be mixed into the union due to GC constraints

    box       : Box       [faux]
    byte      : Byte      [faux]
    character : Character [faux]
    int32     : Int32     [faux]
    int64     : Int64     [faux]
    logical   : Logical   [faux]
    real      : Real      [faux]
    real32    : Real32    [faux]
    real64    : Real32    [faux]
    xy        : XY        [faux]

    native @|union
            |{
            |  GeometryBox    box;
            |  RogueByte      byte;
            |  RogueCharacter character;
            |  RogueInt32     int32;
            |  RogueInt64     int64;
            |  RogueLogical   logical;
            |  RogueReal      real;
            |  RogueReal32    real32;
            |  RogueReal64    real64;
            |  GeometryXY     xy;
            |};

  GLOBAL METHODS
    method create->Value
      return native( "(RogueValue) { 0 }" )->Value  # undefined

    method create( value:Logical )->Value
      return native( "(RogueValue) {  2, 0, {.logical=$value} }" )->Value

    method create( value:Byte )->Value
      return native( "(RogueValue) {  3, 0, {.byte=$value} }" )->Value

    method create( value:Character )->Value
      return native( "(RogueValue) {  4, 0, {.character=$value} }" )->Value

    method create( value:Int32 )->Value
      return native( "(RogueValue) {  5, 0, {.int32=$value} }" )->Value

    method create( value:Int64 )->Value
      return native( "(RogueValue) {  6, 0, {.int64=$value} }" )->Value

    method create( value:Real32 )->Value
      return native( "(RogueValue) {  7, 0, {.real32=$value} }" )->Value

    method create( value:Real64 )->Value
      return native( "(RogueValue) {  8, 0, {.real64=$value} }" )->Value

    method create( value:XY )->Value
      return native( "(RogueValue) {  9, 0, {.xy=$value} }" )->Value

    method create( value:Box )->Value
      return native( "(RogueValue) { 10, 0, {.box=$value} }" )->Value

    method create( value:Object )->Value [preferred]
      if (value) return native( "(RogueValue) { 11, $value }" )->Value
      else       return native( "(RogueValue) { 1 }" )->Value  # null value

    method create( value:String )->Value
      if (value) return native( "(RogueValue) { 12, (RogueObject*)$value }" )->Value
      else       return native( "(RogueValue) { 1 }" )->Value  # null value

    method create( value:Value[] )->Value
      if (value) return native( "(RogueValue) { 13, (RogueObject*)$value }" )->Value
      else       return native( "(RogueValue) { 1 }" )->Value  # null value

    method create( value:[String:Value] )->Value
      if (value) return native( "(RogueValue) { 14, (RogueObject*)$value }" )->Value
      else       return native( "(RogueValue) { 1 }" )->Value  # null value

    method list->Value
      # Convenience syntax: @[] is equivalent to Value.list()
      local data = Value[]
      return native( "(RogueValue) { 13, (RogueObject*)$data }" )->Value

    method table->Value
      # Convenience syntax: @{} is equivalent to Value.table()
      local data = [String:Value]
      return native( "(RogueValue) { 14, (RogueObject*)$data }" )->Value

  METHODS
    method add( value:Value )
      which (type)
        case TYPE_LIST
          object->(as Value[]).add( value )
      endWhich

    method add_all( value:Value )
      which (type)
        case TYPE_LIST
          local list = object->(as Value[])
          list.reserve( value.count )
          list.add( forEach in value )
      endWhich

    method count->Int32
      which (type)
        case TYPE_STRING
          return object->(as String).count
        case TYPE_LIST
          return object->(as Value[]).count
        case TYPE_TABLE
          return object->(as [String:Value]).count
        case TYPE_UNDEFINED
          return 0
        others
          return 1
      endWhich

    method get( index:Int32 )->Value
      which (type)
        case TYPE_LIST
          local list = object->(as Value[])
          if (index < 0 or index >= list.count) return undefined
          return list[index]

        case TYPE_STRING
          local st = object->(as String)
          if (index < 0 or index >= st.count) return undefined
          return st[index]

        case TYPE_TABLE
          local table = object->(as [String:Value])
          if (index < 0 or index >= table.count) return undefined
          return table.at(index)

        others
          if (index == 0) return this
          return undefined
      endWhich

    method get( key:String )->Value
      which (type)
        case TYPE_TABLE
          return object->(as [String:Value])[ key ]
        others
          return undefined
      endWhich

    method is_collection->Logical
      which (type)
        case TYPE_STRING, TYPE_LIST, TYPE_TABLE
          return true
        others
          return false
      endWhich

    method set( index:Int32, value:Value )
      which (type)
        case TYPE_LIST
          local list = object->(as Value[])
          if (index < 0 or index >= list.count) return
          list[index] = value
      endWhich

    method set( key:String, value:Value )
      which (type)
        case TYPE_TABLE
          object->(as [String:Value])[ key ] = value
      endWhich

    method to->Box
      which (type)
        case TYPE_BOX:       return box
        case TYPE_XY:        return Box(xy)
        others:              return defaultValue<<Box>>
      endWhich

    method to->Byte
      which (type)
        case TYPE_BYTE:      return byte
        case TYPE_CHARACTER: return character->Byte
        case TYPE_INT32:     return int32->Byte
        case TYPE_INT64:     return int64->Byte
        case TYPE_REAL32:    return real32->Byte
        case TYPE_REAL64:    return real64->Byte
        case TYPE_OBJECT:    return (object->String->Int32)?
        case TYPE_STRING:    return (object->String->Int32)?
        others:              return 0
      endWhich

    method to->Character
      which (type)
        case TYPE_BYTE:      return byte->Character
        case TYPE_CHARACTER: return character
        case TYPE_INT32:     return int32->Character
        case TYPE_INT64:     return int64->Character
        case TYPE_REAL32:    return real32->Character
        case TYPE_REAL64:    return real64->Character
        case TYPE_OBJECT, TYPE_STRING
          local st = object->String
          if (st and st.count) return st[0]
          else                 return 0
        others:              return 0
      endWhich

    method to->Int32
      which (type)
        case TYPE_BYTE:      return byte->Int32
        case TYPE_CHARACTER: return character->Int32
        case TYPE_INT32:     return int32->Int32
        case TYPE_INT64:     return int64->Int32
        case TYPE_REAL32:    return real32->Int32
        case TYPE_REAL64:    return real64->Int32
        case TYPE_OBJECT:    return object->String->Int32
        case TYPE_STRING:    return object->String->Int32
        others:              return 0
      endWhich

    method to->Int64
      which (type)
        case TYPE_BYTE:      return byte->Int64
        case TYPE_CHARACTER: return character->Int64
        case TYPE_INT32:     return int32->Int64
        case TYPE_INT64:     return int64->Int64
        case TYPE_REAL32:    return real32->Int64
        case TYPE_REAL64:    return real64->Int64
        case TYPE_OBJECT:    return object->String->Int64
        case TYPE_STRING:    return object->String->Int64
        others:              return 0
      endWhich

    method to->Logical
      which (type)
        case TYPE_LOGICAL:   return logical
        case TYPE_BYTE:      return byte?
        case TYPE_CHARACTER: return character?
        case TYPE_INT32:     return int32?
        case TYPE_INT64:     return int64?
        case TYPE_REAL32:    return real32?
        case TYPE_REAL64:    return real64?
        case TYPE_XY:        return xy.x? or xy.y?
        case TYPE_BOX:       return box.size.x? or box.size.y?
        case TYPE_OBJECT:    return true
        case TYPE_STRING:    return true
        case TYPE_LIST:      return true
        case TYPE_TABLE:     return true
        others:              return false
      endWhich

    method to->Object
      which (type)
        case TYPE_OBJECT, TYPE_STRING: return object
        others:                        return null
      endWhich

    method to->Real32
      which (type)
        case TYPE_BYTE:      return byte->Real32
        case TYPE_CHARACTER: return character->Real32
        case TYPE_INT32:     return int32->Real32
        case TYPE_INT64:     return int64->Real32
        case TYPE_REAL32:    return real32->Real32
        case TYPE_REAL64:    return real64->Real32
        case TYPE_OBJECT:    return object->String->Real32
        case TYPE_STRING:    return object->String->Real32
        others:              return 0
      endWhich

    method to->Real64
      which (type)
        case TYPE_BYTE:      return byte->Real64
        case TYPE_CHARACTER: return character->Real64
        case TYPE_INT32:     return real64->Real64
        case TYPE_INT64:     return int64->Real64
        case TYPE_REAL32:    return real32->Real64
        case TYPE_REAL64:    return real64->Real64
        case TYPE_OBJECT:    return object->String->Real64
        case TYPE_STRING:    return object->String->Real64
        others:              return 0
      endWhich

    method to->String
      which (type)
        case TYPE_UNDEFINED: return ""
        case TYPE_NULL:      return "null"
        case TYPE_LOGICAL:   return logical->String
        case TYPE_BYTE:      return byte->String
        case TYPE_CHARACTER: return character->String
        case TYPE_INT32:     return int32->String
        case TYPE_INT64:     return int64->String
        case TYPE_REAL32:    return real32->String
        case TYPE_REAL64:    return real64->String
        case TYPE_XY:        return xy->String
        case TYPE_BOX:       return box->String
        case TYPE_OBJECT:    return object->String
        case TYPE_STRING:    return object->String
        case TYPE_LIST:      return object->(as Value[])->String
        case TYPE_TABLE:     return object->(as [String:Value])->String
        others:              return ""
      endWhich

    method to->XY
      which (type)
        case TYPE_XY:        return xy
        others:              return defaultValue<<XY>>
      endWhich

    method to<<$Type>>->$Type
      if (isPrimitive<<$Type>>)
        return this->$Type
      elseIf (isReference<<$Type>>)
        return this->Object->(as $Type)
      elseIf (isEnum<<$Type>>)
        local st = this->String
        if (st) return $Type(st)
        else    return $Type(0)
      elseIf ($Type isType XY or $Type isType Box)
        return this->$Type
      else
        local box = this->Object->(as Boxed<<$Type>>)
        if (box) return box->$Type
        return defaultValue<<$Type>>
      endIf

endClass

