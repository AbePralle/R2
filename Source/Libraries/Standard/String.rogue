class String
  PROPERTIES
    count           : Int32  # in whole characters
    cursor_offset   : Int32  # in bytes
    cursor_index    : Int32  # in characters
    hash_code       : Int32
    indent          : Int32
    at_newline      = true
    is_immutable    : Logical
    data            : Byte[]

  METHODS
    method init
      init( 20 )

    method init( byte_capacity:Int32 )
      data = Byte[]( byte_capacity + 1 )
      data[0] = 0

    method print( value:Character, &formatted=true )->this
      if (is_immutable) return this

      if (formatted)
        if (value == '\n')
          at_newline = true
        elseIf (at_newline and indent)
          forEach (i in 1..indent) data.add( ' ' )
          count += indent
          at_newline = false
        endIf
      endIf

      ++count
      if (value <= Character(0x7F))
        data.add( value )
      elseIf (value <= Character(0x7FF))
        data.[ add(0xC0 | (value:>>>:6)), add(0x80 | (value & 0x3F)) ]
      elseIf (value <= Character(0xFFFF))
        data.[ add(0xE0 | (value:>>>:12)), add(0x80 | ((value:>>>:6) & 0x3F)), add(0x80 | (value & 0x3F)) ]
      elseIf (value <= Character(0x10FFFF))
        data.[ add(0xF0 | (value:>>>:18)), add(0x80 | ((value:>>>:12) & 0x3F)) ]
        data.[ add(0x80 | ((value:>>>:6) & 0x3F)), add(0x80 | (value & 0x3F)) ]
      else
        data.add( '?' )
      endIf
      return this

    method print( value:Int64 )->this
      if (value == (1->Int64 :<<: 63))
        return print( "-9223372036854775808" )
      elseIf (value < 0)
        print( '-' )
        return print( -value )
      elseIf (value >= 10)
        print( value / 10 )
        return print( ('0'+(value%10))->Character )
      else
        return print( ('0'+value)->Character )
      endIf

    method print( value:String )->this
      if (is_immutable) return this

      if (value is null)
        print( "null" )
        return this
      endIf

      reserve( value.data.count )  # will include space for null terminator
      native ...
        @|memcpy( $this->data->as_utf8+$data->count, $value->data->as_utf8, $value->data->count );
         |$this->count       += $value->count;
         |$this->data->count += $value->data->count;
         |$hash_code = RogueString_compute_hash_code( $value, $hash_code );
         |$this->data->as_utf8[$this->data->count] = 0;

      return this

    method reserve( additional_bytes:Int32 )
      data.reserve( additional_bytes+1 ) # +1 for null terminator

  NATIVE
    nativeHeader @|RogueString* RogueString_create( const char* cstring, int byte_count, int must_free );
                  |RogueString* RogueString_create_from_ascii256( const char* cstring, int byte_count, int must_free );
                  |RogueInt32   RogueString_compute_hash_code( RogueString* THIS, RogueInt32 starting_hash );
                  |const char*  RogueString_to_c_string( RogueString* st );
                  |RogueInt32   RogueString_utf8_character_count( const char* cstring, int byte_count );

    nativeCode  @|RogueString* RogueString_create( const char* cstring, int byte_count, int must_free )
                 |{
                 |  if (byte_count == -1) byte_count = (int) strlen(cstring);
                 |  RogueInt32 character_count = RogueString_utf8_character_count( cstring, byte_count );
                 |  if (character_count == -1) return RogueString_create_from_ascii256( cstring, byte_count, must_free );
                 |
                 |  RogueString* result = ROGUE_RETAIN( ROGUE_CREATE_OBJECT(RogueString) );
                 |  RogueByteList* data = ROGUE_RETAIN( ROGUE_CREATE_OBJECT(RogueByteList) );
                 |  result->data = data;
                 |
                 |  data->as_utf8        = (char*) cstring;
                 |  data->count          = byte_count;
                 |  data->capacity       = byte_count + 1;
                 |  data->is_borrowed    = !must_free;
                 |
                 |  result->count        = character_count;
                 |  result->is_immutable = !must_free;
                 |  result->hash_code = RogueString_compute_hash_code( result, 0 );
                 |  return result;
                 |}
                 |
                 |RogueString* RogueString_create_from_ascii256( const char* cstring, int byte_count, int must_free )
                 |{
                 |  if (byte_count == -1) byte_count = (int) strlen(cstring);
                 |
                 |  int utf8_byte_count = 0;
                 |  int i;
                 |  for (i=byte_count; --i>=0; )
                 |  {
                 |    if (cstring[i] & 0x80) utf8_byte_count += 2;
                 |    else                   ++utf8_byte_count;
                 |  }
                 |
                 |  if (utf8_byte_count == byte_count)
                 |  {
                 |    return RogueString_create( cstring, byte_count, must_free );
                 |  }
                 |
                 |  RogueString* result = ROGUE_RETAIN( ROGUE_CREATE_OBJECT(RogueString) );
                 |  RogueString__init__RogueInt32( result, utf8_byte_count );
                 |
                 |  char* utf8 = result->data->as_utf8;
                 |  int dest_i = 0;
                 |  for (i=-1; ++i<byte_count; )
                 |  {
                 |    char ch = cstring[i];
                 |    if (ch & 0x80)
                 |    {
                 |      // %aaaaaaaa ->
                 |      // %110x xxaa 10aa aaaa
                 |      utf8[dest_i]   = 0xC0 | ((ch >> 6) & 0x03);
                 |      utf8[dest_i+1] = 0x80 | ((ch >> 2) & 0x3F);
                 |      dest_i += 2;
                 |    }
                 |    else
                 |    {
                 |      utf8[dest_i++] = ch;
                 |    }
                 |  }
                 |  utf8[ utf8_byte_count ] = 0;
                 |
                 |  result->data->count = utf8_byte_count;
                 |  result->count       = byte_count;
                 |  result->hash_code   = RogueString_compute_hash_code( result, 0 );
                 |
                 |  if (must_free) ROGUE_FREE( (void*)cstring );
                 |
                 |  return result;
                 |}
                 |
                 |RogueInt32 RogueString_compute_hash_code( RogueString* THIS, RogueInt32 starting_hash )
                 |{
                 |  RogueInt32 hash = starting_hash;
                 |  int n = THIS->data->count;
                 |  char* src = THIS->data->as_utf8 - 1;
                 |  while (--n >= 0)
                 |  {
                 |    hash = ((hash<<3) - hash) + *(++src);
                 |  }
                 |  return hash;
                 |}
                 |
                 |const char* RogueString_to_c_string( RogueString* st )
                 |{
                 |  if ( !st ) { return "null"; }
                 |  return st->data->as_utf8;
                 |}
                 |
                 |RogueInt32 RogueString_utf8_character_count( const char* cstring, int byte_count )
                 |{
                 |  // Returns -1 if 'cstring' is not a valid UTF-8 string.
                 |  if (byte_count == -1) byte_count = strlen(cstring);
                 |
                 |  RogueInt32 character_count = 0;
                 |  int i;
                 |  for (i=0; i<byte_count; ++character_count)
                 |  {
                 |    int b = cstring[ i ];
                 |    if (b & 0x80)
                 |    {
                 |      if ( !(b & 0x40) ) { return -1;}
                 |
                 |      if (b & 0x20)
                 |      {
                 |        if (b & 0x10)
                 |        {
                 |          // %11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                 |          if (b & 0x08) { return -1;}
                 |          if (i + 4 > byte_count || ((cstring[i+1] & 0xC0) != 0x80) || ((cstring[i+2] & 0xC0) != 0x80)
                 |              || ((cstring[i+3] & 0xC0) != 0x80)) { return -1;}
                 |          i += 4;
                 |        }
                 |        else
                 |        {
                 |          // %1110xxxx 10xxxxxx 10xxxxxx
                 |          if (i + 3 > byte_count || ((cstring[i+1] & 0xC0) != 0x80) || ((cstring[i+2] & 0xC0) != 0x80))
                 |          {
                 |            return -1;
                 |          }
                 |          i += 3;
                 |        }
                 |      }
                 |      else
                 |      {
                 |        // %110x xxxx 10xx xxxx
                 |        if (i + 2 > byte_count || ((cstring[i+1] & 0xC0) != 0x80)) { return -1; }
                 |        i += 2;
                 |      }
                 |    }
                 |    else
                 |    {
                 |      ++i;
                 |    }
                 |  }
                 |
                 |  return character_count;
                 |}
                 |
endClass

