class String
  GLOBAL PROPERTIES
    pool = StringPool()

  PROPERTIES
    count           : Int32  # in whole characters
    cursor_offset   : Int32  # in bytes
    cursor_index    : Int32  # in characters
    hash_code       = -1
    indent          : Int32
    at_newline      = true
    is_immutable    : Logical
    is_ascii        : Logical  # makes indexing easier if true
    data            : Byte[]

  GLOBAL METHODS
    method create( data:Byte[] )->String
      local count = native("RogueString_utf8_character_count($data->as_utf8,$data->count)")->Int32
      if (count == -1)
        # Not valid UTF-8 - treat as ASCII-256
        return native("RogueString_create_from_ascii256( $data->as_utf8, $data->count, 1 )")->String
      else
        return String( data, count )
      endIf

    method exists( string:String )->Logical
      # Returns false if the string is null or empty; otherwise returns true.
      return (string and string.count?)

    method operator==( a:String, b:String )->Logical
      if (a is null)     return (b is null)
      elseIf (b is null) return false

      if (a.hash_code != b.hash_code or a.count != b.count) return false
      return native("(0==memcmp($a->data->as_utf8,$b->data->as_utf8,$a->data->count))")->Logical

    method operator<>( a:String, b:String )->Int32
      if (a is b) return 0

      if (a is null)     return -1
      elseIf (b is null) return  1

      native @|RogueInt32 a_count = $a->data->count;
              |RogueInt32 b_count = $b->data->count;
              |
              |int result;
              |if (a_count == b_count)
              |{
              |  // Strings are same length
              |  result = memcmp( $a->data->as_utf8, $b->data->as_utf8, a_count );
              |  if (result == 0) return 0;
              |}
              |else
              |{
              |  // Strings differ in length.  Compare the same-length parts first.
              |  if (a_count > b_count) a_count = b_count;
              |  result = memcmp( $a->data->as_utf8, $b->data->as_utf8, a_count );
              |  if (result == 0)
              |  {
              |    // Equal so far - the shorter string comes before the longer one.
              |    if (a_count == b_count) return 1;
              |    return -1;
              |  }
              |}
              |if (result < 0) return -1;
              |else            return  1;

    method operator+( left:String, right:Byte )->String
      if (left) return String().[ reserve(left.count+3), print(left), print(right) ]
      else      return String().[ print("null"), print(right) ]

    method operator+( left:String, right:Character )->String
      if (left) return String().[ reserve(left.count+4), print(left), print(right) ]
      else      return String().[ print("null"), print(right) ]

    method operator+( left:String, right:Int32 )->String
      if (left) return String().[ reserve(left.count+11), print(left), print(right) ]
      else      return String().[ print("null"), print(right) ]

    method operator+( left:String, right:Int64 )->String
      use builder = String.pool
        builder.print( right )
        if (left) return String().[ reserve(left.count+builder.count), print(left), print(builder) ]
        else      return String().[ reserve(4+builder.count), print("null"), print(builder) ]
      endUse

    method operator+( left:String, right:Logical )->String
      if (left) return String().[ reserve(left.count+5), print(left), print(right) ]
      else      return String().[ print("null"), print(right) ]

    method operator+( left:String, right:Object )->String
      if (right is null) return operator+( left, "null" )

      use builder = String.pool
        builder.print( right->String )
        if (left) return String().[ reserve(left.count+builder.count), print(left), print(builder) ]
        else      return String().[ reserve(4+builder.count), print("null"), print(builder) ]
      endUse

    method operator+( left:String, right:Real32 )->String
      use builder = String.pool
        builder.print( right )
        if (left) return String().[ reserve(left.count+builder.count), print(left), print(builder) ]
        else      return String().[ reserve(4+builder.count), print("null"), print(builder) ]
      endUse

    method operator+( left:String, right:Real64 )->String
      use builder = String.pool
        builder.print( right )
        if (left) return String().[ reserve(left.count+builder.count), print(left), print(builder) ]
        else      return String().[ reserve(4+builder.count), print("null"), print(builder) ]
      endUse

    method operator+( left:String, right:String )->String
      if (right is null) return operator+( left, "null" )
      if (left) return String().[ reserve(left.count+right.count), print(left), print(right) ]
      else      return String().[ reserve(4+right.count), print("null"), print(right) ]

    method operator*( left:String, right:Int32 )->String
      if (left is null) return operator*( "null", right )

      if (right <= 0) return ""
      if (right == 1) return left

      local result = String( left.count * right )
      loop (right) result.print( left )
      return result

    method operator*( left:Int32, right:String )->String
      return operator*( right, left )

    method operator/( prefix:String, suffix:String )->String
      return "$/$" (prefix.without_trailing('/'),suffix)

  METHODS
    method init
      init( 20 )

    method init( existing:String )
      count = existing.count
      hash_code = existing.hash_code
      is_ascii = existing.is_ascii
      data = existing.data.cloned
      data[count] = 0

    method init( byte_capacity:Int32 )
      data = Byte[]( byte_capacity + 1 )
      data[0] = 0
      is_ascii = true

    method init( data, count )
      # 'data' must be valid UTF-8.
      data.reserve(1)
      data[data.count] = 0
      is_ascii = (count == data.count)

    method before_suffix( ch:Character, &ignore_case )->String
      if (ends_with(ch,&=ignore_case)) return before_last( ch, &=ignore_case )
      else                             return this

    method before_suffix( st:String, &ignore_case )->String
      if (ends_with(st,&=ignore_case)) return before_last( st, &=ignore_case )
      else                             return this

    method begins_with( ch:Character, &ignore_case )->Logical
      if (ignore_case)
        return (count and this[0].to_lowercase == ch.to_lowercase)
      else
        return (count and this[0] == ch)
      endIf

    method begins_with( other:String, &ignore_case )->Logical
      return (count >= other.count and contains_at(other,0,&=ignore_case))
    method capacity->Int32
      return data.capacity

    method clear->this
      if (is_immutable) return this
      data.clear
      data[0] = 0
      count = 0
      indent = 0
      at_newline = true
      hash_code = -1
      return this

    method cloned->String
      return String( this )

    method contains( ch:Character, &ignore_case )->Logical
      return locate(ch,&=ignore_case)?

    method contains_at( substring:String, at_index:Int32, &ignore_case )->Logical
      if (at_index < 0 or not substring or substring.count == 0) return false

      if (ignore_case)
        if (at_index + substring.count > count) return false
        forEach (other_ch in substring)
          if (other_ch.to_lowercase != this[at_index].to_lowercase) return false
          ++at_index
        endForEach
        return true
      else
        cursor = at_index
        local other_count = substring.data.count
        if (cursor_offset + other_count > data.count) return false
        return native("(0 == memcmp($this->data->as_utf8 + $cursor_offset, $substring->data->as_utf8, $other_count))")->Logical
      endIf

    method ends_with( ch:Character, &ignore_case )->Logical
      if (ignore_case)
        return (count > 0 and this[count-1].to_lowercase == ch.to_lowercase)
      else
        return (count > 0 and this[count-1] == ch)
      endIf

    method ends_with( other:String, &ignore_case )->Logical
      local other_count = other.count
      return (count >= other_count and other_count > 0 and contains_at(other,count-other_count,&=ignore_case))

    method first->Character
      return this[0]

    method from( i1:Int32 )->String
      return from( i1, count-1 )

    method from( i1:Int32, i2:Int32 )->String
      if (i1 < 0)          i1 = 0
      elseIf (i2 >= count) i2 = count - 1

      if (i1 > i2)  return ""
      if (i1 == i2) return ""+this[i1]
      if (i1 == 0 and i2 == count-1) return this

      local byte_offset = set_cursor( i1 )
      local byte_limit  = set_cursor( i2+1 )
      local byte_count = byte_limit - byte_offset
      local result = String( byte_count )
      native @|memcpy( $result->data->as_utf8, $data->as_utf8+$byte_offset, $byte_count );
      return result

    method from_first( ch:Character, &ignore_case )->String
      local i = locate( ch, &=ignore_case )
      if (not i) return ""
      return from( i.value )

    method from_first( st:String, &ignore_case )->String
      local i = locate( st, &=ignore_case )
      if (not i) return ""
      return from( i.value )

    method from_last( ch:Character, &ignore_case )->String
      local i = locate_last( ch, &=ignore_case )
      if (i.exists) return from( i.value )
      else          return ""

    method from_last( st:String, &ignore_case )->String
      local i = locate_last( st, &=ignore_case )
      if (i.exists) return from( i.value )
      else          return ""

    method before( index:Int32 )->String
      # Returns the substring of this string that occur before
      # the given index.
      #
      # Equivalent to ''leftmost(index)''.
      return from(0,index-1)

    method before_first( ch:Character, &ignore_case )->String
      local i = locate( ch, &=ignore_case )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_first( st:String, &ignore_case )->String
      local i = locate( st, &=ignore_case )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_last( ch:Character, &ignore_case )->String
      local i = locate_last( ch, &=ignore_case )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_last( st:String, &ignore_case )->String
      local i = locate_last( st, &=ignore_case )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method get( index:Int32 )->Character
      cursor = index
      if (is_ascii) return data[index]

      native ...
        @|
         |char* utf8 = $data->as_utf8;
         |
         |RogueInt32 offset = $cursor_offset;
         |RogueCharacter ch = utf8[ offset ];
         |if (ch & 0x80)
         |{
         |  if (ch & 0x20)
         |  {
         |    if (ch & 0x10)
         |    {
         |      return ((ch&7)<<18)
         |          | ((utf8[offset+1] & 0x3F) << 12)
         |          | ((utf8[offset+2] & 0x3F) << 6)
         |          | (utf8[offset+3] & 0x3F);
         |    }
         |    else
         |    {
         |      return ((ch&15)<<12)
         |          | ((utf8[offset+1] & 0x3F) << 6)
         |          | (utf8[offset+2] & 0x3F);
         |    }
         |  }
         |  else
         |  {
         |    return ((ch&31)<<6)
         |        | (utf8[offset+1] & 0x3F);
         |  }
         |}
         |else
         |{
         |  return ch;
         |}

    method hash_code->Int32
      if (@hash_code == -1)
        native @|$hash_code = RogueString_compute_hash_code( $this, 0 );
      endIf
      return @hash_code

    method insert( ch:Character )->this
      local i1 = data.count
      print( ch )   # put new UTF8 bytes on end
      local n = data.count - i1
      data.shift( n ) # shift data right to make room for same bytes at beginning
      data.copy( i1+n, n, data, 0 ) # copy bytes to beginning
      data.discard_from(i1+n)
      hash_code = -1
      return this

    method last->Character
      return this[ count-1 ]

    method locate( ch:Character, optional_i1=null:Int32?, &ignore_case )->Int32?
      local i = 0
      local limit = count
      if (optional_i1.exists) i = optional_i1.value

      if (ignore_case)
        while (i < limit)
          if (this[i].to_lowercase == ch.to_lowercase) return i
          ++i
        endWhile
      else
        while (i < limit)
          if (this[i] == ch) return i
          ++i
        endWhile
      endIf
      return null

    method locate( other:String, optional_i1=null:Int32?, &ignore_case )->Int32?
      local other_count = other.count
      if (other_count == 1) return locate( other[0], optional_i1 )

      local this_limit = (count - other_count) + 1
      if (other_count == 0 or this_limit <= 0) return null

      forEach (i in which{optional_i1||0}..<this_limit)
        if (contains_at(other,i,&=ignore_case)) return i
      endForEach

      return null

    method locate_last( ch:Character, starting_index=null:Int32?, &ignore_case )->Int32?
      local i = count - 1
      if (starting_index.exists) i = starting_index.value

      if (ignore_case)
        while (i >= 0)
          if (this[i].to_lowercase == ch.to_lowercase) return i
          --i
        endWhile
      else
        while (i >= 0)
          if (this[i] == ch) return i
          --i
        endWhile
      endIf
      return null

    method locate_last( other:String, starting_index=null:Int32?, &ignore_case )->Int32?
      local other_count = other.count
      if (other_count == 1) return locate_last( other[0], starting_index )

      local this_limit = (count - other_count) + 1
      if (other_count == 0 or this_limit <= 0) return null

      local i : Int32
      if (starting_index)
        i = starting_index.value + 1
        if (i > this_limit) i = this_limit
      else
        i = this_limit
      endIf

      while (i > 0)
        --i
        if (contains_at(other,i,&=ignore_case)) return i
      endWhile

      return null

    method locate_nth( ch:Character, n:Int32, optional_i1=null:Int32?, &ignore_case )->Int32?
      # n=1 finds the first match from the left side (or optional first index), etc.
      local index = locate( ch, optional_i1, &=ignore_case )

      loop n - 1
        if (not index) return null
        index = locate( ch, index.value+1, &=ignore_case )
      endLoop

      return index

    method locate_nth( other:String, n:Int32, optional_i1=null:Int32?, &ignore_case )->Int32?
      # n=1 finds the first match from the left side (or optional first index), etc.
      local index = locate( other, optional_i1, &=ignore_case )

      loop n - 1
        if (not index) return null
        index = locate( other, index.value+1, &=ignore_case )
      endLoop

      return index

    method locate_nth_last( ch:Character, n:Int32, optional_i1=null:Int32?, &ignore_case )->Int32?
      # n=1 finds the first match from the right side (or optional first index), etc.
      local index = locate_last( ch, optional_i1, &=ignore_case )

      loop n - 1
        if (not index) return null
        index = locate_last( ch, index.value-1, &=ignore_case )
      endLoop

      return index

    method locate_nth_last( other:String, n:Int32, optional_i1=null:Int32?, &ignore_case )->Int32?
      # n=1 finds the first match from the right side (or optional first index), etc.
      local index = locate_last( other, optional_i1, &=ignore_case )

      loop n - 1
        if (not index) return null
        index = locate_last( other, index.value-1, &=ignore_case )
      endLoop

      return index

    method print( value:Byte )->this
      return print( value->Int64 )

    method print( value:Character )->this
      if (is_immutable) return this
      hash_code = -1  # invalidate

      if (value == '\n')
        at_newline = true
      elseIf (at_newline)
        if (indent)
          forEach (i in 1..indent) data.add(' ')
          count += indent
        endIf
        at_newline = false
      endIf

      ++count
      if (value <= Character(0x7F))
        data.add( value )
      else
        is_ascii = false
        if (value <= Character(0x7FF))
          data.[ add(0xC0 | (value:>>>:6)), add(0x80 | (value & 0x3F)) ]
        elseIf (value <= Character(0xFFFF))
          data.[ add(0xE0 | (value:>>>:12)), add(0x80 | ((value:>>>:6) & 0x3F)), add(0x80 | (value & 0x3F)) ]
        elseIf (value <= Character(0x10FFFF))
          data.[ add(0xF0 | (value:>>>:18)), add(0x80 | ((value:>>>:12) & 0x3F)) ]
          data.[ add(0x80 | ((value:>>>:6) & 0x3F)), add(0x80 | (value & 0x3F)) ]
        else
          data.add( '?' )
        endIf
      endIf
      return this

    method print( value:Int32 )->this
      return print( value->Int64 )

    method print( value:Int64 )->this
      if (value == (1->Int64 :<<: 63))
        return print( "-9223372036854775808" )
      elseIf (value < 0)
        print( '-' )
        return print( -value )
      elseIf (value >= 10)
        print( value / 10 )
        return print( ('0'+(value%10))->Character )
      else
        return print( ('0'+value)->Character )
      endIf

    method print( value:Logical )->this
      if (is_immutable) return this
      print( which{value:"true" || "false"} )
      return this

    method print( value:Object )->this
      if (is_immutable) return this

      if (value is null)
        print( "null" )
        return this
      endIf

      print( value->String )
      return this

    method print( value:Real32 )->this
      return this.print( value->Real64 ) # FIXME: have custom Real32 version using template methods

    method print( value:Real64 )->this
      if (is_immutable) return this

      if (value == 0)
        print( "0.0" )
        return this
      elseIf (value.is_infinite)
        if (value < 0) print( "-infinity" )
        else           print( "infinity" )
        return this
      elseIf (value.is_NaN)
        print( "NaN" )
        return this
      endIf

      if (value < 0)
        print( '-' )
        value = -value
      endIf

      # Display power of 10 exponent for numbers >= 1e16 or <= 1e-4
      if (value >= 1000000000000000.0)
        local pow10 = 0
        while (value >= 10.0)
          value /= 10.0
          ++pow10
        endWhile

        return print( value ).print( 'e' ).print( pow10->Int32 )
      endIf

      if (value < 0.00001)
        local pow10 = 0
        while (value < 0.1)
          value *= 10.0
          --pow10
        endWhile

        return print( value ).print( 'e' ).print( pow10->Int32 )
      endIf

      use builder = String.pool
        forEach (n in 1..18)
          if (_check_to_string(value,n,builder)) escapeForEach
        endForEach

        print builder
      endUse

      return this

    method _check_to_string( value:Real64, decimal_places:Int32, buffer:String )->Logical
      buffer.clear
      buffer.print( value, decimal_places )
      return (buffer->Real64 == value)

    method print( value:Real64, decimal_places:Int32 )->this
      if (is_immutable) return this

      if (value.is_infinite)
        if (value < 0) print( "-infinity" )
        else           print( "infinity" )
        return this
      elseIf (value.is_NaN)
        print( "NaN" )
        return this
      endIf

      use builder = String.pool
        if (value < 0 )
          builder.print( '-' )
          value = -value
        endIf

        local whole = value.floor
        value -= whole
        while (whole >= 10)
          builder.print( ('0' + ((whole%10)->Int32))->Character )
          whole /= 10
        endWhile
        builder.print( ('0' + ((whole%10)->Int32))->Character )

        builder.reverse

        if (decimal_places != 0)
          builder.print( '.' )
          forEach (1..decimal_places)
            value *= 10
            local digit = value.floor->Int32
            value -= digit
            builder.print( ('0' + digit)->Character )
          endForEach
        endIf
        if (value >= 0.5)
          builder.print( '5' )
          builder._round_off
        endIf
        print( builder )
      endUse

      return this

    method print( value:String )->this
      if (is_immutable) return this

      if (value is null)
        print( "null" )
        return this
      endIf

      if (value.count == 0) return this  # no change

      reserve( value.data.count )  # will include space for null terminator
      native ...
        @|memcpy( $this->data->as_utf8+$data->count, $value->data->as_utf8, $value->data->count );
         |$this->count       += $value->count;
         |$this->data->count += $value->data->count;
         |$this->data->as_utf8[$this->data->count] = 0;

      hash_code = -1;

      return this

    method remove_first->Character
      local result = this[ 0 ]
      if (is_immutable) return result

      cursor = 1
      data.shift( -cursor_offset )
      hash_code = -1
      --count
      data[count] = 0
      return result

    method remove_last->Character
      local result = this[ count-1 ]
      if (is_immutable) return result

      --count
      cursor = count
      data.discard_from( cursor_offset )
      hash_code = -1
      return result

    method reserve( additional_bytes:Int32 )
      if (is_immutable) return
      data.reserve( additional_bytes+1 ) # +1 for null terminator

    method reverse
      # Reverses the characters in this mutable String.
      if (is_immutable) return

      use builder=String.pool
        builder.reserve( count )
        builder.print( forEach in this step -1 )
        clear
        this.print builder
      endUse

    method reversed->String
      local result = String()
      result.reserve( count )
      result.print( forEach in this step -1 )
      return result

    method set_cursor( character_index:Int32 )->Int32
      # Sets this string's cursor_offset (in bytes) and cursor_index (in characters)
      if (is_ascii)
        cursor_offset = character_index
        cursor_index = character_index
        return cursor_offset
      endIf

      native ...
        @|char* utf8 = $data->as_utf8;
         |
         |RogueInt32 c_offset;
         |RogueInt32 c_index;
         |
         |if ($character_index == 0)
         |{
         |  $cursor_index = 0;
         |  $cursor_offset = 0;
         |  return 0;
         |}
         |else if ($character_index >= $count - 1 || $cursor_index > $count-1 || $cursor_offset > $data->count-1)
         |{
         |  c_offset = $data->count;
         |  c_index = $count;
         |}
         |else
         |{
         |  c_offset = $cursor_offset;
         |  c_index  = $cursor_index;
         |}
         |
         |while (c_index < $character_index)
         |{
         |  while ((utf8[++c_offset] & 0xC0) == 0x80) {}
         |  ++c_index;
         |}
         |
         |while (c_index > $character_index)
         |{
         |  while ((utf8[--c_offset] & 0xC0) == 0x80) {}
         |  --c_index;
         |}
         |
         |$cursor_index = c_index;
         |$cursor_offset = c_offset;

     return cursor_offset

    method to->Real64
      if (count == 0) return 0
      if (this.contains(','))
        use filtered = String.pool
          forEach (ch in this)
            if (ch != ',') filtered.print ch
          endForEach
          return filtered->Real64
        endUse
      endIf
      return native( "strtod( (char*)$this->data->as_utf8, 0 )" )->Real64

    method without_trailing( ch:Character )->String
      # Like before_suffix() but removes multiple copies of the given character.
      local result = this
      local next   = result.before_suffix( ch )
      while (result != next)
        result = next
        next   = result.before_suffix( ch )
      endWhile
      return result

    method without_trailing( text:String )->String
      # Like before_suffix() but removes multiple copies of the given string.
      local result = this
      local next   = result.before_suffix( text )
      while (result != next)
        result = next
        next   = result.before_suffix( text )
      endWhile
      return result

    method _round_off
      # Internal use.
      #
      # Removes the last digit and rounds off preceding digits accordingly.
      #
      # Requires: this mutable String contains a real number (and only a real number)
      # in the form [0-9]*.[0-9]+
      if (is_immutable or not count) return

      local ch = last
      if (ch >= '5' and ch <= '9')
        remove_last
        forEach (i in count-1 downTo 0)
          if (this[i] != '.')
            ++data[cursor_offset]
            if (this[i] == ('9'+1))
              data[cursor_offset] = '0'
            else
              if (this[count-1] == '.') print '0'
              return
            endIf
          endIf
        endForEach
        insert( '1' )
        if (this[count-1] == '.') print '0'
      endIf

  NATIVE
    nativeHeader @|RogueString* RogueString_create( const char* cstring, int byte_count, int must_free );
                  |RogueString* RogueString_create_from_ascii256( const char* cstring, int byte_count, int must_free );
                  |RogueInt32   RogueString_compute_hash_code( RogueString* THIS, RogueInt32 starting_hash );
                  |const char*  RogueString_to_c_string( RogueString* st );
                  |RogueInt32   RogueString_utf8_character_count( const char* cstring, int byte_count );

    nativeCode  @|RogueString* RogueString_create( const char* cstring, int byte_count, int must_free )
                 |{
                 |  if (byte_count == -1) byte_count = (int) strlen(cstring);
                 |  RogueInt32 character_count = RogueString_utf8_character_count( cstring, byte_count );
                 |  if (character_count == -1) return RogueString_create_from_ascii256( cstring, byte_count, must_free );
                 |
                 |  RogueString* result = ROGUE_CREATE_OBJECT( RogueString );
                 |  RogueByteList* data = ROGUE_CREATE_OBJECT( RogueByteList );
                 |  result->data = data;
                 |
                 |  data->as_utf8        = (char*) cstring;
                 |  data->count          = byte_count;
                 |  data->capacity       = byte_count + 1;
                 |  data->is_borrowed    = !must_free;
                 |  data->element_size   = 1;
                 |
                 |  result->count        = character_count;
                 |  result->is_immutable = !must_free;
                 |  result->hash_code    = -1;
                 |  result->is_ascii     = (character_count == byte_count);
                 |  return result;
                 |}
                 |
                 |RogueString* RogueString_create_from_ascii256( const char* cstring, int byte_count, int must_free )
                 |{
                 |  if (byte_count == -1) byte_count = (int) strlen(cstring);
                 |
                 |  int utf8_byte_count = 0;
                 |  int i;
                 |  for (i=byte_count; --i>=0; )
                 |  {
                 |    if (cstring[i] & 0x80) utf8_byte_count += 2;
                 |    else                   ++utf8_byte_count;
                 |  }
                 |
                 |  if (utf8_byte_count == byte_count)
                 |  {
                 |    return RogueString_create( cstring, byte_count, must_free );
                 |  }
                 |
                 |  RogueString* result = ROGUE_CREATE_OBJECT( RogueString );
                 |  RogueString__init__RogueInt32( result, utf8_byte_count );
                 |
                 |  char* utf8 = result->data->as_utf8;
                 |  int dest_i = 0;
                 |  for (i=-1; ++i<byte_count; )
                 |  {
                 |    char ch = cstring[i];
                 |    if (ch & 0x80)
                 |    {
                 |      // %aaaaaaaa ->
                 |      // %110x xxaa 10aa aaaa
                 |      utf8[dest_i]   = 0xC0 | ((ch >> 6) & 0x03);
                 |      utf8[dest_i+1] = 0x80 | ((ch >> 2) & 0x3F);
                 |      dest_i += 2;
                 |    }
                 |    else
                 |    {
                 |      utf8[dest_i++] = ch;
                 |    }
                 |  }
                 |  utf8[ utf8_byte_count ] = 0;
                 |
                 |  result->data->count = utf8_byte_count;
                 |  result->count       = byte_count;
                 |  result->hash_code   = -1;
                 |
                 |  if (must_free) ROGUE_FREE( (void*)cstring );
                 |
                 |  return result;
                 |}
                 |
                 |RogueInt32 RogueString_compute_hash_code( RogueString* THIS, RogueInt32 starting_hash )
                 |{
                 |  RogueInt32 hash = starting_hash;
                 |  int n = THIS->data->count;
                 |  char* src = THIS->data->as_utf8 - 1;
                 |  while (--n >= 0)
                 |  {
                 |    hash = ((hash<<3) - hash) + *(++src);
                 |  }
                 |  return hash;
                 |}
                 |
                 |const char* RogueString_to_c_string( RogueString* st )
                 |{
                 |  if ( !st ) { return "null"; }
                 |  return st->data->as_utf8;
                 |}
                 |
                 |RogueInt32 RogueString_utf8_character_count( const char* cstring, int byte_count )
                 |{
                 |  // Returns -1 if 'cstring' is not a valid UTF-8 string.
                 |  if (byte_count == -1) byte_count = strlen(cstring);
                 |
                 |  RogueInt32 character_count = 0;
                 |  int i;
                 |  for (i=0; i<byte_count; ++character_count)
                 |  {
                 |    int b = cstring[ i ];
                 |    if (b & 0x80)
                 |    {
                 |      if ( !(b & 0x40) ) { return -1;}
                 |
                 |      if (b & 0x20)
                 |      {
                 |        if (b & 0x10)
                 |        {
                 |          // %11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                 |          if (b & 0x08) { return -1;}
                 |          if (i + 4 > byte_count || ((cstring[i+1] & 0xC0) != 0x80) || ((cstring[i+2] & 0xC0) != 0x80)
                 |              || ((cstring[i+3] & 0xC0) != 0x80)) { return -1;}
                 |          i += 4;
                 |        }
                 |        else
                 |        {
                 |          // %1110xxxx 10xxxxxx 10xxxxxx
                 |          if (i + 3 > byte_count || ((cstring[i+1] & 0xC0) != 0x80) || ((cstring[i+2] & 0xC0) != 0x80))
                 |          {
                 |            return -1;
                 |          }
                 |          i += 3;
                 |        }
                 |      }
                 |      else
                 |      {
                 |        // %110x xxxx 10xx xxxx
                 |        if (i + 2 > byte_count || ((cstring[i+1] & 0xC0) != 0x80)) { return -1; }
                 |        i += 2;
                 |      }
                 |    }
                 |    else
                 |    {
                 |      ++i;
                 |    }
                 |  }
                 |
                 |  return character_count;
                 |}
                 |

endClass

class StringPool : ObjectPool<<String>>
  METHODS
    method on_end_use( builder:String )
      available.add( builder.clear )
endClass

