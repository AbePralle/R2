class String
  PROPERTIES
    count           : Int32  # in whole characters
    byte_capacity   : Int32  # in bytes; will be >= byte_count+1 (+1 accommodates null terminator)
    byte_count      : Int32  # in UTF-8 bytes, not including null terminator
    cursor_offset   : Int32  # in bytes
    cursor_index    : Int32  # in characters
    hash_code       : Int32
    is_immutable    : Logical
    must_free       : Logical
    native  "char* utf8;"  # always includes null pointer
    native  "char  buffer[ROGUE_STRING_INTERNAL_BUFFER_SIZE];"

  GLOBAL METHODS
    method create->String
      return native( "RogueString_create_with_byte_capacity(ROGUE_STRING_INTERNAL_BUFFER_SIZE)" )->String

  METHODS
    method print( value:String )
      if (is_immutable) return

      if (value is null)
        print( "null" )
        return
      endIf

      reserve( value.byte_count )
      native @|memcpy( $this->utf8+$byte_count, $value->utf8, $value->byte_count );
              |$hash_code = RogueString_compute_hash_code( $value, $hash_code );
              |$byte_count += $value->byte_count;
              |$this->utf8[$count += $value->count] = 0;

    method reserve( additional_bytes:Int32 )
      local required_capacity = byte_count + additional_bytes
      if (byte_capacity >= required_capacity) return

      local doubled = byte_capacity + byte_capacity
      if (doubled > required_capacity) required_capacity = doubled

      native @|char* old_data = THIS->utf8;
              |THIS->utf8 = ROGUE_MALLOC( $required_capacity );
              |memcpy( THIS->utf8, old_data, $byte_count+1 );
              |if ($must_free) ROGUE_FREE(old_data);

      must_free = true
      byte_capacity = required_capacity


  NATIVE
    nativeHeader @|RogueString* RogueString_create( const char* cstring, int byte_count, int must_free );
                  |RogueString* RogueString_create_from_ascii256( const char* cstring, int byte_count, int must_free );
                  |RogueString* RogueString_create_with_byte_capacity( RogueInt32 byte_capacity );
                  |RogueInt32   RogueString_compute_hash_code( RogueString* THIS, RogueInt32 starting_hash );
                  |const char*  RogueString_to_c_string( RogueString* st );
                  |RogueInt32   RogueString_utf8_character_count( const char* cstring, int byte_count );

    nativeCode  @|RogueString* RogueString_create( const char* cstring, int byte_count, int must_free )
                 |{
                 |  if (byte_count == -1) byte_count = (int) strlen(cstring);
                 |  RogueInt32 character_count = RogueString_utf8_character_count( cstring, byte_count );
                 |  if (character_count == -1) return RogueString_create_from_ascii256( cstring, byte_count, must_free );
                 |
                 |  RogueString* result = ROGUE_CREATE_OBJECT( RogueString );
                 |  result->utf8 = (char*) cstring;
                 |  result->byte_count   = byte_count;
                 |  result->count        = character_count;
                 |  result->is_immutable = 1;
                 |  result->must_free = must_free;
                 |  result->hash_code = RogueString_compute_hash_code( result, 0 );
                 |  //printf("sizeof(RogueString): %d\n",(int)sizeof(RogueString));
                 |  return result;
                 |}
                 |
                 |RogueString* RogueString_create_from_ascii256( const char* cstring, int byte_count, int must_free )
                 |{
                 |  if (byte_count == -1) byte_count = (int) strlen(cstring);
                 |
                 |  int utf8_byte_count = 0;
                 |  int i;
                 |  for (i=byte_count; --i>=0; )
                 |  {
                 |    if (cstring[i] & 0x80) utf8_byte_count += 2;
                 |    else                   ++utf8_byte_count;
                 |  }
                 |
                 |  RogueString* result = RogueString_create_with_byte_capacity( utf8_byte_count+1 );
                 |  char* utf8 = result->utf8;
                 |  int dest_i = 0;
                 |  for (i=-1; ++i<byte_count; )
                 |  {
                 |    char ch = cstring[i];
                 |    if (ch & 0x80)
                 |    {
                 |      // %aaaaaaaa ->
                 |      // %110x xxaa 10aa aaaa
                 |      utf8[dest_i]   = 0xC0 | ((ch >> 6) & 0x03);
                 |      utf8[dest_i+1] = 0x80 | ((ch >> 2) & 0x3F);
                 |      dest_i += 2;
                 |    }
                 |    else
                 |    {
                 |      utf8[dest_i++] = ch;
                 |    }
                 |  }
                 |  utf8[ utf8_byte_count ] = 0;
                 |
                 |  result->is_immutable = 1;
                 |  result->byte_count      = utf8_byte_count;
                 |  result->count           = byte_count;
                 |  result->hash_code = RogueString_compute_hash_code( result, 0 );
                 |  return result;
                 |}
                 |
                 |RogueString* RogueString_create_with_byte_capacity( RogueInt32 byte_capacity )
                 |{
                 |  RogueString* result = ROGUE_CREATE_OBJECT( RogueString );
                 |  result->byte_capacity = byte_capacity;
                 |  if (byte_capacity <= ROGUE_STRING_INTERNAL_BUFFER_SIZE)
                 |  {
                 |    result->utf8 = result->buffer;
                 |    byte_capacity = ROGUE_STRING_INTERNAL_BUFFER_SIZE;
                 |  }
                 |  else
                 |  {
                 |    if (byte_capacity < 1) byte_capacity = 1;
                 |    result->utf8 = (char*) ROGUE_MALLOC( byte_capacity );
                 |    result->must_free = 1;
                 |  }
                 |  // result->utf8[0] = 0;  // object is already zero-filled
                 |  return result;
                 |}
                 |
                 |RogueInt32 RogueString_compute_hash_code( RogueString* THIS, RogueInt32 starting_hash )
                 |{
                 |  RogueInt32 hash = starting_hash;
                 |  int n = THIS->byte_count;
                 |  char* src = THIS->utf8 - 1;
                 |  while (--n >= 0)
                 |  {
                 |    hash = ((hash<<3) - hash) + *(++src);
                 |  }
                 |  return hash;
                 |}
                 |
                 |const char* RogueString_to_c_string( RogueString* st )
                 |{
                 |  if ( !st ) { return "null"; }
                 |  return st->utf8;
                 |}
                 |
                 |RogueInt32 RogueString_utf8_character_count( const char* cstring, int byte_count )
                 |{
                 |  // Returns -1 if 'cstring' is not a valid UTF-8 string.
                 |  if (byte_count == -1) byte_count = strlen(cstring);
                 |
                 |  RogueInt32 character_count = 0;
                 |  int i;
                 |  for (i=0; i<byte_count; ++character_count)
                 |  {
                 |    int b = cstring[ i ];
                 |    if (b & 0x80)
                 |    {
                 |      if ( !(b & 0x40) ) { return -1;}
                 |
                 |      if (b & 0x20)
                 |      {
                 |        if (b & 0x10)
                 |        {
                 |          // %11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                 |          if (b & 0x08) { return -1;}
                 |          if (i + 4 > byte_count || ((cstring[i+1] & 0xC0) != 0x80) || ((cstring[i+2] & 0xC0) != 0x80)
                 |              || ((cstring[i+3] & 0xC0) != 0x80)) { return -1;}
                 |          i += 4;
                 |        }
                 |        else
                 |        {
                 |          // %1110xxxx 10xxxxxx 10xxxxxx
                 |          if (i + 3 > byte_count || ((cstring[i+1] & 0xC0) != 0x80) || ((cstring[i+2] & 0xC0) != 0x80)) { return -1;}
                 |          i += 3;
                 |        }
                 |      }
                 |      else
                 |      {
                 |        // %110x xxxx 10xx xxxx
                 |        if (i + 2 > byte_count || ((cstring[i+1] & 0xC0) != 0x80)) { return -1; }
                 |        i += 2;
                 |      }
                 |    }
                 |    else
                 |    {
                 |      ++i;
                 |    }
                 |  }
                 |
                 |  return character_count;
                 |}
                 |
endClass

