class ListType [aspect];

class List<<$DataType>> : ListType
  PROPERTIES
    count        : Int32
    capacity     : Int32
    element_size : Int32
    is_ref_array : Logical
    element_type : $DataType  # dummy property used to generate type-releated C code
    is_borrowed  : Logical

    native @|union
            |{
            |  void*           data;
            |  RogueObject**   as_objects;
            |  RogueReal64*    as_real64s;
            |  RogueReal32*    as_real32s;
            |  RogueInt64*     as_int64s;
            |  RogueInt32*     as_int32s;
            |  RogueCharacter* as_characters;
            |  RogueByte*      as_bytes;
            |  char*           as_utf8; // only valid for String data; includes null terminator
            |  RogueByte*      as_logicals;
            |};

  METHODS
    method init
      if ($DataType isType Logical) element_size = 1
      else                          element_size = native("sizeof($element_type)")->Int32
      if ($DataType instanceOf Object) is_ref_array = true

    method init( capacity:Int32 )
      init
      reserve( capacity )

    method on_cleanup
      native @|if ($this->as_bytes)
              |{
              |  if ($is_borrowed) $is_borrowed = 0;
              |  else              ROGUE_FREE( $this->as_bytes );
              |  $this->as_bytes = 0;
              |  $capacity = 0;
              |  $count = 0;
              |}

    method add( value:$DataType )
      reserve( 1 )
      if ($DataType isType Logical)
        native @|$this->as_logicals[$count++] = (RogueByte)$value;
      else
        native @|(($<<value>>*)($this->data))[$count++] = $value;
      endIf

    method clear
      discard_from( 0 )

    method cloned->$DataType[]
      local result = $DataType[]( count )
      result.count = count
      copy( 0, count, result, 0 )
      return result

    method copy( src_i1:Int32, src_count:Int32, dest:$DataType[], dest_i1:Int32 )
      if (src_count <= 0) return

      if (this is dest)
        native @|memmove(
                |  $dest->as_bytes + $dest_i1*$element_size,
                |  $this->as_bytes + $src_i1*$element_size,
                |  $src_count * $element_size
                |);
      else
        native @|memcpy(
                |  $dest->as_bytes + $dest_i1*$element_size,
                |  $this->as_bytes + $src_i1*$element_size,
                |  $src_count * $element_size
                |);
      endIf

    method description->String
      local result = String()
      result.print '['
      forEach (value at i in this)
        if (i > 0) result.print ','
        result.print( value )
      endForEach
      result.print ']'
      return result

    method discard_from( index:Int32 )
      local n = (count - index)
      if (n > 0)
        zero( index, n )
        count = index
      endIf

    method fill( value:$DataType, i1=0:Int32, count=null:Int32? )
      local n = which{ count || this.count }

      if ($DataType isType Logical) native @|//A
      if ($DataType isType Byte) native @|//B
      if ($DataType isType Logical or $DataType isType Byte) native @|//C

      if ($DataType isType Logical or $DataType isType Byte)
        native @|memset( $this->as_logicals + $i1, (RogueByte)$value, $n );
        return
      elseIf ($DataType isPrimitive or $DataType isReference)
        if (not value)
          native @|memset( $this->as_bytes + $i1*$element_size, 0, $n*$element_size );
          return
        endIf
      endIf

      native @|RogueInt32 n = $n;
              |$<<element_type>>* ptr = (($<<element_type>>*)$this->data) + ($i1 - 1);
              |while (--n >= 0) *(++ptr) = $value;

    method first->$DataType
      return this[0]

    method get( index:Int32 )->$DataType
      if ($DataType isType Logical)
        native @|return $this->as_logicals[$index];
      else
        native @|return (($<<element_type>>*)($this->data))[$index];
      endIf

    method is_empty->Logical
      return count == 0

    method remove_first->$DataType
      local result = this[0]
      shift( -1 )
      return result

    method remove_last->$DataType
      --count
      if ($DataType isType Logical)
        native @|RogueLogical result = $this->as_logicals[$count];
                |$this->as_logicals[$count] = 0;
                |return result;
      elseIf ($DataType isCompound)
        native @|$<<element_type>> result = (($<<element_type>>*)($this->data))[$count];
                |memset( (($<<element_type>>*)($this->data)) + $count, 0, sizeof($<<element_type>>) );
                |return result;
      else
        native @|$<<element_type>> result = (($<<element_type>>*)($this->data))[$count];
                |(($<<element_type>>*)($this->data))[$count] = 0;
                |return result;
      endIf

    method reserve( additional_capacity:Int32 )
      local required_capacity = count + additional_capacity
      if (required_capacity <= capacity) return

      required_capacity = required_capacity.or_larger( count*2 ).or_larger( 10 )

      native @|int total_size = $required_capacity * $element_size;
              |RogueByte* new_data = (RogueByte*) ROGUE_MALLOC( total_size );
              |
              |if ($this->as_bytes)
              |{
              |  int old_size = $capacity * $element_size;
              |  RogueByte* old_data = $this->as_bytes;
              |  memcpy( new_data, old_data, old_size );
              |  memset( new_data+old_size, 0, total_size-old_size );
              |  if ($is_borrowed) $is_borrowed = 0;
              |  else              ROGUE_FREE( old_data );
              |}
              |else
              |{
              |  memset( new_data, 0, total_size );
              |}
              |$this->as_bytes = new_data;

      capacity = required_capacity

    method set( index:Int32, value:$DataType )
      if ($DataType isType Logical)
        native @|$this->as_logicals[$index] = (RogueByte) $value;
      else
        native @|(($<<element_type>>*)($this->data))[$index] = $value;
      endIf

    method shift( delta:Int32 )
      if (delta == 0) return

      if (delta > 0)
        reserve( delta )
        copy( 0, count, this, delta )
        zero( 0, delta )
        count += delta
      elseIf (-delta >= count)
        clear
      else
        copy( -delta, count+delta, this, 0 )
        discard_from( count+delta )
      endIf

    method to->String
      return description

    method zero( i1=0:Int32, count=null:Int32? )
      local n = which{ count || this.count }
      native @|memset( $this->as_bytes + $i1*$element_size, 0, $n*$element_size );

endClass

#{
class Array<<$DataType>> : Array [native]
  METHODS
    method cloned->Array<<$DataType>>
      local result = Array<<$DataType>>( count )
      forEach (value at index in this) result[ index ] = value
      return result

    method get( index:Int32 )->$DataType
      return this[ index ]  # intercepted by compiler

    method set( index:Int32, new_value:$DataType )
      this[ index ] = new_value
endClass
}#
