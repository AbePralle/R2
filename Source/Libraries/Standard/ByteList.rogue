augment Byte[]
  GLOBAL METHODS
    method create( file:File )->Byte[]
      return file.load_as_bytes

  METHODS
    method init( hex:String )
      add( hex )

    method add( hex:String )
      if (hex.count & 1)
        println "ERROR: odd number of characters in Byte[].add(hex:String)."
        return
      endIf

      local dest_i = count
      reserve( hex.count/2 )
      count += hex.count/2

      forEach (hex_i of hex step 2)
        this[ dest_i ] = (hex[hex_i].to_number(16).value :<<: 4) | hex[hex_i+1].to_number(16).value
        ++dest_i
      endForEach

    method has_byte_order_mark->Logical
      if (count < 3) return false
      if (this[0] != 0xEF) return false
      if (this[1] != 0xBB) return false
      if (this[2] != 0xBF) return false
      return true

    method is_valid_utf8->Logical
      native @|int n = $count;
              |unsigned char* src = $this->as_bytes - 1;
              |while (--n >= 0)
              |{
              |  int b = *(++src);
              |  if (b & 0x80)
              |  {
              |    // 1xxx_xxxx
              |    if (b & 0x40)
              |    {
              |      // 11xx_xxxx
              |      if (b & 0x20)
              |      {
              |        // 111x_xxxx
              |        if (b & 0x10)
              |        {
              |          // 1111_xxxx
              |          if (b & 8)
              |          {
              |            // 1111_1xxx is illegal
              |            goto return_false;
              |          }
              |          else
              |          {
              |            // 1111_0xxx
              |            if (n < 2) goto return_false;
              |            if ((*(++src) & 0xC0) != 0x80) goto return_false;
              |            if ((*(++src) & 0xC0) != 0x80) goto return_false;
              |            if ((*(++src) & 0xC0) != 0x80) goto return_false;
              |            n -= 3;
              |          }
              |        }
              |        else
              |        {
              |          // 1110_xxxx
              |          if (n < 1) goto return_false;
              |          if ((*(++src) & 0xC0) != 0x80) goto return_false;
              |          if ((*(++src) & 0xC0) != 0x80) goto return_false;
              |          n -= 2;
              |        }
              |      }
              |      else
              |      {
              |        // 110x_xxxx
              |        if (--n < 0) goto return_false;
              |        if ((*(++src) & 0xC0) != 0x80) goto return_false;
              |      }
              |    }
              |    else
              |    {
              |      // 10xx_xxxx is an illegal first byte of UTF8
              |      goto return_false;
              |    }
              |  //else 0xxx_xxxx is fine
              |  }
              |}
              |return true;
              |return_false:
              |return false;

    method to_base64->String
      local base64_count = ((count+2) / 3) * 4
      local result = String( base64_count )
      local reader = BitReader( this )
      while (reader.has_another(6))
        result.print( reader.read(6).to_digit(&base64) )
      endWhile
      if (reader.buffer_count)
        local available_bits = reader.buffer_count
        result.print( (reader.read(available_bits) :<<: (6-available_bits)).to_digit(&base64) )
      endIf
      while ((result.count & 3) != 0) result.print('=')
      return result

    method to->String( hex:Logical, &uppercase, &lowercase )
      # Returns a string of hexadecimal digit pairs encoding each byte.
      # Uppercase by default unless &lowercase is specified.
      #
      # Example:
      #
      #   println Byte[][0,127,160,255]->String(&hex) # "007FA0FF"
      local buffer = String( count*2 )
      if (lowercase)
        forEach (b in this)
          buffer.[ print(((b:>>:4)&15).to_digit.to_lowercase), print((b&15).to_digit.to_lowercase) ]
        endForEach
      else
        forEach (b in this)
          buffer.[ print(((b:>>:4)&15).to_digit), print((b&15).to_digit) ]
        endForEach
      endIf
      return buffer
endAugment

