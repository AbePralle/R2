module Math

$include Math/Random

class Math
  DEFINITIONS
    E = 2.718281828459045

  GLOBAL METHODS
    method acos( n:Real64 )->Real64
      return native('acos($n)')->Real64

    method asin( n:Real64 )->Real64
      return native('asin($n)')->Real64

    method atan( n:Real64 )->Real64
      return native('atan($n)')->Real64

    method atan2( y:Real64, x:Real64 )->Real64
      return native('atan2($y,$x)')->Real64

    method ceiling( n:Real64 )->Real64
      return native('ceil($n)')->Real64

    method cos( n:Real64 )->Real64
      return native('cos($n)')->Real64

    method exp( n:Real64 )->Real64
      return native('exp($n)')->Real64

    method floor( n:Real64 )->Real64
      return native('floor($n)')->Real64

    method log( n:Real64 )->Real64
      return native('log($n)')->Real64

    method log2( n:Real64 )->Real64
      return native('log2($n)')->Real64

    method log10( n:Real64 )->Real64
      return native('log10($n)')->Real64

    method sin( n:Real64 )->Real64
      return native('sin($n)')->Real64

    method sqrt( n:Real64 )->Real64
      return native("sqrt($n)")->Real64

    method tan( n:Real64 )->Real64
      return native('tan($n)')->Real64

    method abs( n:Real64 )->Real64
      if (n >= 0) return  n
      else        return -n

      #{
    method abs( n:Int64 )->Int64
      if (n >= 0) return  n
      else        return -n

    method abs( n:Int32 )->Int32
      if (n >= 0) return  n
      else        return -n

    method lerp( a:Real64, b:Real64, progress:Real64 )->Real64
      return a + (b-a) * progress

    method lerp( a:Int32,  b:Int32,  progress:Real64 )->Int32
      return a + (b-a) * progress

    method max( a:Int32, b:Int32 )->Int32
      if (a >= b) return a
      else        return b

    method max( a:Int64, b:Int64 )->Int64
      if (a >= b) return a
      else        return b

    method max( a:Real64, b:Real64 )->Real64
      if (a >= b) return a
      else        return b

    method min( a:Int32, b:Int32 )->Int32
      if (a <= b) return a
      else        return b

    method min( a:Int64, b:Int64 )->Int64
      if (a <= b) return a
      else        return b

    method min( a:Real64, b:Real64 )->Real64
      if (a <= b) return a
      else        return b

    method mod( a:Int32, b:Int32 )->Int32
      if ((not a and not b) or b == 1) return 0

      local r = native("$a % $b")->Int32
      if ((a ~ b) < 0)
        if (r) return r + b
        else   return 0
      else
        return r
      endIf

    method mod( a:Int64, b:Int64 )->Int64
      if ((not a and not b) or b == 1) return 0

      local r = native("$a % $b")->Int64
      if ((a ~ b) < 0)
        if (r) return r + b
        else   return 0
      else
        return r
      endIf

    method mod( a:Real64, b:Real64 )->Real64
      local q = a / b
      return a - floor(q)*b

    method shift_right( value:Int32, bits:Int32 )->Int32
      if (bits <= 0) return value

      --bits
      if (bits) return ((value :>>>: 1) & 0x7fffFFFF) :>>>: bits
      else      return (value :>>>: 1) & 0x7fffFFFF

    method shift_right( value:Int64, bits:Int64 )->Int64
      if (bits <= 0) return value

      --bits
      if (bits) return ((value :>>>: 1) & 0x7fffFFFFffffFFFF) :>>>: bits
      else      return (value :>>>: 1) & 0x7fffFFFFffffFFFF
      }#
endClass

