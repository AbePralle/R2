module RogueC

# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
$define PARSER_EXISTS true

$include "Cmd.rogue"
$include "Scanner.rogue"
$include "Visitor.rogue"

class ParserCore [abstract]
  DEFINITIONS
    ip_program_elements = 0
    ip_consume_eols = 1
    ip_must_consume_eols = 2
    ip_consume_eols_and_semicolons = 3
    ip_program_element = 4
    ip_subclass = 5
    ip_store_routine = 6
    ip_procedure_attributes = 7
    ip_procedure_attribute = 8
    ip_procedure_body = 9
    ip_procedure_name = 10
    ip_procedure_parameters = 11
    ip_procedure_parameter = 12
    ip_optional_initial_value = 13
    ip_procedure_return_type = 14
    ip_function_definition = 15
    ip_with_values = 16
    ip_with_value = 17
    ip_id_or_type = 18
    ip_type = 19
    ip_named_tuple_type_element = 20
    ip_remaining_type = 21
    ip_list_or_optional_type = 22
    ip_function_param_types = 23
    ip_function_type_parameter = 24
    ip_function_return_type = 25
    ip_remaining_template_access = 26
    ip_template_args = 27
    ip_template_arg_tokens = 28
    ip_nested_specializer_tokens = 29
    ip_nested_parens_tokens = 30
    ip_pathed_name = 31
    ip_optional_type = 32
    ip_identifier = 33
    ip_string = 34
    ip_module_attributes = 35
    ip_module_attribute = 36
    ip_class_attributes = 37
    ip_class_attribute = 38
    ip_class = 39
    ip_enum_attributes = 40
    ip_enum_attribute = 41
    ip_enum = 42
    ip_placeholder = 43
    ip_template_parameters = 44
    ip_constructor_properties = 45
    ip_base_types = 46
    ip_class_sections = 47
    ip_class_section = 48
    ip_state = 49
    ip_enum_sections = 50
    ip_enum_section = 51
    ip_categories = 52
    ip_category = 53
    ip_native_code_blocks = 54
    ip_native_code_block = 55
    ip_definition = 56
    ip_forEach_loop = 57
    ip_forEach_control = 58
    ip_inline_forEach = 59
    ip_forEach_optional_at = 60
    ip_forEach_collection = 61
    ip_if_statement = 62
    ip_print_peek_8 = 63
    ip_if_local_elseifs_or_else = 64
    ip_if_statement_multi_line_elseIf_else = 65
    ip_if_statement_single_line_elseIf_else = 66
    ip_inline_which = 67
    ip_inline_which_case = 68
    ip_method = 69
    ip_scoped_single_line_statements = 70
    ip_scoped_multi_line_statements = 71
    ip_global_method_template_instance = 72
    ip_method_template_instance = 73
    ip_global_method = 74
    ip_global_properties = 75
    ip_properties = 76
    ip_property_declaration = 77
    ip_global_property_attributes = 78
    ip_global_property_attribute = 79
    ip_property_attributes = 80
    ip_property_attribute = 81
    ip_multi_line_statements = 82
    ip_single_line_statements = 83
    ip_control_structure = 84
    ip_optional_args = 85
    ip_args = 86
    ip_macro_args = 87
    ip_macro_arg = 88
    ip_nested_macro_arg = 89
    ip_arg = 90
    ip_arg_inner = 91
    ip_statement = 92
    ip_verbose_trace = 93
    ip_brief_trace = 94
    ip_local_declarations = 95
    ip_local_declaration = 96
    ip_localize = 97
    ip_destructuring_local_declarations = 98
    ip_block = 99
    ip_block_assignment = 100
    ip_contingent = 101
    ip_loop = 102
    ip_which_conditional = 103
    ip_while_loop = 104
    ip_try_catch = 105
    ip_catches = 106
    ip_catch_clause = 107
    ip_temporarily = 108
    ip_temporary_assignment = 109
    ip_use = 110
    ip_used_resource = 111
    ip_module_path = 112
    ip_uses_attributes = 113
    ip_uses_attribute = 114
    ip_access_args = 115
    ip_optional_expression = 116
    ip_expression = 117
    ip_logical_xor = 118
    ip_logical_xor__inner = 119
    ip_logical_or = 120
    ip_logical_or__inner = 121
    ip_logical_and = 122
    ip_logical_and__inner = 123
    ip_comparison = 124
    ip_comparison__inner = 125
    ip_reference_comparison = 126
    ip_range = 127
    ip_bitwise_xor = 128
    ip_bitwise_xor__inner = 129
    ip_bitwise_or = 130
    ip_bitwise_or__inner = 131
    ip_bitwise_and = 132
    ip_bitwise_and__inner = 133
    ip_add_subtract = 134
    ip_add_subtract__inner = 135
    ip_bitwise_shift = 136
    ip_bitwise_shift__inner = 137
    ip_multiply_divide_mod = 138
    ip_multiply_divide_mod__inner = 139
    ip_power = 140
    ip_power__inner = 141
    ip_pre_unary = 142
    ip_post_unary = 143
    ip_post_unary__inner = 144
    ip_access = 145
    ip_access_inner = 146
    ip_context_block = 147
    ip_member_access = 148
    ip_context_block_command = 149
    ip_term = 150
    ip_value_expression = 151
    ip_value_list = 152
    ip_value_table = 153
    ip_key_value_pair = 154
    ip_type_access_or_typed_literal_list = 155
    ip_anonymous_tuple_or_tuple_type = 156
    ip_anonymous_tuple = 157
    ip_named_tuple_or_tuple_type = 158
    ip_named_tuple = 159
    ip_named_tuple_element = 160
    ip_remaining_generic_function_definition = 161
    ip_native_code = 162
    ip_literal_list = 163
    ip_remaining_typed_literal_list = 164
    ip_literal_table = 165
    ip_literal_table_entry = 166
    ip_preprocess = 167
    ip_process_another = 168
    ip_include_attributes = 169
    ip_include_attribute = 170
    ip_meta_expression = 171
    ip_meta_term = 172
    ip_collect_meta_filepath = 173
    ip_additional_node_types = 174

  PROPERTIES
    _tokens          : Token[]
    _position        : Int32
    _limit           : Int32
    _cmd_stack       = Cmd[]
    _list_starts     = Int32[]
    _list_tokens     = Token[]
    _next_t          : Token
    _cur_t           : Token
    _saved_positions = ParserPosition[]
    start_ip         = 0
    ip               = 0
    buffer           = String()
    output           = String()

    disable_output             : Int32
    is_batch_augment           : Logical
    saved_setting              : Int32
    procedure_returns_this     : Logical
    next_is_to_type            : Logical
    is_def                     : Logical
    is_method_template         : Logical
    include_attribute_optional : Logical

  METHODS
    method init( file:File )
      init( Scanner(file) )

    method init( filepath:String, content:String )
      init( Scanner(filepath,content) )

    method init( scanner:Scanner )
      local tokens = scanner.tokenize
      if (scanner.output.count) print scanner.output; flush
      init( tokens )

    method init( _tokens )
      _position = 0
      _limit = _tokens.count
      _cmd_stack.clear
      output.clear

    method on_parsed_class [abstract]

    method on_parsed_enum [abstract]

    method set_augment_context_name [abstract]

    method on_parsed_augment [abstract]

    method parse_module_id [abstract]

    method on_uses_module [abstract]

    method on_parsed_subclass [abstract]

    method on_parsed_routine [abstract]

    method use_Table [abstract]

    method set_cur_token [abstract]

    method discard_last [abstract]

    method join_adjacent_literal_strings [abstract]

    method class_attribute_essential [abstract]

    method load_filepath_as_string [abstract]

    method rogo_directive [abstract]

    method print_peek [abstract]

    method swap [abstract]

    method join_template_args [abstract]

    method batch_augment_create_method [abstract]

    method join [abstract]

    method on_begin_arg [abstract]

    method on_end_arg [abstract]

    method store_statement_args [abstract]

    method clone [abstract]

    method uses_attribute_no_include [abstract]

    method on_generic_fn_arg [abstract]

    method use_Introspection [abstract]

    method filename_to_file_bytes [abstract]

    method filename_to_file_string [abstract]

    method use_Value [abstract]

    method mark_token [abstract]

    method collect_token_string [abstract]

    method collect_next_token [abstract]

    method create_definition [abstract]

    method begin_join_ids [abstract]

    method end_join_ids [abstract]

    method include_filepath [abstract]

    method on_is_defined [abstract]

    method create_local_definition [abstract]

    method define_macro [abstract]

    method begin_join_lowercase [abstract]

    method end_join_lowercase [abstract]

    method require_rogue_version [abstract]

    method create_rogue_version_string [abstract]

    method create_source_filepath [abstract]

    method create_source_line [abstract]

    method check_target [abstract]

    method begin_join_strings [abstract]

    method end_join_strings [abstract]

    method begin_join_uppercase [abstract]

    method end_join_uppercase [abstract]

    method rewrite_cur_token [abstract]

    method uses_filepath [abstract]

    method insert_definition [abstract]

    method rewrite_token [abstract]

    method has_another->Logical
      return _position < _limit

    method parse( ip=null:Int32? )->Cmd
      if (_position == _limit) return null
      if (ip) start_ip = ip.value
      _list_starts.clear
      _list_tokens.clear
      _next_t = _peek
      _cur_t = _next_t
      _execute( start_ip )
      _on_output_line # flush any buffered output
      if (disable_output) return null
      if (_cmd_stack.count != 1)
        @trace _cmd_stack
        throw _peek.error( "[INTERNAL] Expected exactly one command node remaining on stack." )
      endIf
      return _cmd_stack.remove_last

    method _begin_list
      _list_starts.add( _cmd_stack.count )
      _list_tokens.add( _next_t )

    method _consume( type:TokenType )->Logical
      if (_next_t.type != type) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _consume_content( content:String )->Logical
      if (not _next_t.content or _next_t.content != content) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _consume_eols
      while (_next_t.type == TokenType.EOL)
        ++_position
        _next_t = _peek
      endWhile

    method _create_token_list
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] createTokenList/produceTokenlist without prior savePosition." )
      endIf
      local i1 = _saved_positions.remove_last.position
      local limit = _position
      local list = Token[]( limit - i1 )
      forEach (i in i1..<limit) list.add( _tokens[i] )
      _push( TokenList(_tokens[i1],list), 0 )

    method _describe( type:TokenType )->String
      if (type.symbol[0].is_letter) return type.symbol
      return "'$'" (type.symbol)

    method _discard_list
      if (_list_tokens.is_empty)
        throw _peek.error( "[INTERNAL] discardList without corresponding beginList." )
      endIf
      _list_starts.remove_last
      _list_tokens.remove_last

    method _discard_position
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] No savePosition to discard." )
      endIf
      _saved_positions.remove_last

    method _list_t->Token
      if (_list_tokens.is_empty)
        throw _peek.error( "[INTERNAL] createList/produceList without corresponding beginList." )
      endIf
      return _list_tokens.remove_last

    method _must_consume_content( content:String )
      if (_consume_content(content)) return
      local expected = which{ content.contains('\''):content || "'$'"(content.to_escaped_ascii) }
      local next = _describe( _peek.type )
      _throw_syntax_error( "Expected $, found $." (expected,next) )

    method _next_is( content:String )->Logical
      if (not _next_t.content or _next_t.content != content) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _on_output_line
      # Default behavior: print out 'output' and clear it. Can override this method.
      print( output )
      flush
      output.clear

    method _on_t->Token
     local result = _next_t
     ++_position
     _next_t = _peek
     return result

    method _peek->Token
      if (_position < _limit) return _tokens[ _position ]
      if (_tokens.count) return _tokens.last.cloned( TokenType.EOI )
      return Token( TokenType.EOI, null, null, 0, 0 )

    method _push( cmd:Cmd, node_arg_count:Int32 )
      if (node_arg_count) _cmd_stack.discard_from( _cmd_stack.count - node_arg_count )
      _cmd_stack.add( cmd )

    method _push_list( list:Cmd )
      local i1 = _list_starts.remove_last
      list.add( forEach in _cmd_stack from i1 )
      _cmd_stack.discard_from( i1 )
      _cmd_stack.add( list )

    method _read->Token
      local result = _next_t
      if (_position < _limit) ++_position; _next_t = _peek
      return result

    method _restore_position
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] No savePosition to restore." )
      endIf
      local pos = _saved_positions.remove_last
      _position = pos.position
      _cmd_stack.discard_from( pos.cmd_stack_count )
      _cur_t = pos.cur_t
      _next_t = _peek

    method _save_position
      _saved_positions.add( ParserPosition(_position,_cmd_stack.count,_cur_t) )

    method _node_arg( relative:Int32 )->Cmd
      local i = _cmd_stack.count + relative
      if (i < 0) throw _peek.error( "[INTERNAL] Not enough nodes on stack to create new Cmd." )
      return _cmd_stack[i]

    method _logical_arg( relative:Int32 )->Logical
      local node = _node_arg( relative )
      if (node is null) return false
      return node->Logical

    method _character_arg( relative:Int32 )->Character
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Character

    method _integer_arg( relative:Int32 )->Int32
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Int32

    method _real_arg( relative:Int32 )->Real64
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Real64

    method _string_arg( relative:Int32 )->String
      local node = _node_arg( relative )
      if (node is null) return null
      return node->String

    method _string_to_Logical( st:String )->Logical
      if (st.equals("false",&ignore_case)) return false
      return true

    method _string_to_Character( st:String )->Character
      if (st.count == 0) return Character(0)
      return st[0]

    method _string_to_Integer( st:String )->Int32
      return st->Int32

    method _string_to_Real( st:String )->Real64
      return st->Real64

    method _throw_syntax_error( message=null:String, expected=null:TokenType? )
      if (message is null)
        local builder = String()
        local next = _describe( _peek.type )
        if (expected)
          builder.print "Expected $, found $." (_describe(expected.value),next)
        else
          builder.print "Unexpected $." (next)
        endIf
        message = builder
      endIf

      throw _peek.error( message )

    method _execute( ip:Int32 )
      which (ip)
        case ip_program_elements: r_program_elements
        case ip_consume_eols: r_consume_eols
        case ip_must_consume_eols: r_must_consume_eols
        case ip_consume_eols_and_semicolons: r_consume_eols_and_semicolons
        case ip_program_element: r_program_element
        case ip_subclass: r_subclass
        case ip_store_routine: r_store_routine
        case ip_procedure_attributes: r_procedure_attributes
        case ip_procedure_attribute: r_procedure_attribute
        case ip_procedure_body: r_procedure_body
        case ip_procedure_name: r_procedure_name
        case ip_procedure_parameters: r_procedure_parameters
        case ip_procedure_parameter: r_procedure_parameter
        case ip_optional_initial_value: r_optional_initial_value
        case ip_procedure_return_type: r_procedure_return_type
        case ip_function_definition: r_function_definition
        case ip_with_values: r_with_values
        case ip_with_value: r_with_value
        case ip_id_or_type: r_id_or_type
        case ip_type: r_type
        case ip_named_tuple_type_element: r_named_tuple_type_element
        case ip_remaining_type: r_remaining_type
        case ip_list_or_optional_type: r_list_or_optional_type
        case ip_function_param_types: r_function_param_types
        case ip_function_type_parameter: r_function_type_parameter
        case ip_function_return_type: r_function_return_type
        case ip_remaining_template_access: r_remaining_template_access
        case ip_template_args: r_template_args
        case ip_template_arg_tokens: r_template_arg_tokens
        case ip_nested_specializer_tokens: r_nested_specializer_tokens
        case ip_nested_parens_tokens: r_nested_parens_tokens
        case ip_pathed_name: r_pathed_name
        case ip_optional_type: r_optional_type
        case ip_identifier: r_identifier
        case ip_string: r_string
        case ip_module_attributes: r_module_attributes
        case ip_module_attribute: r_module_attribute
        case ip_class_attributes: r_class_attributes
        case ip_class_attribute: r_class_attribute
        case ip_class: r_class
        case ip_enum_attributes: r_enum_attributes
        case ip_enum_attribute: r_enum_attribute
        case ip_enum: r_enum
        case ip_placeholder: r_placeholder
        case ip_template_parameters: r_template_parameters
        case ip_constructor_properties: r_constructor_properties
        case ip_base_types: r_base_types
        case ip_class_sections: r_class_sections
        case ip_class_section: r_class_section
        case ip_state: r_state
        case ip_enum_sections: r_enum_sections
        case ip_enum_section: r_enum_section
        case ip_categories: r_categories
        case ip_category: r_category
        case ip_native_code_blocks: r_native_code_blocks
        case ip_native_code_block: r_native_code_block
        case ip_definition: r_definition
        case ip_forEach_loop: r_forEach_loop
        case ip_forEach_control: r_forEach_control
        case ip_inline_forEach: r_inline_forEach
        case ip_forEach_optional_at: r_forEach_optional_at
        case ip_forEach_collection: r_forEach_collection
        case ip_if_statement: r_if_statement
        case ip_print_peek_8: r_print_peek_8
        case ip_if_local_elseifs_or_else: r_if_local_elseifs_or_else
        case ip_if_statement_multi_line_elseIf_else: r_if_statement_multi_line_elseIf_else
        case ip_if_statement_single_line_elseIf_else: r_if_statement_single_line_elseIf_else
        case ip_inline_which: r_inline_which
        case ip_inline_which_case: r_inline_which_case
        case ip_method: r_method
        case ip_scoped_single_line_statements: r_scoped_single_line_statements
        case ip_scoped_multi_line_statements: r_scoped_multi_line_statements
        case ip_global_method_template_instance: r_global_method_template_instance
        case ip_method_template_instance: r_method_template_instance
        case ip_global_method: r_global_method
        case ip_global_properties: r_global_properties
        case ip_properties: r_properties
        case ip_property_declaration: r_property_declaration
        case ip_global_property_attributes: r_global_property_attributes
        case ip_global_property_attribute: r_global_property_attribute
        case ip_property_attributes: r_property_attributes
        case ip_property_attribute: r_property_attribute
        case ip_multi_line_statements: r_multi_line_statements
        case ip_single_line_statements: r_single_line_statements
        case ip_control_structure: r_control_structure
        case ip_optional_args: r_optional_args
        case ip_args: r_args
        case ip_macro_args: r_macro_args
        case ip_macro_arg: r_macro_arg
        case ip_nested_macro_arg: r_nested_macro_arg
        case ip_arg: r_arg
        case ip_arg_inner: r_arg_inner
        case ip_statement: r_statement
        case ip_verbose_trace: r_verbose_trace
        case ip_brief_trace: r_brief_trace
        case ip_local_declarations: r_local_declarations
        case ip_local_declaration: r_local_declaration
        case ip_localize: r_localize
        case ip_destructuring_local_declarations: r_destructuring_local_declarations
        case ip_block: r_block
        case ip_block_assignment: r_block_assignment
        case ip_contingent: r_contingent
        case ip_loop: r_loop
        case ip_which_conditional: r_which_conditional
        case ip_while_loop: r_while_loop
        case ip_try_catch: r_try_catch
        case ip_catches: r_catches
        case ip_catch_clause: r_catch_clause
        case ip_temporarily: r_temporarily
        case ip_temporary_assignment: r_temporary_assignment
        case ip_use: r_use
        case ip_used_resource: r_used_resource
        case ip_module_path: r_module_path
        case ip_uses_attributes: r_uses_attributes
        case ip_uses_attribute: r_uses_attribute
        case ip_access_args: r_access_args
        case ip_optional_expression: r_optional_expression
        case ip_expression: r_expression
        case ip_logical_xor: r_logical_xor
        case ip_logical_xor__inner: r_logical_xor__inner
        case ip_logical_or: r_logical_or
        case ip_logical_or__inner: r_logical_or__inner
        case ip_logical_and: r_logical_and
        case ip_logical_and__inner: r_logical_and__inner
        case ip_comparison: r_comparison
        case ip_comparison__inner: r_comparison__inner
        case ip_reference_comparison: r_reference_comparison
        case ip_range: r_range
        case ip_bitwise_xor: r_bitwise_xor
        case ip_bitwise_xor__inner: r_bitwise_xor__inner
        case ip_bitwise_or: r_bitwise_or
        case ip_bitwise_or__inner: r_bitwise_or__inner
        case ip_bitwise_and: r_bitwise_and
        case ip_bitwise_and__inner: r_bitwise_and__inner
        case ip_add_subtract: r_add_subtract
        case ip_add_subtract__inner: r_add_subtract__inner
        case ip_bitwise_shift: r_bitwise_shift
        case ip_bitwise_shift__inner: r_bitwise_shift__inner
        case ip_multiply_divide_mod: r_multiply_divide_mod
        case ip_multiply_divide_mod__inner: r_multiply_divide_mod__inner
        case ip_power: r_power
        case ip_power__inner: r_power__inner
        case ip_pre_unary: r_pre_unary
        case ip_post_unary: r_post_unary
        case ip_post_unary__inner: r_post_unary__inner
        case ip_access: r_access
        case ip_access_inner: r_access_inner
        case ip_context_block: r_context_block
        case ip_member_access: r_member_access
        case ip_context_block_command: r_context_block_command
        case ip_term: r_term
        case ip_value_expression: r_value_expression
        case ip_value_list: r_value_list
        case ip_value_table: r_value_table
        case ip_key_value_pair: r_key_value_pair
        case ip_type_access_or_typed_literal_list: r_type_access_or_typed_literal_list
        case ip_anonymous_tuple_or_tuple_type: r_anonymous_tuple_or_tuple_type
        case ip_anonymous_tuple: r_anonymous_tuple
        case ip_named_tuple_or_tuple_type: r_named_tuple_or_tuple_type
        case ip_named_tuple: r_named_tuple
        case ip_named_tuple_element: r_named_tuple_element
        case ip_remaining_generic_function_definition: r_remaining_generic_function_definition
        case ip_native_code: r_native_code
        case ip_literal_list: r_literal_list
        case ip_remaining_typed_literal_list: r_remaining_typed_literal_list
        case ip_literal_table: r_literal_table
        case ip_literal_table_entry: r_literal_table_entry
        case ip_preprocess: r_preprocess
        case ip_process_another: r_process_another
        case ip_include_attributes: r_include_attributes
        case ip_include_attribute: r_include_attribute
        case ip_meta_expression: r_meta_expression
        case ip_meta_term: r_meta_term
        case ip_collect_meta_filepath: r_collect_meta_filepath
        case ip_additional_node_types: r_additional_node_types
        others
          return
      endWhich

    method r_program_elements
      local _previous_cur_t = _cur_t
      _begin_list
      while ((_position < _limit))
        r_program_element
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_consume_eols
      local _previous_cur_t = _cur_t
      while (_consume(TokenType.EOL))
      endWhile
      _cur_t = _previous_cur_t

    method r_must_consume_eols
      local _previous_cur_t = _cur_t
      if ((not _consume(TokenType.EOL)))
        _throw_syntax_error("End of line expected.")
        _cur_t = _previous_cur_t
        return
      endIf
      while (_consume(TokenType.EOL))
      endWhile
      _cur_t = _previous_cur_t

    method r_consume_eols_and_semicolons
      local _previous_cur_t = _cur_t
      while ((_consume(TokenType.EOL) or _consume(TokenType.SYMBOL_SEMICOLON)))
      endWhile
      _cur_t = _previous_cur_t

    method r_program_element
      local _previous_cur_t = _cur_t
      r_consume_eols
      if ((not (_position < _limit)))
        _cur_t = _previous_cur_t
        return
      endIf
      if ((_next_t.type == TokenType.KEYWORD_CLASS))
        _save_position
        ++disable_output
        _consume(TokenType.KEYWORD_CLASS)
        r_identifier
        r_template_parameters
        r_class
        this.ip = ip
        on_parsed_class
        ip = this.ip
        --disable_output
        _discard_position
        _cur_t = _previous_cur_t
        return
      endIf
      if ((_next_t.type == TokenType.KEYWORD_ENUM))
        _save_position
        ++disable_output
        _consume(TokenType.KEYWORD_ENUM)
        r_identifier
        r_template_parameters
        r_enum
        this.ip = ip
        on_parsed_enum
        ip = this.ip
        --disable_output
        _discard_position
        _cur_t = _previous_cur_t
        return
      endIf
      if (_next_t.type == TokenType.KEYWORD_AUGMENT)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.EOL))
            ++disable_output
            is_batch_augment = true
            r_class_sections
            is_batch_augment = false
            if (not _consume(TokenType.KEYWORD_END_AUGMENT)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_AUGMENT )
            --disable_output
          else
            ++disable_output
            _save_position
            r_type
            this.ip = ip
            set_augment_context_name
            ip = this.ip
            _discard_position
            _save_position
            r_must_consume_eols
            r_class_sections
            if (not _consume(TokenType.KEYWORD_END_AUGMENT)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_AUGMENT )
            this.ip = ip
            on_parsed_augment
            ip = this.ip
            _discard_position
            --disable_output
          endIf
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_MODULE)
        temporarily _cur_t = _on_t
          this.ip = ip
          parse_module_id
          ip = this.ip
          r_module_attributes
          if (not disable_output) _push( DefineModule(_cur_t,_string_arg(-2),_node_arg(-1)->(as Attributes)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if ((_next_t.type == TokenType.KEYWORD_ROUTINE))
        _save_position
        ++disable_output
        _consume(TokenType.KEYWORD_ROUTINE)
        r_procedure_name
        if ((_next_t.type == TokenType.SYMBOL_LTLT))
          r_template_parameters
        endIf
        r_procedure_parameters
        r_procedure_return_type
        r_procedure_attributes
        if (_consume(TokenType.SYMBOL_COLON))
          r_single_line_statements
          r_store_routine
        else
          r_multi_line_statements
          r_store_routine
          if (not _consume(TokenType.KEYWORD_END_ROUTINE)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_ROUTINE )
        endIf
        _cur_t = _previous_cur_t
        return
      endIf
      if (_next_t.type == TokenType.KEYWORD_USES)
        temporarily _cur_t = _on_t
          saved_setting = 0
          saved_setting = disable_output
          disable_output = 0
          r_string
          r_uses_attributes
          disable_output = saved_setting
          this.ip = ip
          on_uses_module
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if ((_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)
        _throw_syntax_error
        _cur_t = _previous_cur_t
        return
      endIf
      r_procedure_body
      _cur_t = _previous_cur_t

    method r_subclass
      local _previous_cur_t = _cur_t
      if ((_next_t.type == TokenType.KEYWORD_SUBCLASS))
        _save_position
        ++disable_output
        _consume(TokenType.KEYWORD_SUBCLASS)
        r_class_sections
        if (not _consume(TokenType.KEYWORD_END_SUBCLASS)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_SUBCLASS )
        --disable_output
        this.ip = ip
        on_parsed_subclass
        ip = this.ip
        _discard_position
      endIf
      _cur_t = _previous_cur_t

    method r_store_routine
      local _previous_cur_t = _cur_t
      this.ip = ip
      on_parsed_routine
      ip = this.ip
      --disable_output
      _discard_position
      _cur_t = _previous_cur_t

    method r_procedure_attributes
      local _previous_cur_t = _cur_t
      _begin_list
      if (procedure_returns_this)
        if (not disable_output) _push( AttributeReturnsThis(_cur_t), 0 )
        procedure_returns_this = false
      endIf
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
            r_procedure_attribute
            _consume(TokenType.SYMBOL_COMMA)
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
        endTemporarily
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( Attributes(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_procedure_attribute
      local _previous_cur_t = _cur_t
      if (_next_t.content and _next_t.content == "abstract")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeAbstract(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "api")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeEssential(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "append")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeAppend(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "essential")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeEssential(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "fallback")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeFallback(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "insert")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeInsert(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "mutating")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeMutating(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "override")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeOverride(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "preferred")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributePreferred(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "propagated")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributePropagated(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Illegal procedure attribute. Expected one or more of [abstract api append essential fallback insert mutating override preferred propagated].")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_procedure_body
      local _previous_cur_t = _cur_t
      r_multi_line_statements
      _cur_t = _previous_cur_t

    method r_procedure_name
      local _previous_cur_t = _cur_t
      if (_next_t.content and _next_t.content == "operator")
        temporarily _cur_t = _on_t
          if (_next_t.type == TokenType.SYMBOL_QUESTION)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator?"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_PLUS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator+"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_MINUS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator-"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_ASTERISK)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator*"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_SLASH)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator/"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_PERCENT)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator%"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_CARET)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator^"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator++"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator--"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_AMPERSAND)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator&"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_VERTICAL_BAR)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator|"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_TILDE)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator~"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_BANG)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator!"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_LEFT_SHIFT)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator:<<:"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_RIGHT_SHIFT)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator:>>:"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_RIGHT_SHIFT_X)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator:>>>:"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_EQ)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator=="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_COMPARE)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator<>"), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_PLUS_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator+="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_MINUS_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator-="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_TIMES_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator*="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_DIVIDE_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator/="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_MOD_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator%="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_POWER_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator^="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_BITWISE_AND_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator&="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_BITWISE_OR_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator|="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_BITWISE_XOR_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator~="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_SHIFT_LEFT_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator:<<:="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_SHIFT_RIGHT_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator:>>:="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
          if (_next_t.type == TokenType.SYMBOL_SHIFT_RIGHT_X_EQUALS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Identifier(_cur_t,"operator:>>>:="), 0 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
        endTemporarily
      else
        r_identifier
      endIf
      _cur_t = _previous_cur_t

    method r_procedure_parameters
      local _previous_cur_t = _cur_t
      _begin_list
      if ((not _consume(TokenType.SYMBOL_OPEN_PAREN)))
        if (disable_output)     _discard_list
        else                    _push_list( CmdList(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_consume_eols
      if (_consume(TokenType.SYMBOL_CLOSE_PAREN))
        if (disable_output)     _discard_list
        else                    _push_list( CmdList(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_consume_eols
      r_procedure_parameter
      r_consume_eols
      while (_consume(TokenType.SYMBOL_COMMA))
        r_procedure_parameter
        r_consume_eols
      endWhile
      if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      if (disable_output)     _discard_list
      else                    _push_list( Parameters(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_procedure_parameter
      local _previous_cur_t = _cur_t
      r_consume_eols
      if (_next_t.type == TokenType.SYMBOL_AMPERSAND)
        temporarily _cur_t = _on_t
          r_identifier
          r_optional_initial_value
          r_optional_type
          if (not disable_output) _push( Local(_cur_t,_string_arg(-3),_node_arg(-2),_node_arg(-1)->(as Type),"default"), 3 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_AT)
        temporarily _cur_t = _on_t
          r_identifier
          r_optional_initial_value
          if ((_next_t.type == TokenType.SYMBOL_COLON))
            _throw_syntax_error("Direct @property-set parameter cannot specify a type.")
            _cur_t = _previous_cur_t
            return
          endIf
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( Local(_cur_t,_string_arg(-3),_node_arg(-2),_node_arg(-1)->(as Type),"direct-auto-store"), 3 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _next_t
          r_identifier
          r_optional_initial_value
          r_optional_type
          if (not disable_output) _push( Local(_cur_t,_string_arg(-3),_node_arg(-2),_node_arg(-1)->(as Type)), 3 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_identifier
      _cur_t = _previous_cur_t

    method r_optional_initial_value
      local _previous_cur_t = _cur_t
      if (_consume(TokenType.SYMBOL_EQUALS))
        r_consume_eols
        r_expression
      else
        if (not disable_output) _push( null, 0 )
      endIf
      _cur_t = _previous_cur_t

    method r_procedure_return_type
      local _previous_cur_t = _cur_t
      if ((not _consume(TokenType.SYMBOL_ARROW)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      if ((_consume(TokenType.KEYWORD_THIS) or _consume(TokenType.KEYWORD_THIS_TYPE)))
        procedure_returns_this = true
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      r_type
      _cur_t = _previous_cur_t

    method r_function_definition
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_FUNCTION)
        temporarily _cur_t = _on_t
          r_procedure_parameters
          r_procedure_return_type
          if (_next_t.type == TokenType.KEYWORD_WITH)
            temporarily _cur_t = _next_t
              r_with_values
            endTemporarily
          else
            if (not disable_output) _push( null, 0 )
          endIf
          _consume(TokenType.SYMBOL_COLON)
          if (_consume(TokenType.EOL))
            r_multi_line_statements
            if (not _consume(TokenType.KEYWORD_END_FUNCTION)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_FUNCTION )
          else
            r_single_line_statements
          endIf
          if (not disable_output) _push( FunctionDefinition(_cur_t,_node_arg(-4)->(as Parameters),_node_arg(-3)->(as Type),_node_arg(-2)->(as WithValues),_node_arg(-1)), 4 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_with_values
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_WITH)
        temporarily _cur_t = _on_t
          _begin_list
          if (_consume(TokenType.SYMBOL_OPEN_PAREN))
            r_with_value
            while (_consume(TokenType.SYMBOL_COMMA))
              r_consume_eols
              r_with_value
            endWhile
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          else
            r_with_value
            while (_consume(TokenType.SYMBOL_COMMA))
              r_consume_eols
              r_with_value
            endWhile
          endIf
          if (disable_output)     _discard_list
          else                    _push_list( WithValues(_list_t) )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_with_value
      local _previous_cur_t = _cur_t
      r_identifier
      if (_next_t.type == TokenType.SYMBOL_EQUALS)
        temporarily _cur_t = _on_t
          r_expression
        endTemporarily
      else
        if (not disable_output) _push( null, 0 )
      endIf
      if (not disable_output) _push( WithValue(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
      _cur_t = _previous_cur_t
      return

    method r_id_or_type
      local _previous_cur_t = _cur_t
      r_pathed_name
      if ((((_next_t.type == TokenType.SYMBOL_LTLT) or (_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS)) or (_next_t.type == TokenType.SYMBOL_QUESTION)))
        r_remaining_type
      endIf
      _cur_t = _previous_cur_t

    method r_type
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
        temporarily _cur_t = _on_t
          if (_next_t.type == TokenType.KEYWORD_FUNCTION_TYPE)
            temporarily _cur_t = _on_t
              r_function_param_types
              r_function_return_type
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
              if (not disable_output) _push( FunctionType(_cur_t,_node_arg(-2)->(as TypeList),_node_arg(-1)->(as Type)), 2 )
              r_list_or_optional_type
              _cur_t = _previous_cur_t
              return
            endTemporarily
          else
            _save_position
            ++disable_output
            r_type
            --disable_output
            if ((_next_t.type == TokenType.SYMBOL_COLON))
              _restore_position
              _begin_list
              r_named_tuple_type_element
              while (_consume(TokenType.SYMBOL_COMMA))
                r_named_tuple_type_element
              endWhile
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
              if (disable_output)     _discard_list
              else                    _push_list( NamedTupleTypeElements(_list_t) )
              if (not disable_output) _push( Type(_cur_t,_node_arg(-1)->(as NamedTupleTypeElements)), 1 )
              r_list_or_optional_type
              _cur_t = _previous_cur_t
              return
            else
              _restore_position
              _begin_list
              r_consume_eols
              r_type
              r_consume_eols
              while (_consume(TokenType.SYMBOL_COMMA))
                r_consume_eols
                r_type
                r_consume_eols
              endWhile
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
              if (disable_output)     _discard_list
              else                    _push_list( AnonymousTupleTypeElements(_list_t) )
              if (not disable_output) _push( Type(_cur_t,_node_arg(-1)->(as AnonymousTupleTypeElements)), 1 )
              r_list_or_optional_type
              _cur_t = _previous_cur_t
              return
            endIf
          endIf
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          r_type
          if (not _consume(TokenType.SYMBOL_COLON)) _throw_syntax_error( &expected=TokenType.SYMBOL_COLON )
          r_type
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
          if (not disable_output) _push( Type(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)->(as Type)), 2 )
          this.ip = ip
          use_Table
          ip = this.ip
          r_list_or_optional_type
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_FUNCTION_TYPE)
        temporarily _cur_t = _on_t
          r_function_param_types
          r_function_return_type
          if (not disable_output) _push( FunctionType(_cur_t,_node_arg(-2)->(as TypeList),_node_arg(-1)->(as Type)), 2 )
          r_list_or_optional_type
          _cur_t = _previous_cur_t
          return
        endTemporarily
      else
        this.ip = ip
        set_cur_token
        ip = this.ip
        r_pathed_name
        r_remaining_type
      endIf
      _cur_t = _previous_cur_t

    method r_named_tuple_type_element
      local _previous_cur_t = _cur_t
      r_consume_eols
      r_identifier
      r_consume_eols
      if (not _consume(TokenType.SYMBOL_COLON)) _throw_syntax_error( &expected=TokenType.SYMBOL_COLON )
      r_type
      r_consume_eols
      if (not disable_output) _push( NamedTupleTypeElement(_cur_t,_string_arg(-2),_node_arg(-1)->(as Type)), 2 )
      _cur_t = _previous_cur_t
      return

    method r_remaining_type
      local _previous_cur_t = _cur_t
      if ((_next_t.type == TokenType.SYMBOL_LTLT))
        r_template_args
      else
        if (not disable_output) _push( null, 0 )
      endIf
      if (not disable_output) _push( Type(_cur_t,_string_arg(-2),_node_arg(-1)->(as TemplateArgs)), 2 )
      r_list_or_optional_type
      _cur_t = _previous_cur_t

    method r_list_or_optional_type
      local _previous_cur_t = _cur_t
      while (((_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS) or (_next_t.type == TokenType.SYMBOL_QUESTION)))
        if (_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( Type(_cur_t,_node_arg(-1)->(as Type)), 1 )
          endTemporarily
        elseIf (_next_t.type == TokenType.SYMBOL_QUESTION)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( Type(_cur_t,_node_arg(-1)->(as Type),_string_to_Logical("true")), 1 )
          endTemporarily
        endIf
      endWhile
      _cur_t = _previous_cur_t

    method r_function_param_types
      local _previous_cur_t = _cur_t
      _begin_list
      if ((_consume(TokenType.SYMBOL_OPEN_PAREN) and (not _consume(TokenType.SYMBOL_CLOSE_PAREN))))
        r_function_type_parameter
        while (_consume(TokenType.SYMBOL_COMMA))
          r_function_type_parameter
        endWhile
        if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( TypeList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_function_type_parameter
      local _previous_cur_t = _cur_t
      if ((_next_t.type == TokenType.IDENTIFIER))
        _save_position
        r_identifier
        if (_consume(TokenType.SYMBOL_COLON))
          _discard_position
          this.ip = ip
          discard_last
          ip = this.ip
          r_type
          _cur_t = _previous_cur_t
          return
        endIf
        _restore_position
      endIf
      r_type
      _cur_t = _previous_cur_t

    method r_function_return_type
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_ARROW)
        temporarily _cur_t = _on_t
          r_type
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (not disable_output) _push( null, 0 )
      _cur_t = _previous_cur_t
      return

    method r_remaining_template_access
      local _previous_cur_t = _cur_t
      r_template_args
      if (((_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS) or (_next_t.type == TokenType.SYMBOL_QUESTION)))
        if (not disable_output) _push( Type(_cur_t,_string_arg(-2),_node_arg(-1)->(as TemplateArgs)), 2 )
        while (((_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS) or (_next_t.type == TokenType.SYMBOL_QUESTION)))
          if (_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Type(_cur_t,_node_arg(-1)->(as Type)), 1 )
            endTemporarily
          elseIf (_next_t.type == TokenType.SYMBOL_QUESTION)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( Type(_cur_t,_node_arg(-1)->(as Type),_string_to_Logical("true")), 1 )
            endTemporarily
          endIf
        endWhile
        r_type_access_or_typed_literal_list
        _cur_t = _previous_cur_t
        return
      endIf
      r_access_args
      if (not disable_output) _push( TemplatedAccess(_cur_t,_string_arg(-3),_node_arg(-2)->(as TemplateArgs),_node_arg(-1)), 3 )
      r_subclass
      _cur_t = _previous_cur_t

    method r_template_args
      local _previous_cur_t = _cur_t
      _consume(TokenType.SYMBOL_LTLT)
      _begin_list
      r_consume_eols
      if ((not _consume(TokenType.SYMBOL_GTGT)))
        r_template_arg_tokens
        r_consume_eols
        while (_consume(TokenType.SYMBOL_COMMA))
          r_consume_eols
          r_template_arg_tokens
          r_consume_eols
        endWhile
        if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( TemplateArgs(_list_t) )
      _cur_t = _previous_cur_t

    method r_template_arg_tokens
      local _previous_cur_t = _cur_t
      _save_position
      while ((((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_COMMA))) and (not (_next_t.type == TokenType.SYMBOL_GTGT))))
        if ((_next_t.type == TokenType.SYMBOL_LTLT))
          r_nested_specializer_tokens
        elseIf ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
          r_nested_parens_tokens
        else
          _read
        endIf
      endWhile
      if (disable_output) _discard_position
      else                _create_token_list
      _cur_t = _previous_cur_t
      return

    method r_nested_specializer_tokens
      local _previous_cur_t = _cur_t
      _read
      while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_GTGT))))
        if ((_next_t.type == TokenType.SYMBOL_LTLT))
          r_nested_specializer_tokens
        elseIf ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
          r_nested_parens_tokens
        else
          _read
        endIf
      endWhile
      if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
      _cur_t = _previous_cur_t

    method r_nested_parens_tokens
      local _previous_cur_t = _cur_t
      _read
      while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_PAREN))))
        if ((_next_t.type == TokenType.SYMBOL_LTLT))
          r_nested_specializer_tokens
        elseIf ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
          r_nested_parens_tokens
        else
          _read
        endIf
      endWhile
      if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      _cur_t = _previous_cur_t

    method r_pathed_name
      local _previous_cur_t = _cur_t
      _save_position
      if (_next_t.type == TokenType.SYMBOL_COLON_COLON)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,"Rogue"), 0 )
          r_identifier
          if (not disable_output) _push( ModuleQualifiedID(_cur_t,_node_arg(-2),_string_arg(-1)), 2 )
          _discard_position
        endTemporarily
      else
        _restore_position
        r_identifier
      endIf
      while ((_next_t.type == TokenType.SYMBOL_COLON_COLON))
        if (_next_t.type == TokenType.SYMBOL_COLON_COLON)
          temporarily _cur_t = _on_t
            r_identifier
            if (not disable_output) _push( ModuleQualifiedID(_cur_t,_node_arg(-2),_string_arg(-1)), 2 )
          endTemporarily
        endIf
      endWhile
      _cur_t = _previous_cur_t

    method r_optional_type
      local _previous_cur_t = _cur_t
      if (_consume(TokenType.SYMBOL_COLON))
        r_type
      else
        if (not disable_output) _push( null, 0 )
      endIf
      _cur_t = _previous_cur_t

    method r_identifier
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if ((_next_t.type == TokenType.PLACEHOLDER))
        if ((not disable_output))
          _throw_syntax_error("Unrecognized $directive or $placeholder.")
          _cur_t = _previous_cur_t
          return
        endIf
        if (_next_t.type == TokenType.PLACEHOLDER)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
            _cur_t = _previous_cur_t
            return
          endTemporarily
        endIf
      endIf
      if (_next_t.type == TokenType.KEYWORD_THIS_TYPE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,"ThisType"), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Identifier expected.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_string
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.STRING)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          while ((_next_t.type == TokenType.STRING))
            if (_next_t.type == TokenType.STRING)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
                this.ip = ip
                join_adjacent_literal_strings
                ip = this.ip
              endTemporarily
            endIf
          endWhile
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Literal string expected.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_module_attributes
      local _previous_cur_t = _cur_t
      _begin_list
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
            r_module_attribute
            _consume(TokenType.SYMBOL_COMMA)
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
        endTemporarily
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( Attributes(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_module_attribute
      local _previous_cur_t = _cur_t
      if (_next_t.content and _next_t.content == "api")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeAPI(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "essential")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeEssential(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Illegal module attribute. Expected one or more of [api essential].")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_class_attributes
      local _previous_cur_t = _cur_t
      _begin_list
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
            r_class_attribute
            _consume(TokenType.SYMBOL_COMMA)
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
        endTemporarily
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( Attributes(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_class_attribute
      local _previous_cur_t = _cur_t
      if (_next_t.content and _next_t.content == "abstract")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeAbstract(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "api")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeAPI(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "aspect")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeAspect(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "compound")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeCompound(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "primitive")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributePrimitive(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "singleton")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeSingleton(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_consume_content("essential"))
        this.ip = ip
        class_attribute_essential
        ip = this.ip
        if (not disable_output) _push( AttributeEssential(_cur_t), 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _throw_syntax_error("Illegal class attribute. Expected one or more of [abstract api aspect compound essential primitive singleton].")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_class
      local _previous_cur_t = _cur_t
      r_constructor_properties
      r_base_types
      r_class_attributes
      if (_consume(TokenType.SYMBOL_SEMICOLON))
        if (not disable_output) _push( null, 0 )
      else
        r_class_sections
        if (not _consume(TokenType.KEYWORD_END_CLASS)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_CLASS )
      endIf
      if (not disable_output) _push( Class(_cur_t,_node_arg(-4)->(as Parameters),_node_arg(-3)->(as TypeList),_node_arg(-2)->(as Attributes),_node_arg(-1)), 4 )
      _cur_t = _previous_cur_t
      return

    method r_enum_attributes
      local _previous_cur_t = _cur_t
      _begin_list
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
            r_enum_attribute
            _consume(TokenType.SYMBOL_COMMA)
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
        endTemporarily
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( Attributes(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_enum_attribute
      local _previous_cur_t = _cur_t
      if (_next_t.content and _next_t.content == "bitflags")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeBitflags(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Illegal enum attribute. Expected [bitflags].")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_enum
      local _previous_cur_t = _cur_t
      r_constructor_properties
      r_base_types
      r_enum_attributes
      if (_consume(TokenType.SYMBOL_SEMICOLON))
        if (not disable_output) _push( null, 0 )
      else
        r_enum_sections
        if (not _consume(TokenType.KEYWORD_END_ENUM)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_ENUM )
      endIf
      if (not disable_output) _push( Class(_cur_t,_node_arg(-4)->(as Parameters),_node_arg(-3)->(as TypeList),_node_arg(-2)->(as Attributes),_node_arg(-1)), 4 )
      _cur_t = _previous_cur_t
      return

    method r_placeholder
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.PLACEHOLDER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Placeholder(_cur_t,_cur_t.content), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("'$Placeholder' name expected.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_template_parameters
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_LTLT)
        temporarily _cur_t = _on_t
          _begin_list
          if ((not _consume(TokenType.SYMBOL_GTGT)))
            r_placeholder
            while (_consume(TokenType.SYMBOL_COMMA))
              r_placeholder
            endWhile
            if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          endIf
          if (disable_output)     _discard_list
          else                    _push_list( CmdList(_list_t) )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (not disable_output) _push( null, 0 )
      _cur_t = _previous_cur_t
      return

    method r_constructor_properties
      local _previous_cur_t = _cur_t
      if ((not (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      r_procedure_parameters
      _cur_t = _previous_cur_t

    method r_base_types
      local _previous_cur_t = _cur_t
      _begin_list
      if ((not _consume(TokenType.SYMBOL_COLON)))
        if (disable_output)     _discard_list
        else                    _push_list( TypeList(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_type
      while (((_position < _limit) and ((_next_t.type == TokenType.SYMBOL_COMMA) or (_next_t.type == TokenType.IDENTIFIER))))
        if (_consume(TokenType.SYMBOL_COMMA))
          r_consume_eols
        endIf
        r_type
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( TypeList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_class_sections
      local _previous_cur_t = _cur_t
      _begin_list
      if ((not _consume(TokenType.SYMBOL_SEMICOLON)))
        r_consume_eols
        while ((((not (_next_t.type == TokenType.KEYWORD_END_CLASS)) and (not (_next_t.type == TokenType.KEYWORD_END_AUGMENT))) and (not (_next_t.type == TokenType.KEYWORD_END_SUBCLASS))))
          r_class_section
          r_consume_eols
        endWhile
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_class_section
      local _previous_cur_t = _cur_t
      r_consume_eols
      if (_next_t.type == TokenType.KEYWORD_GLOBAL_METHODS)
        temporarily _cur_t = _on_t
          r_consume_eols
          while ((_next_t.type == TokenType.KEYWORD_METHOD))
            r_global_method
            r_consume_eols
          endWhile
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_METHODS)
        temporarily _cur_t = _on_t
          r_consume_eols
          while ((_next_t.type == TokenType.KEYWORD_METHOD))
            r_method
            r_consume_eols
          endWhile
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_GLOBAL_PROPERTIES)
        temporarily _cur_t = _on_t
          r_consume_eols
          while ((not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
            r_global_properties
            r_consume_eols
          endWhile
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_PROPERTIES)
        temporarily _cur_t = _on_t
          r_consume_eols
          while ((not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
            r_properties
            r_consume_eols
          endWhile
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_NATIVE_SECTION)
        temporarily _cur_t = _on_t
          r_consume_eols
          while ((not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
            r_native_code_blocks
            r_consume_eols
          endWhile
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_DEFINITIONS)
        temporarily _cur_t = _on_t
          r_consume_eols
          while ((not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
            r_definition
            r_consume_eols
          endWhile
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_STATES)
        temporarily _cur_t = _on_t
          r_consume_eols
          while ((_next_t.type == TokenType.SYMBOL_GT))
            r_state
            r_consume_eols
          endWhile
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_state
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_GT)
        temporarily _cur_t = _on_t
          r_identifier
          r_consume_eols
          _begin_list
          while ((_next_t.type == TokenType.KEYWORD_METHOD))
            r_method
            r_consume_eols
          endWhile
          if (disable_output)     _discard_list
          else                    _push_list( Methods(_list_t) )
          if (not disable_output) _push( StateDef(_cur_t,_string_arg(-2),_node_arg(-1)->(as Methods)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_enum_sections
      local _previous_cur_t = _cur_t
      _begin_list
      if ((not _consume(TokenType.SYMBOL_SEMICOLON)))
        r_categories
        r_consume_eols
        while ((not (_next_t.type == TokenType.KEYWORD_END_ENUM)))
          r_enum_section
          r_consume_eols
        endWhile
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_enum_section
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_CATEGORIES)
        temporarily _cur_t = _on_t
          r_categories
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_class_section
      _cur_t = _previous_cur_t

    method r_categories
      local _previous_cur_t = _cur_t
      r_consume_eols
      while ((_next_t.type == TokenType.IDENTIFIER))
        r_category
        while (_consume(TokenType.SYMBOL_COMMA))
          r_consume_eols
          r_category
        endWhile
        r_consume_eols
      endWhile
      _cur_t = _previous_cur_t

    method r_category
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _next_t
          r_identifier
          if ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
            r_args
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (_next_t.type == TokenType.SYMBOL_EQUALS)
            temporarily _cur_t = _on_t
              r_expression
            endTemporarily
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (not disable_output) _push( Category(_cur_t,_string_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_identifier
      _cur_t = _previous_cur_t

    method r_native_code_blocks
      local _previous_cur_t = _cur_t
      r_consume_eols
      while ((not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
        r_native_code_block
        r_consume_eols
      endWhile
      _cur_t = _previous_cur_t

    method r_native_code_block
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_NATIVE_HEADER)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.SYMBOL_OPEN_PAREN))
            if (_next_t.type == TokenType.INTEGER)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralInteger(_cur_t,_cur_t.content,_string_to_Integer("10")), 0 )
              endTemporarily
            else
              _throw_syntax_error("Integer ordinal expected.")
              _cur_t = _previous_cur_t
              return
            endIf
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          else
            if (not disable_output) _push( null, 0 )
          endIf
          r_consume_eols
          if (_next_t.content and _next_t.content == "File")
            temporarily _cur_t = _on_t
              if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
              r_string
              this.ip = ip
              load_filepath_as_string
              ip = this.ip
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            endTemporarily
          else
            r_string
          endIf
          if (not disable_output) _push( NativeHeader(_cur_t,_integer_arg(-2),_string_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_NATIVE_CODE)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.SYMBOL_OPEN_PAREN))
            if (_next_t.type == TokenType.INTEGER)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralInteger(_cur_t,_cur_t.content,_string_to_Integer("10")), 0 )
              endTemporarily
            else
              _throw_syntax_error("Integer ordinal expected.")
              _cur_t = _previous_cur_t
              return
            endIf
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          else
            if (not disable_output) _push( null, 0 )
          endIf
          r_consume_eols
          if (_next_t.content and _next_t.content == "File")
            temporarily _cur_t = _on_t
              if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
              r_string
              this.ip = ip
              load_filepath_as_string
              ip = this.ip
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            endTemporarily
          else
            r_string
          endIf
          if (not disable_output) _push( NativeCode(_cur_t,_integer_arg(-2),_string_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_ROGO_DIRECTIVE)
        temporarily _cur_t = _on_t
          r_string
          this.ip = ip
          rogo_directive
          ip = this.ip
          r_consume_eols
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Expected 'nativeHeader', 'nativeCode', or 'rogoDirective'.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_definition
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_EQUALS)) _throw_syntax_error( &expected=TokenType.SYMBOL_EQUALS )
          r_expression
          if (not disable_output) _push( Definition(_cur_t,_cur_t.content,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (not _consume(TokenType.IDENTIFIER)) _throw_syntax_error( &expected=TokenType.IDENTIFIER )
      _cur_t = _previous_cur_t

    method r_forEach_loop
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_FOR_EACH)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.SYMBOL_OPEN_PAREN))
            r_consume_eols
            r_forEach_control
            r_consume_eols
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          else
            r_forEach_control
          endIf
          if (_consume(TokenType.EOL))
            r_multi_line_statements
            if (not _consume(TokenType.KEYWORD_END_FOR_EACH)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_FOR_EACH )
          else
            r_single_line_statements
          endIf
          if (not disable_output) _push( ForEach(_cur_t,_node_arg(-2)->(as ForEachControl),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_forEach_control
      local _previous_cur_t = _cur_t
      _save_position
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _next_t
          r_identifier
          r_forEach_optional_at
          if (_consume_content("in"))
            r_forEach_collection
            _discard_position
            if (not disable_output) _push( ForEachInControl(_cur_t,_string_arg(-3),_node_arg(-2)->(as ForEachAt),_node_arg(-1)->(as ForEachCollection)), 3 )
            _cur_t = _previous_cur_t
            return
          elseIf (_consume_content("of"))
            r_forEach_collection
            _discard_position
            if (not disable_output) _push( ForEachOfControl(_cur_t,_string_arg(-3),_node_arg(-2)->(as ForEachAt),_node_arg(-1)->(as ForEachCollection)), 3 )
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      endIf
      _restore_position
      if (not disable_output) _push( null, 0 )
      if (not disable_output) _push( null, 0 )
      r_forEach_collection
      if (not disable_output) _push( ForEachInControl(_cur_t,_string_arg(-3),_node_arg(-2)->(as ForEachAt),_node_arg(-1)->(as ForEachCollection)), 3 )
      _cur_t = _previous_cur_t
      return

    method r_inline_forEach
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_FOR_EACH)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( null, 0 )
          if (_consume_content("in"))
            r_forEach_collection
            if (not disable_output) _push( ForEachInControl(_cur_t,_string_arg(-3),_node_arg(-2)->(as ForEachAt),_node_arg(-1)->(as ForEachCollection)), 3 )
          elseIf (_consume_content("of"))
            r_forEach_collection
            if (not disable_output) _push( ForEachOfControl(_cur_t,_string_arg(-3),_node_arg(-2)->(as ForEachAt),_node_arg(-1)->(as ForEachCollection)), 3 )
          else
            _throw_syntax_error("Expected 'in' or 'of'.")
            _cur_t = _previous_cur_t
            return
          endIf
          if (not disable_output) _push( InlineForEach(_cur_t,_node_arg(-1)->(as ForEachControl)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_forEach_optional_at
      local _previous_cur_t = _cur_t
      if ((not _consume_content("at")))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      r_identifier
      if (not disable_output) _push( ForEachAt(_cur_t,_string_arg(-1)), 1 )
      _cur_t = _previous_cur_t
      return

    method r_forEach_collection
      local _previous_cur_t = _cur_t
      _save_position
      if (not disable_output) _push( null, 0 )
      r_expression
      if ((_next_t.type == TokenType.SYMBOL_EQUALS))
        _restore_position
        r_identifier
        if (not _consume(TokenType.SYMBOL_EQUALS)) _throw_syntax_error( &expected=TokenType.SYMBOL_EQUALS )
        r_expression
      else
        _discard_position
      endIf
      if (_consume_content("from"))
        r_expression
      else
        if (not disable_output) _push( null, 0 )
      endIf
      if (_consume_content("step"))
        r_expression
      else
        if (not disable_output) _push( null, 0 )
      endIf
      if (not disable_output) _push( ForEachCollection(_cur_t,_string_arg(-4),_node_arg(-3),_node_arg(-2),_node_arg(-1)), 4 )
      _cur_t = _previous_cur_t
      return

    method r_if_statement
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_IF)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.KEYWORD_LOCAL))
            r_identifier
            if (not _consume(TokenType.SYMBOL_EQUALS)) _throw_syntax_error( &expected=TokenType.SYMBOL_EQUALS )
            r_expression
            r_must_consume_eols
            r_multi_line_statements
            r_if_local_elseifs_or_else
            if (not _consume(TokenType.KEYWORD_END_IF)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_IF )
            if (not disable_output) _push( IfLocal(_cur_t,_string_arg(-4),_node_arg(-3),_node_arg(-2),_node_arg(-1)->(as IfLocal)), 4 )
            _cur_t = _previous_cur_t
            return
          endIf
          r_expression
          if (_consume(TokenType.EOL))
            r_scoped_multi_line_statements
            r_if_statement_multi_line_elseIf_else
            if (not _consume(TokenType.KEYWORD_END_IF)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_IF )
          else
            r_scoped_single_line_statements
            r_if_statement_single_line_elseIf_else
          endIf
          if (not disable_output) _push( If(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_print_peek_8
      local _previous_cur_t = _cur_t
      _save_position
      output.[ print(""), println ]
      _on_output_line
      this.ip = ip
      print_peek
      ip = this.ip
      _read
      this.ip = ip
      print_peek
      ip = this.ip
      _read
      this.ip = ip
      print_peek
      ip = this.ip
      _read
      this.ip = ip
      print_peek
      ip = this.ip
      _read
      this.ip = ip
      print_peek
      ip = this.ip
      _read
      this.ip = ip
      print_peek
      ip = this.ip
      _read
      this.ip = ip
      print_peek
      ip = this.ip
      _read
      this.ip = ip
      print_peek
      ip = this.ip
      _restore_position
      _cur_t = _previous_cur_t

    method r_if_local_elseifs_or_else
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_ELSE_IF)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.KEYWORD_LOCAL)) _throw_syntax_error( &expected=TokenType.KEYWORD_LOCAL )
          r_identifier
          if (not _consume(TokenType.SYMBOL_EQUALS)) _throw_syntax_error( &expected=TokenType.SYMBOL_EQUALS )
          r_expression
          r_must_consume_eols
          r_scoped_multi_line_statements
          r_if_local_elseifs_or_else
          if (not disable_output) _push( IfLocal(_cur_t,_string_arg(-4),_node_arg(-3),_node_arg(-2),_node_arg(-1)->(as IfLocal)), 4 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_ELSE)
        temporarily _cur_t = _on_t
          r_must_consume_eols
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( null, 0 )
          r_scoped_multi_line_statements
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( IfLocal(_cur_t,_string_arg(-4),_node_arg(-3),_node_arg(-2),_node_arg(-1)->(as IfLocal)), 4 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      else
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf

    method r_if_statement_multi_line_elseIf_else
      local _previous_cur_t = _cur_t
      _save_position
      if (_next_t.type == TokenType.KEYWORD_ELSE_IF)
        temporarily _cur_t = _on_t
          r_expression
          if (_consume(TokenType.EOL))
            _discard_position
            r_scoped_multi_line_statements
            r_if_statement_multi_line_elseIf_else
            if (not disable_output) _push( If(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
            if (not disable_output) _push( Statements(_cur_t,_node_arg(-1)), 1 )
            _cur_t = _previous_cur_t
            return
          else
            _restore_position
            if (not disable_output) _push( null, 0 )
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_ELSE)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.EOL))
            _discard_position
            if (not disable_output) _push( null, 0 )
            r_scoped_multi_line_statements
            if (not disable_output) _push( null, 0 )
            if (not disable_output) _push( If(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
            if (not disable_output) _push( Statements(_cur_t,_node_arg(-1)), 1 )
            _cur_t = _previous_cur_t
            return
          else
            _restore_position
            if (not disable_output) _push( null, 0 )
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      else
        _discard_position
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf

    method r_if_statement_single_line_elseIf_else
      local _previous_cur_t = _cur_t
      _save_position
      if (_next_t.type == TokenType.KEYWORD_ELSE_IF)
        temporarily _cur_t = _on_t
          r_expression
          if (_consume(TokenType.EOL))
            _restore_position
            if (not disable_output) _push( null, 0 )
            _cur_t = _previous_cur_t
            return
          else
            _discard_position
            r_scoped_single_line_statements
            r_if_statement_single_line_elseIf_else
            if (not disable_output) _push( If(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
            if (not disable_output) _push( Statements(_cur_t,_node_arg(-1)), 1 )
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_ELSE)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.EOL))
            _restore_position
            if (not disable_output) _push( null, 0 )
            _cur_t = _previous_cur_t
            return
          else
            _discard_position
            if (not disable_output) _push( null, 0 )
            r_scoped_single_line_statements
            if (not disable_output) _push( null, 0 )
            if (not disable_output) _push( If(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
            if (not disable_output) _push( Statements(_cur_t,_node_arg(-1)), 1 )
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      else
        _discard_position
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf

    method r_inline_which
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_WHICH)
        temporarily _cur_t = _on_t
          r_consume_eols
          if (not _consume(TokenType.SYMBOL_OPEN_CURLY)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_CURLY )
          r_consume_eols
          _begin_list
          r_inline_which_case
          r_consume_eols
          while (_consume(TokenType.SYMBOL_DOUBLE_VERTICAL_BAR))
            r_consume_eols
            r_inline_which_case
            r_consume_eols
          endWhile
          if (disable_output)     _discard_list
          else                    _push_list( InlineWhichCases(_list_t) )
          if (not _consume(TokenType.SYMBOL_CLOSE_CURLY)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_CURLY )
          if (not disable_output) _push( InlineWhich(_cur_t,_node_arg(-1)->(as InlineWhichCases)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_inline_which_case
      local _previous_cur_t = _cur_t
      r_expression
      r_consume_eols
      if (_consume(TokenType.SYMBOL_COLON))
        r_expression
        r_consume_eols
      else
        if (not disable_output) _push( null, 0 )
      endIf
      if (not disable_output) _push( InlineWhichCase(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      _cur_t = _previous_cur_t
      return

    method r_method
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_METHOD)
        temporarily _cur_t = _on_t
          if (is_batch_augment)
            _save_position
            r_type
            this.ip = ip
            set_augment_context_name
            ip = this.ip
            _discard_position
            if (not _consume(TokenType.SYMBOL_PERIOD)) _throw_syntax_error( &expected=TokenType.SYMBOL_PERIOD )
            _save_position
          endIf
          next_is_to_type = false
          if ((_next_t.content and _next_t.content == "to"))
            _save_position
            _consume_content("to")
            next_is_to_type = (not (_next_t.type == TokenType.SYMBOL_LTLT))
            _restore_position
          endIf
          if (next_is_to_type)
            if (_next_t.content and _next_t.content == "to")
              temporarily _cur_t = _on_t
                if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
                r_procedure_return_type
                r_procedure_parameters
                this.ip = ip
                swap
                ip = this.ip
              endTemporarily
            endIf
          else
            r_procedure_name
            is_def = false
            if ((_next_t.type == TokenType.SYMBOL_LTLT))
              _save_position
              _consume(TokenType.SYMBOL_LTLT)
              is_def = (_next_t.type == TokenType.PLACEHOLDER)
              _restore_position
              if (is_def)
                is_method_template = true
                r_template_parameters
                _save_position
                ++disable_output
              else
                r_template_args
                this.ip = ip
                join_template_args
                ip = this.ip
              endIf
            endIf
            r_procedure_parameters
            r_procedure_return_type
          endIf
          r_procedure_attributes
          _consume(TokenType.SYMBOL_COLON)
          if (is_batch_augment)
            r_multi_line_statements
            if (is_method_template)
              is_method_template = false
              --disable_output
              _discard_position
            endIf
            this.ip = ip
            batch_augment_create_method
            ip = this.ip
            _discard_position
          elseIf (is_method_template)
            r_multi_line_statements
            is_method_template = false
            --disable_output
            if (disable_output) _discard_position
            else                _create_token_list
            if (not disable_output) _push( MethodTemplate(_cur_t,_string_arg(-3),_node_arg(-2),_node_arg(-1)->(as TokenList)), 3 )
            _cur_t = _previous_cur_t
            return
          else
            _save_position
            ++disable_output
            r_multi_line_statements
            --disable_output
            if (disable_output) _discard_position
            else                _create_token_list
            if (not disable_output) _push( null, 0 )
            if (not disable_output) _push( LocalScope(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( Method(_cur_t,_string_arg(-6),_node_arg(-5)->(as Parameters),_node_arg(-4)->(as Type),_node_arg(-3)->(as Attributes),_node_arg(-2)->(as TokenList),_node_arg(-1)->(as LocalScope)), 6 )
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_scoped_single_line_statements
      local _previous_cur_t = _cur_t
      r_single_line_statements
      if (not disable_output) _push( LocalScope(_cur_t,_node_arg(-1)), 1 )
      _cur_t = _previous_cur_t
      return

    method r_scoped_multi_line_statements
      local _previous_cur_t = _cur_t
      r_multi_line_statements
      if (not disable_output) _push( LocalScope(_cur_t,_node_arg(-1)), 1 )
      _cur_t = _previous_cur_t
      return

    method r_global_method_template_instance
      local _previous_cur_t = _cur_t
      r_procedure_parameters
      r_procedure_return_type
      r_procedure_attributes
      _consume(TokenType.SYMBOL_COLON)
      _save_position
      r_scoped_multi_line_statements
      if (not disable_output) _push( GlobalMethod(_cur_t,_string_arg(-5),_node_arg(-4)->(as Parameters),_node_arg(-3)->(as Type),_node_arg(-2)->(as Attributes),_node_arg(-1)->(as LocalScope)), 5 )
      _cur_t = _previous_cur_t
      return

    method r_method_template_instance
      local _previous_cur_t = _cur_t
      r_procedure_parameters
      r_procedure_return_type
      r_procedure_attributes
      _consume(TokenType.SYMBOL_COLON)
      _save_position
      ++disable_output
      r_multi_line_statements
      --disable_output
      if (disable_output) _discard_position
      else                _create_token_list
      if (not disable_output) _push( null, 0 )
      if (not disable_output) _push( LocalScope(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( Method(_cur_t,_string_arg(-6),_node_arg(-5)->(as Parameters),_node_arg(-4)->(as Type),_node_arg(-3)->(as Attributes),_node_arg(-2)->(as TokenList),_node_arg(-1)->(as LocalScope)), 6 )
      _cur_t = _previous_cur_t
      return

    method r_global_method
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_METHOD)
        temporarily _cur_t = _on_t
          r_procedure_name
          if ((_next_t.type == TokenType.SYMBOL_LTLT))
            is_def = false
            _save_position
            _consume(TokenType.SYMBOL_LTLT)
            is_def = (_next_t.type == TokenType.PLACEHOLDER)
            _restore_position
            if (is_def)
              r_template_parameters
              _save_position
              ++disable_output
              r_procedure_parameters
              r_procedure_return_type
              r_procedure_attributes
              _consume(TokenType.SYMBOL_COLON)
              r_multi_line_statements
              --disable_output
              if (disable_output) _discard_position
              else                _create_token_list
              if (not disable_output) _push( GlobalMethodTemplate(_cur_t,_string_arg(-3),_node_arg(-2),_node_arg(-1)->(as TokenList)), 3 )
              _cur_t = _previous_cur_t
              return
            else
              r_template_args
              this.ip = ip
              join
              ip = this.ip
            endIf
          endIf
          r_procedure_parameters
          r_procedure_return_type
          r_procedure_attributes
          _consume(TokenType.SYMBOL_COLON)
          r_scoped_multi_line_statements
          if (not disable_output) _push( GlobalMethod(_cur_t,_string_arg(-5),_node_arg(-4)->(as Parameters),_node_arg(-3)->(as Type),_node_arg(-2)->(as Attributes),_node_arg(-1)->(as LocalScope)), 5 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_global_properties
      local _previous_cur_t = _cur_t
      _begin_list
      r_consume_eols
      r_property_declaration
      while (_consume(TokenType.SYMBOL_COMMA))
        r_consume_eols
        r_property_declaration
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      r_optional_type
      r_global_property_attributes
      if (not disable_output) _push( GlobalPropertyDeclarations(_cur_t,_node_arg(-3),_node_arg(-2)->(as Type),_node_arg(-1)->(as Attributes)), 3 )
      _cur_t = _previous_cur_t
      return

    method r_properties
      local _previous_cur_t = _cur_t
      _begin_list
      r_consume_eols
      r_property_declaration
      while (_consume(TokenType.SYMBOL_COMMA))
        r_consume_eols
        r_property_declaration
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      r_optional_type
      r_property_attributes
      if (not disable_output) _push( PropertyDeclarations(_cur_t,_node_arg(-3),_node_arg(-2)->(as Type),_node_arg(-1)->(as Attributes)), 3 )
      _cur_t = _previous_cur_t
      return

    method r_property_declaration
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          r_optional_initial_value
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( Property(_cur_t,_cur_t.content,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.PLACEHOLDER)
        temporarily _cur_t = _on_t
          if ((not disable_output))
            _throw_syntax_error
            _cur_t = _previous_cur_t
            return
          endIf
          r_optional_initial_value
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( Property(_cur_t,_cur_t.content,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_NATIVE)
        temporarily _cur_t = _on_t
          r_string
          if (not disable_output) _push( NativeCProperty(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (not _consume(TokenType.IDENTIFIER)) _throw_syntax_error( &expected=TokenType.IDENTIFIER )
      _cur_t = _previous_cur_t

    method r_global_property_attributes
      local _previous_cur_t = _cur_t
      _begin_list
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
            r_global_property_attribute
            _consume(TokenType.SYMBOL_COMMA)
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
        endTemporarily
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( Attributes(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_global_property_attribute
      local _previous_cur_t = _cur_t
      _throw_syntax_error("Illegal global property attribute.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_property_attributes
      local _previous_cur_t = _cur_t
      _begin_list
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
            r_property_attribute
            _consume(TokenType.SYMBOL_COMMA)
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
        endTemporarily
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( Attributes(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_property_attribute
      local _previous_cur_t = _cur_t
      if (_next_t.content and _next_t.content == "faux")
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeFaux(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Illegal property attribute. Expected [faux].")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_multi_line_statements
      local _previous_cur_t = _cur_t
      r_consume_eols_and_semicolons
      _begin_list
      while (((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)))
        r_control_structure
        r_consume_eols_and_semicolons
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( Statements(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_single_line_statements
      local _previous_cur_t = _cur_t
      _begin_list
      if ((_consume(TokenType.EOL) or ((_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)? and (not (_next_t.type == TokenType.SYMBOL_SEMICOLON)))))
        if (disable_output)     _discard_list
        else                    _push_list( Statements(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_statement
      while (_consume(TokenType.SYMBOL_SEMICOLON))
        if ((not (_next_t.type == TokenType.EOL)))
          r_statement
        endIf
      endWhile
      r_consume_eols
      if (disable_output)     _discard_list
      else                    _push_list( Statements(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_control_structure
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_LOCAL)
        temporarily _cur_t = _on_t
          r_local_declarations
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_LOCALIZE)
        temporarily _cur_t = _next_t
          r_localize
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_BLOCK)
        temporarily _cur_t = _next_t
          r_block
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_CONTINGENT)
        temporarily _cur_t = _next_t
          r_contingent
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_FOR_EACH)
        temporarily _cur_t = _next_t
          r_forEach_loop
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_IF)
        temporarily _cur_t = _next_t
          r_if_statement
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_LOOP)
        temporarily _cur_t = _next_t
          r_loop
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_WHICH)
        temporarily _cur_t = _next_t
          r_which_conditional
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_WHILE)
        temporarily _cur_t = _next_t
          r_while_loop
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_TEMPORARILY)
        temporarily _cur_t = _next_t
          r_temporarily
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_TRY)
        temporarily _cur_t = _next_t
          r_try_catch
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_USE)
        temporarily _cur_t = _next_t
          r_use
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_statement
      _cur_t = _previous_cur_t

    method r_optional_args
      local _previous_cur_t = _cur_t
      if ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
        r_args
      else
        if (not disable_output) _push( null, 0 )
      endIf
      _cur_t = _previous_cur_t

    method r_args
      local _previous_cur_t = _cur_t
      _begin_list
      if (_consume(TokenType.SYMBOL_OPEN_PAREN))
        r_consume_eols
        if (_consume(TokenType.SYMBOL_CLOSE_PAREN))
          if (disable_output)     _discard_list
          else                    _push_list( Args(_list_t) )
          _cur_t = _previous_cur_t
          return
        endIf
        r_consume_eols
        while (((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)))
          r_arg
          r_consume_eols
          _consume(TokenType.SYMBOL_COMMA)
          r_consume_eols
        endWhile
        if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      else
        while ((((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)) and (not (_next_t.type == TokenType.EOL))))
          r_arg
          if (_consume(TokenType.SYMBOL_COMMA))
            r_consume_eols
          endIf
        endWhile
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( Args(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_macro_args
      local _previous_cur_t = _cur_t
      _begin_list
      if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
      r_consume_eols
      if (_consume(TokenType.SYMBOL_GTGT))
        if (disable_output)     _discard_list
        else                    _push_list( Args(_list_t) )
        _cur_t = _previous_cur_t
        return
      endIf
      r_consume_eols
      while (((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)))
        _save_position
        ++disable_output
        r_macro_arg
        --disable_output
        if (disable_output) _discard_position
        else                _create_token_list
        r_consume_eols
        _consume(TokenType.SYMBOL_COMMA)
        r_consume_eols
      endWhile
      if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_macro_arg
      local _previous_cur_t = _cur_t
      while ((((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_COMMA))) and (not (_next_t.type == TokenType.SYMBOL_GTGT))))
        if (_consume(TokenType.SYMBOL_LTLT))
          r_nested_macro_arg
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
        else
          _read
        endIf
      endWhile
      _cur_t = _previous_cur_t

    method r_nested_macro_arg
      local _previous_cur_t = _cur_t
      while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_GTGT))))
        if (_consume(TokenType.SYMBOL_LTLT))
          r_nested_macro_arg
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
        else
          _read
        endIf
      endWhile
      _cur_t = _previous_cur_t

    method r_arg
      local _previous_cur_t = _cur_t
      this.ip = ip
      on_begin_arg
      ip = this.ip
      r_arg_inner
      this.ip = ip
      on_end_arg
      ip = this.ip
      _cur_t = _previous_cur_t

    method r_arg_inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_AMPERSAND)
        temporarily _cur_t = _on_t
          if (_next_t.type == TokenType.SYMBOL_BANG)
            temporarily _cur_t = _on_t
              r_identifier
              if (_consume(TokenType.SYMBOL_EQUALS))
                r_expression
              else
                if (not disable_output) _push( null, 0 )
              endIf
              if (not disable_output) _push( NamedArg(_cur_t,_string_arg(-2),_node_arg(-1),_string_to_Logical("true")), 2 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          else
            r_identifier
            if (_consume(TokenType.SYMBOL_EQUALS))
              r_expression
            else
              if (not disable_output) _push( null, 0 )
            endIf
            if (not disable_output) _push( NamedArg(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_BITWISE_AND_EQUALS)
        temporarily _cur_t = _on_t
          r_identifier
          if (_consume(TokenType.SYMBOL_EQUALS))
            r_expression
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (not disable_output) _push( NamedArg(_cur_t,_string_arg(-2),_node_arg(-1),_string_to_Logical("false"),_string_to_Logical("true")), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_expression
      _cur_t = _previous_cur_t

    method r_statement
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_ASSERT)
        temporarily _cur_t = _on_t
          _save_position
          r_expression
          if (disable_output) _discard_position
          else                _create_token_list
          if (not disable_output) _push( Assert(_cur_t,_node_arg(-2),_node_arg(-1)->(as TokenList)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_ENSURE)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
          r_expression
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          r_args
          if (not disable_output) _push( Ensure(_cur_t,_node_arg(-2),_node_arg(-1)->(as Args)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_ESCAPE_BLOCK)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( EscapeBlock(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_ESCAPE_CONTINGENT)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( EscapeContingent(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_ESCAPE_FOR_EACH)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( EscapeForEach(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_ESCAPE_IF)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( EscapeIf(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_ESCAPE_LOOP)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( EscapeLoop(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_ESCAPE_TRY)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( EscapeTry(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_ESCAPE_WHICH)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( EscapeWhich(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_ESCAPE_WHILE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( EscapeWhile(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NECESSARY)
        temporarily _cur_t = _on_t
          r_expression
          if (not disable_output) _push( Necessary(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NEXT_ITERATION)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( NextIteration(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NO_ACTION)
        temporarily _cur_t = _on_t
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "print")
        temporarily _cur_t = _on_t
          r_args
          if (not disable_output) _push( Access(_cur_t,_cur_t.content,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "println")
        temporarily _cur_t = _on_t
          r_args
          if (not disable_output) _push( Access(_cur_t,_cur_t.content,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_RETURN)
        temporarily _cur_t = _on_t
          r_optional_expression
          if (not disable_output) _push( Return(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_SUFFICIENT)
        temporarily _cur_t = _on_t
          r_expression
          if (not disable_output) _push( Sufficient(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_SWAP_VALUES)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
          r_expression
          if (not _consume(TokenType.SYMBOL_COMMA)) _throw_syntax_error( &expected=TokenType.SYMBOL_COMMA )
          r_expression
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          if (not disable_output) _push( SwapValues(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_TRACE)
        temporarily _cur_t = _next_t
          r_verbose_trace
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_BRIEF_TRACE)
        temporarily _cur_t = _next_t
          r_brief_trace
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_THROW)
        temporarily _cur_t = _on_t
          r_expression
          if (not disable_output) _push( Throw(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NATIVE_HEADER)
        temporarily _cur_t = _next_t
          r_native_code_block
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_NATIVE_CODE)
        temporarily _cur_t = _next_t
          r_native_code_block
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
        temporarily _cur_t = _on_t
          r_expression
          if (not disable_output) _push( Increment(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
        temporarily _cur_t = _on_t
          r_expression
          if (not disable_output) _push( Decrement(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_expression
      if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Increment(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Decrement(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( Assign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_PLUS_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( AddAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( SubtractAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_TIMES_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( MultiplyAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_DIVIDE_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( DivideAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MOD_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( ModAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_POWER_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( PowerAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_BITWISE_AND_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( BitwiseAndAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_BITWISE_OR_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( BitwiseOrAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_BITWISE_XOR_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( BitwiseXorAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_SHIFT_LEFT_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( BitShiftLeftAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_SHIFT_RIGHT_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( BitShiftRightAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_SHIFT_RIGHT_X_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          if (not disable_output) _push( BitShiftRightXAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_ACCESS_EQUALS)
        temporarily _cur_t = _on_t
          r_consume_eols
          if (not disable_output) _push( AccessAndAssignContext(_cur_t,_node_arg(-1)), 1 )
          if (_next_t.type == TokenType.SYMBOL_AT)
            temporarily _cur_t = _on_t
              r_identifier
              if (not disable_output) _push( ContextDirectAccess(_cur_t,_node_arg(-2),_string_arg(-1)), 2 )
            endTemporarily
          else
            r_procedure_name
            r_access_args
            if (not disable_output) _push( ContextAccess(_cur_t,_node_arg(-3),_string_arg(-2),_node_arg(-1)), 3 )
          endIf
          r_access_inner
          if (not disable_output) _push( AccessAndAssign(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      while ((_next_t.type == TokenType.SYMBOL_QUESTION_DOT))
        if (_next_t.type == TokenType.SYMBOL_QUESTION_DOT)
          temporarily _cur_t = _on_t
            r_consume_eols
            if (not disable_output) _push( ConditionalContext(_cur_t,_node_arg(-1)), 1 )
            r_member_access
          endTemporarily
        endIf
      endWhile
      if ((((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)) and (not (_next_t.type == TokenType.EOL))))
        r_args
        this.ip = ip
        store_statement_args
        ip = this.ip
      endIf
      _cur_t = _previous_cur_t

    method r_verbose_trace
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_TRACE)
        temporarily _cur_t = _on_t
          _begin_list
          while ((not (_next_t.type == TokenType.EOL)))
            _save_position
            r_expression
            if (disable_output) _discard_position
            else                _create_token_list
            if (not disable_output) _push( TracedExpression(_cur_t,_node_arg(-2),_node_arg(-1)->(as TokenList)), 2 )
            _consume(TokenType.SYMBOL_COMMA)
          endWhile
          if (disable_output)     _discard_list
          else                    _push_list( TracedExpressions(_list_t) )
          if (not disable_output) _push( VerboseTrace(_cur_t,_node_arg(-1)->(as TracedExpressions)), 1 )
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_brief_trace
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_BRIEF_TRACE)
        temporarily _cur_t = _on_t
          _begin_list
          while ((not (_next_t.type == TokenType.EOL)))
            _save_position
            r_expression
            if (disable_output) _discard_position
            else                _create_token_list
            if (not disable_output) _push( TracedExpression(_cur_t,_node_arg(-2),_node_arg(-1)->(as TokenList)), 2 )
            _consume(TokenType.SYMBOL_COMMA)
          endWhile
          if (disable_output)     _discard_list
          else                    _push_list( TracedExpressions(_list_t) )
          if (not disable_output) _push( BriefTrace(_cur_t,_node_arg(-1)->(as TracedExpressions)), 1 )
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_local_declarations
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
        temporarily _cur_t = _next_t
          r_destructuring_local_declarations
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _begin_list
      r_consume_eols
      r_local_declaration
      while (_consume(TokenType.SYMBOL_COMMA))
        r_consume_eols
        r_local_declaration
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      r_optional_type
      if (not disable_output) _push( LocalDeclarations(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
      _cur_t = _previous_cur_t
      return

    method r_local_declaration
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          r_optional_initial_value
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( Local(_cur_t,_cur_t.content,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (not _consume(TokenType.IDENTIFIER)) _throw_syntax_error( &expected=TokenType.IDENTIFIER )
      _cur_t = _previous_cur_t

    method r_localize
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_LOCALIZE)
        temporarily _cur_t = _on_t
          _begin_list
          r_identifier
          this.ip = ip
          clone
          ip = this.ip
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( Access(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
          r_subclass
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( Local(_cur_t,_string_arg(-3),_node_arg(-2),_node_arg(-1)->(as Type)), 3 )
          if (disable_output)     _discard_list
          else                    _push_list( CmdList(_list_t) )
          if (not disable_output) _push( null, 0 )
          if (not disable_output) _push( LocalDeclarations(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_destructuring_local_declarations
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
        temporarily _cur_t = _on_t
          _begin_list
          r_consume_eols
          r_identifier
          r_consume_eols
          if (_next_t.type == TokenType.SYMBOL_COLON)
            temporarily _cur_t = _on_t
              r_type
              r_consume_eols
              if (not disable_output) _push( TypedDestructuringLocal(_cur_t,_string_arg(-2),_node_arg(-1)->(as Type)), 2 )
              while (_consume(TokenType.SYMBOL_COMMA))
                r_consume_eols
                r_identifier
                r_consume_eols
                if (not _consume(TokenType.SYMBOL_COLON)) _throw_syntax_error( &expected=TokenType.SYMBOL_COLON )
                r_consume_eols
                r_type
                r_consume_eols
                if (not disable_output) _push( TypedDestructuringLocal(_cur_t,_string_arg(-2),_node_arg(-1)->(as Type)), 2 )
              endWhile
              if (disable_output)     _discard_list
              else                    _push_list( TypedDestructuringLocals(_list_t) )
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
              if (not _consume(TokenType.SYMBOL_EQUALS)) _throw_syntax_error( &expected=TokenType.SYMBOL_EQUALS )
              r_expression
              if (not disable_output) _push( TypedDestructuringLocalDeclarations(_cur_t,_node_arg(-2)->(as TypedDestructuringLocals),_node_arg(-1)), 2 )
              _cur_t = _previous_cur_t
              return
            endTemporarily
          else
            while (_consume(TokenType.SYMBOL_COMMA))
              r_consume_eols
              r_identifier
              r_consume_eols
            endWhile
            if (disable_output)     _discard_list
            else                    _push_list( Identifiers(_list_t) )
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            if (not _consume(TokenType.SYMBOL_EQUALS)) _throw_syntax_error( &expected=TokenType.SYMBOL_EQUALS )
            r_expression
            if (not disable_output) _push( UntypedDestructuringLocalDeclarations(_cur_t,_node_arg(-2)->(as Identifiers),_node_arg(-1)), 2 )
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_block
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_BLOCK)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.EOL))
            if (not disable_output) _push( null, 0 )
          else
            _begin_list
            r_block_assignment
            while (_consume(TokenType.SYMBOL_COMMA))
              r_block_assignment
            endWhile
            if (disable_output)     _discard_list
            else                    _push_list( CmdList(_list_t) )
            r_must_consume_eols
          endIf
          r_multi_line_statements
          if (not _consume(TokenType.KEYWORD_END_BLOCK)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_BLOCK )
        endTemporarily
      endIf
      if (not disable_output) _push( Block(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      _cur_t = _previous_cur_t
      return

    method r_block_assignment
      local _previous_cur_t = _cur_t
      r_identifier
      if (_next_t.type == TokenType.SYMBOL_EQUALS)
        temporarily _cur_t = _on_t
          r_expression
          if (not disable_output) _push( Assign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_contingent
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_CONTINGENT)
        temporarily _cur_t = _on_t
          r_multi_line_statements
          if (_next_t.type == TokenType.KEYWORD_SATISFIED)
            temporarily _cur_t = _on_t
              r_multi_line_statements
            endTemporarily
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (_next_t.type == TokenType.KEYWORD_UNSATISFIED)
            temporarily _cur_t = _on_t
              r_multi_line_statements
            endTemporarily
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (not _consume(TokenType.KEYWORD_END_CONTINGENT)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_CONTINGENT )
          if (not disable_output) _push( Contingent(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_loop
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_LOOP)
        temporarily _cur_t = _on_t
          if (_next_t.type == TokenType.EOL)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( null, 0 )
              r_multi_line_statements
              if (not _consume(TokenType.KEYWORD_END_LOOP)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_LOOP )
            endTemporarily
          else
            r_expression
            if (_consume(TokenType.EOL))
              r_multi_line_statements
              if (not _consume(TokenType.KEYWORD_END_LOOP)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_LOOP )
            else
              r_single_line_statements
            endIf
          endIf
          if (not disable_output) _push( Loop(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_which_conditional
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_WHICH)
        temporarily _cur_t = _on_t
          r_expression
          r_must_consume_eols
          _begin_list
          while ((_next_t.type == TokenType.KEYWORD_CASE))
            if (_next_t.type == TokenType.KEYWORD_CASE)
              temporarily _cur_t = _on_t
                r_consume_eols
                _begin_list
                r_expression
                while (_consume(TokenType.SYMBOL_COMMA))
                  r_consume_eols
                  r_expression
                endWhile
                if ((not _consume(TokenType.SYMBOL_COLON)))
                  if (not _consume(TokenType.EOL)) _throw_syntax_error( &expected=TokenType.EOL )
                endIf
                if (disable_output)     _discard_list
                else                    _push_list( Args(_list_t) )
                r_scoped_multi_line_statements
                if (not disable_output) _push( WhichCase(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
              endTemporarily
            endIf
          endWhile
          if (disable_output)     _discard_list
          else                    _push_list( WhichCases(_list_t) )
          if (_next_t.type == TokenType.KEYWORD_OTHERS)
            temporarily _cur_t = _on_t
              if ((not _consume(TokenType.SYMBOL_COLON)))
                if (not _consume(TokenType.EOL)) _throw_syntax_error( &expected=TokenType.EOL )
              endIf
              r_scoped_multi_line_statements
            endTemporarily
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (not _consume(TokenType.KEYWORD_END_WHICH)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_WHICH )
          if (not disable_output) _push( Which(_cur_t,_node_arg(-3),_node_arg(-2)->(as WhichCases),_node_arg(-1)), 3 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_while_loop
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_WHILE)
        temporarily _cur_t = _on_t
          r_expression
          if (_consume(TokenType.EOL))
            r_multi_line_statements
            if (not _consume(TokenType.KEYWORD_END_WHILE)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_WHILE )
          else
            r_single_line_statements
          endIf
          if (not disable_output) _push( While(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_try_catch
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_TRY)
        temporarily _cur_t = _on_t
          r_multi_line_statements
          r_catches
          if (not _consume(TokenType.KEYWORD_END_TRY)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_TRY )
          if (not disable_output) _push( Try(_cur_t,_node_arg(-2),_node_arg(-1)->(as Catches)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_catches
      local _previous_cur_t = _cur_t
      _begin_list
      while ((_next_t.type == TokenType.KEYWORD_CATCH))
        if (_next_t.type == TokenType.KEYWORD_CATCH)
          temporarily _cur_t = _on_t
            if (_consume(TokenType.SYMBOL_OPEN_PAREN))
              r_catch_clause
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            else
              r_catch_clause
            endIf
            r_multi_line_statements
            if (not disable_output) _push( Catch(_cur_t,_string_arg(-3),_node_arg(-2)->(as Type),_node_arg(-1)), 3 )
          endTemporarily
        endIf
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( Catches(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_catch_clause
      local _previous_cur_t = _cur_t
      _save_position
      r_identifier
      if (_consume(TokenType.SYMBOL_COLON))
        _discard_position
        r_type
      else
        _restore_position
        if (not disable_output) _push( null, 0 )
        r_type
      endIf
      _cur_t = _previous_cur_t

    method r_temporarily
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_TEMPORARILY)
        temporarily _cur_t = _on_t
          _begin_list
          r_temporary_assignment
          while (_consume(TokenType.SYMBOL_COMMA))
            r_consume_eols
            r_temporary_assignment
          endWhile
          if (disable_output)     _discard_list
          else                    _push_list( TemporaryAssignments(_list_t) )
          r_must_consume_eols
          r_multi_line_statements
          if (not _consume(TokenType.KEYWORD_END_TEMPORARILY)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_TEMPORARILY )
          if (not disable_output) _push( Temporarily(_cur_t,_node_arg(-2)->(as TemporaryAssignments),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_temporary_assignment
      local _previous_cur_t = _cur_t
      r_expression
      if (_next_t.type == TokenType.SYMBOL_EQUALS)
        temporarily _cur_t = _on_t
          r_expression
          if (not disable_output) _push( TemporaryAssignment(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (not _consume(TokenType.SYMBOL_EQUALS)) _throw_syntax_error( &expected=TokenType.SYMBOL_EQUALS )
      _cur_t = _previous_cur_t

    method r_use
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_USE)
        temporarily _cur_t = _on_t
          _begin_list
          r_used_resource
          while (_consume(TokenType.SYMBOL_COMMA))
            r_consume_eols
            r_used_resource
          endWhile
          if (disable_output)     _discard_list
          else                    _push_list( UsedResources(_list_t) )
          r_must_consume_eols
          r_multi_line_statements
          if (not _consume(TokenType.KEYWORD_END_USE)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_USE )
          if (not disable_output) _push( Use(_cur_t,_node_arg(-2)->(as UsedResources),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_used_resource
      local _previous_cur_t = _cur_t
      _save_position
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
          if (_next_t.type == TokenType.SYMBOL_EQUALS)
            temporarily _cur_t = _on_t
              r_expression
              if (not disable_output) _push( UsedResource(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
              _discard_position
              _cur_t = _previous_cur_t
              return
            endTemporarily
          endIf
        endTemporarily
      endIf
      _restore_position
      if (not disable_output) _push( null, 0 )
      r_expression
      if (not disable_output) _push( UsedResource(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
      _cur_t = _previous_cur_t
      return
      r_expression

    method r_module_path
      local _previous_cur_t = _cur_t
      _begin_list
      r_identifier
      while (_consume(TokenType.SYMBOL_SLASH))
        r_identifier
      endWhile
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_uses_attributes
      local _previous_cur_t = _cur_t
      _begin_list
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
            r_uses_attribute
            _consume(TokenType.SYMBOL_COMMA)
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
        endTemporarily
      endIf
      if (disable_output)     _discard_list
      else                    _push_list( Attributes(_list_t) )
      _cur_t = _previous_cur_t
      return

    method r_uses_attribute
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_EXPORT)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( AttributeExport(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_consume_content("noInclude"))
        this.ip = ip
        uses_attribute_no_include
        ip = this.ip
        _cur_t = _previous_cur_t
        return
      endIf
      _throw_syntax_error("Illegal 'uses' attribute. Expected any of [export noInclude].")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_access_args
      local _previous_cur_t = _cur_t
      if ((not (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      r_args
      _cur_t = _previous_cur_t

    method r_optional_expression
      local _previous_cur_t = _cur_t
      if (((_next_t.type == TokenType.EOL) or (_next_t.type == TokenType.SYMBOL_SEMICOLON)))
        if (not disable_output) _push( null, 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      r_expression
      _cur_t = _previous_cur_t

    method r_expression
      local _previous_cur_t = _cur_t
      r_logical_xor
      _cur_t = _previous_cur_t

    method r_logical_xor
      local _previous_cur_t = _cur_t
      r_logical_or
      r_logical_xor__inner
      _cur_t = _previous_cur_t

    method r_logical_xor__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_XOR)
        temporarily _cur_t = _on_t
          _consume_eols
          r_logical_or
          if (not disable_output) _push( LogicalXor(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_logical_xor__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_logical_or
      local _previous_cur_t = _cur_t
      r_logical_and
      r_logical_or__inner
      _cur_t = _previous_cur_t

    method r_logical_or__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_OR)
        temporarily _cur_t = _on_t
          _consume_eols
          r_logical_and
          if (not disable_output) _push( LogicalOr(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_logical_or__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_logical_and
      local _previous_cur_t = _cur_t
      r_comparison
      r_logical_and__inner
      _cur_t = _previous_cur_t

    method r_logical_and__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_AND)
        temporarily _cur_t = _on_t
          _consume_eols
          r_comparison
          if (not disable_output) _push( LogicalAnd(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_logical_and__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_comparison
      local _previous_cur_t = _cur_t
      r_reference_comparison
      r_comparison__inner
      _cur_t = _previous_cur_t

    method r_comparison__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_EQ)
        temporarily _cur_t = _on_t
          _consume_eols
          r_reference_comparison
          if (not disable_output) _push( CompareEQ(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_NE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_reference_comparison
          if (not disable_output) _push( CompareNE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_LT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_reference_comparison
          if (not disable_output) _push( CompareLT(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_GT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_reference_comparison
          if (not disable_output) _push( CompareGT(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_LE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_reference_comparison
          if (not disable_output) _push( CompareLE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_GE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_reference_comparison
          if (not disable_output) _push( CompareGE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_COMPARE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_reference_comparison
          if (not disable_output) _push( CompareOp(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_comparison__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_reference_comparison
      local _previous_cur_t = _cur_t
      r_range
      if (_next_t.type == TokenType.KEYWORD_IS)
        temporarily _cur_t = _on_t
          if (_consume(TokenType.KEYWORD_NOT))
            r_reference_comparison
            if (not disable_output) _push( IsNot(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
            _cur_t = _previous_cur_t
            return
          else
            r_reference_comparison
            if (not disable_output) _push( Is(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_INSTANCE_OF)
        temporarily _cur_t = _on_t
          r_type
          if (not disable_output) _push( InstanceOf(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_NOT)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.KEYWORD_INSTANCE_OF)) _throw_syntax_error( &expected=TokenType.KEYWORD_INSTANCE_OF )
          r_type
          if (not disable_output) _push( NotInstanceOf(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_IS_TYPE)
        temporarily _cur_t = _on_t
          r_type
          if (not disable_output) _push( IsType(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_range
      local _previous_cur_t = _cur_t
      r_bitwise_xor
      if (_next_t.type == TokenType.SYMBOL_DOTDOT)
        temporarily _cur_t = _on_t
          r_expression
          if (_consume_content("step"))
            r_expression
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (not disable_output) _push( CreateRangeUpTo(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_DOTDOTLT)
        temporarily _cur_t = _on_t
          r_expression
          if (_consume_content("step"))
            r_expression
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (not disable_output) _push( CreateRangeUpToLessThan(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_DOTDOTGT)
        temporarily _cur_t = _on_t
          r_expression
          if (_consume_content("step"))
            r_expression
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (not disable_output) _push( CreateRangeDownToGreaterThan(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_DOWN_TO)
        temporarily _cur_t = _on_t
          r_expression
          if (_consume_content("step"))
            r_expression
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (not disable_output) _push( CreateRangeDownTo(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_bitwise_xor
      local _previous_cur_t = _cur_t
      r_bitwise_or
      r_bitwise_xor__inner
      _cur_t = _previous_cur_t

    method r_bitwise_xor__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_TILDE)
        temporarily _cur_t = _on_t
          _consume_eols
          r_bitwise_or
          if (not disable_output) _push( BitwiseXor(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_bitwise_xor__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_bitwise_or
      local _previous_cur_t = _cur_t
      r_bitwise_and
      r_bitwise_or__inner
      _cur_t = _previous_cur_t

    method r_bitwise_or__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_VERTICAL_BAR)
        temporarily _cur_t = _on_t
          _consume_eols
          r_bitwise_and
          if (not disable_output) _push( BitwiseOr(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_bitwise_or__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_bitwise_and
      local _previous_cur_t = _cur_t
      r_add_subtract
      r_bitwise_and__inner
      _cur_t = _previous_cur_t

    method r_bitwise_and__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_AMPERSAND)
        temporarily _cur_t = _on_t
          _consume_eols
          r_add_subtract
          if (not disable_output) _push( BitwiseAnd(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_bitwise_and__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_add_subtract
      local _previous_cur_t = _cur_t
      r_bitwise_shift
      r_add_subtract__inner
      _cur_t = _previous_cur_t

    method r_add_subtract__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_PLUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_bitwise_shift
          if (not disable_output) _push( Add(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_add_subtract__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_bitwise_shift
          if (not disable_output) _push( Subtract(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_add_subtract__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_bitwise_shift
      local _previous_cur_t = _cur_t
      r_multiply_divide_mod
      r_bitwise_shift__inner
      _cur_t = _previous_cur_t

    method r_bitwise_shift__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_LEFT_SHIFT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_multiply_divide_mod
          if (not disable_output) _push( BitShiftLeft(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_bitwise_shift__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_RIGHT_SHIFT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_multiply_divide_mod
          if (not disable_output) _push( BitShiftRight(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_bitwise_shift__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_RIGHT_SHIFT_X)
        temporarily _cur_t = _on_t
          _consume_eols
          r_multiply_divide_mod
          if (not disable_output) _push( BitShiftRightX(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_bitwise_shift__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_multiply_divide_mod
      local _previous_cur_t = _cur_t
      r_power
      r_multiply_divide_mod__inner
      _cur_t = _previous_cur_t

    method r_multiply_divide_mod__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_ASTERISK)
        temporarily _cur_t = _on_t
          _consume_eols
          r_power
          if (not disable_output) _push( Multiply(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_multiply_divide_mod__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_SLASH)
        temporarily _cur_t = _on_t
          _consume_eols
          r_power
          if (not disable_output) _push( Divide(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_multiply_divide_mod__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_PERCENT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_power
          if (not disable_output) _push( Mod(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_multiply_divide_mod__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_power
      local _previous_cur_t = _cur_t
      r_pre_unary
      r_power__inner
      _cur_t = _previous_cur_t

    method r_power__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_CARET)
        temporarily _cur_t = _on_t
          _consume_eols
          r_pre_unary
          if (not disable_output) _push( Power(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_power__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_pre_unary
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_BANG)
        temporarily _cur_t = _on_t
          _consume_eols
          r_pre_unary
          if (not disable_output) _push( BitwiseNot(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NOT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_pre_unary
          if (not disable_output) _push( LogicalNot(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_MINUS)
        temporarily _cur_t = _on_t
          _consume_eols
          r_pre_unary
          if (not disable_output) _push( Negate(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_PERCENT)
        temporarily _cur_t = _on_t
          _consume_eols
          r_pre_unary
          if (not disable_output) _push( Describe(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_post_unary
      _cur_t = _previous_cur_t

    method r_post_unary
      local _previous_cur_t = _cur_t
      r_access
      r_post_unary__inner
      _cur_t = _previous_cur_t

    method r_post_unary__inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_QUESTION)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Logicalize(_cur_t,_node_arg(-1)), 1 )
          r_post_unary__inner
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
        r_args
        if (not disable_output) _push( ContextAccess(_cur_t,_node_arg(-2),"call",_node_arg(-1)), 2 )
      endIf
      _cur_t = _previous_cur_t

    method r_access
      local _previous_cur_t = _cur_t
      r_term
      r_access_inner
      _cur_t = _previous_cur_t

    method r_access_inner
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_PERIOD)
        temporarily _cur_t = _on_t
          r_consume_eols
          if (_consume(TokenType.SYMBOL_OPEN_SQUARE))
            r_context_block
            r_access_inner
          else
            r_member_access
          endIf
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_ARROW)
        temporarily _cur_t = _on_t
          if ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
            _save_position
            _consume(TokenType.SYMBOL_OPEN_PAREN)
            if (_next_t.type == TokenType.KEYWORD_AS)
              temporarily _cur_t = _on_t
                _discard_position
                r_type
                if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
                if (not disable_output) _push( As(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
                r_access_inner
                _cur_t = _previous_cur_t
                return
              endTemporarily
            else
              _restore_position
            endIf
          else
            r_consume_eols
          endIf
          r_type
          if ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
            r_args
            if (not disable_output) _push( ConvertToTypeWithArgs(_cur_t,_node_arg(-3),_node_arg(-2)->(as Type),_node_arg(-1)), 3 )
          else
            if (not disable_output) _push( ConvertToType(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
          endIf
          r_access_inner
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_expression
          r_consume_eols
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
          if (not disable_output) _push( IndexedAccess(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_access_inner
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_SLASH_SLASH)
        temporarily _cur_t = _on_t
          r_consume_eols
          if (_next_t.type == TokenType.IDENTIFIER)
            temporarily _cur_t = _on_t
              if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
            endTemporarily
          else
            r_identifier
          endIf
          if (not disable_output) _push( IndexedAccess(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          r_access_inner
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_DOT_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          r_context_block
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_FAT_ARROW)
        temporarily _cur_t = _on_t
          r_consume_eols
          r_identifier
          if ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
            r_function_param_types
          else
            if (not disable_output) _push( null, 0 )
          endIf
          if (not disable_output) _push( CallbackFunction(_cur_t,_node_arg(-3),_string_arg(-2),_node_arg(-1)->(as TypeList)), 3 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE_GT)
        temporarily _cur_t = _on_t
          r_consume_eols
          _begin_list
          r_expression
          if (disable_output)     _discard_list
          else                    _push_list( Args(_list_t) )
          r_consume_eols
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
          if (not disable_output) _push( ContextAccess(_cur_t,_node_arg(-2),"set_state",_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_context_block
      local _previous_cur_t = _cur_t
      r_consume_eols
      if (_consume(TokenType.SYMBOL_CLOSE_SQUARE))
        r_access_inner
        _cur_t = _previous_cur_t
        return
      endIf
      _begin_list
      r_context_block_command
      r_consume_eols
      while ((_consume(TokenType.SYMBOL_COMMA) or ((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE)))))
        r_context_block_command
        r_consume_eols
      endWhile
      if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
      if (disable_output)     _discard_list
      else                    _push_list( CmdList(_list_t) )
      if (not disable_output) _push( ContextBlock(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      r_access_inner
      _cur_t = _previous_cur_t

    method r_member_access
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_AT)
        temporarily _cur_t = _on_t
          r_identifier
          if (not disable_output) _push( ContextDirectAccess(_cur_t,_node_arg(-2),_string_arg(-1)), 2 )
        endTemporarily
      else
        r_procedure_name
        if ((_next_t.type == TokenType.SYMBOL_LTLT))
          r_template_args
          r_access_args
          if (not disable_output) _push( TemplatedMethodContextAccess(_cur_t,_node_arg(-4),_string_arg(-3),_node_arg(-2)->(as TemplateArgs),_node_arg(-1)), 4 )
        else
          r_access_args
          if (not disable_output) _push( ContextAccess(_cur_t,_node_arg(-3),_string_arg(-2),_node_arg(-1)), 3 )
        endIf
      endIf
      r_access_inner
      _cur_t = _previous_cur_t

    method r_context_block_command
      local _previous_cur_t = _cur_t
      if (not disable_output) _push( ContextBlockContext(_cur_t), 0 )
      r_procedure_name
      r_access_args
      if (not disable_output) _push( ContextAccess(_cur_t,_node_arg(-3),_string_arg(-2),_node_arg(-1)), 3 )
      if (_next_t.type == TokenType.SYMBOL_EQUALS)
        temporarily _cur_t = _on_t
          r_expression
          if (not disable_output) _push( Assign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_access_inner
      _cur_t = _previous_cur_t

    method r_term
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.STRING)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          while ((_next_t.type == TokenType.STRING))
            if (_next_t.type == TokenType.STRING)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
                this.ip = ip
                join_adjacent_literal_strings
                ip = this.ip
              endTemporarily
            endIf
          endWhile
          if ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
            r_args
            if (not disable_output) _push( FormattedString(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
            _cur_t = _previous_cur_t
            return
          endIf
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.INTEGER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralInteger(_cur_t,_cur_t.content,_string_to_Integer("10")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.HEX_INTEGER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralInteger(_cur_t,_cur_t.content,_string_to_Integer("16")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.BINARY_INTEGER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralInteger(_cur_t,_cur_t.content,_string_to_Integer("2")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.OCTAL_INTEGER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralInteger(_cur_t,_cur_t.content,_string_to_Integer("8")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.REAL_NUMBER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralReal(_cur_t,_string_to_Real(_cur_t.content)), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.CHARACTER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralCharacter(_cur_t,_string_to_Character(_cur_t.content)), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_AT)
        temporarily _cur_t = _on_t
          r_pathed_name
          if (not disable_output) _push( DirectAccess(_cur_t,_string_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.content and _next_t.content == "operator")
        temporarily _cur_t = _next_t
          r_procedure_name
          r_access_args
          if (not disable_output) _push( Access(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _next_t
          r_pathed_name
          if ((_next_t.type == TokenType.SYMBOL_LTLT))
            r_remaining_template_access
            _cur_t = _previous_cur_t
            return
          elseIf ((_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS))
            r_remaining_type
            r_type_access_or_typed_literal_list
            _cur_t = _previous_cur_t
            return
          elseIf ((_next_t.type == TokenType.SYMBOL_QUESTION))
            if (_next_t.type == TokenType.SYMBOL_QUESTION)
              temporarily _cur_t = _on_t
                if ((((_next_t.type == TokenType.SYMBOL_OPEN_PAREN) or (_next_t.type == TokenType.SYMBOL_QUESTION)) or (_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS)))
                  if (not disable_output) _push( null, 0 )
                  if (not disable_output) _push( Type(_cur_t,_string_arg(-2),_node_arg(-1)->(as TemplateArgs)), 2 )
                  if (not disable_output) _push( Type(_cur_t,_node_arg(-1)->(as Type),_string_to_Logical("true")), 1 )
                  r_remaining_type
                  r_type_access_or_typed_literal_list
                  _cur_t = _previous_cur_t
                  return
                else
                  if (not disable_output) _push( null, 0 )
                  if (not disable_output) _push( Access(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
                  if (not disable_output) _push( Logicalize(_cur_t,_node_arg(-1)), 1 )
                  _cur_t = _previous_cur_t
                  return
                endIf
              endTemporarily
            endIf
          else
            r_access_args
            if (not disable_output) _push( Access(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
            r_subclass
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      endIf
      if (_next_t.type == TokenType.PLACEHOLDER)
        temporarily _cur_t = _next_t
          r_id_or_type
          r_access_args
          if (not disable_output) _push( Access(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
          r_subclass
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_TRUE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralLogical(_cur_t,_string_to_Logical("true")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_FALSE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralLogical(_cur_t,_string_to_Logical("false")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NULL)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralNull(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PI)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralPi(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_PRIOR)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_PERIOD)) _throw_syntax_error( &expected=TokenType.SYMBOL_PERIOD )
          r_identifier
          if ((_next_t.type == TokenType.SYMBOL_LTLT))
            r_template_args
            if ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
              r_access_args
            else
              if (not disable_output) _push( null, 0 )
            endIf
            if (not disable_output) _push( CallPriorTemplatedMethod(_cur_t,_string_arg(-3),_node_arg(-2)->(as TemplateArgs),_node_arg(-1)->(as Args)), 3 )
            r_access_inner
          else
            if ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
              r_access_args
            else
              if (not disable_output) _push( null, 0 )
            endIf
            if (not disable_output) _push( CallPriorMethod(_cur_t,_string_arg(-2),_node_arg(-1)->(as Args)), 2 )
            r_access_inner
          endIf
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_THIS)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( This(_cur_t), 0 )
          if ((_next_t.type == TokenType.SYMBOL_OPEN_PAREN))
            if (not disable_output) _push( Identifier(_cur_t,"call"), 0 )
            r_args
            if (not disable_output) _push( ContextAccess(_cur_t,_node_arg(-3),_string_arg(-2),_node_arg(-1)), 3 )
            _cur_t = _previous_cur_t
            return
          endIf
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_WHICH)
        temporarily _cur_t = _next_t
          r_inline_which
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
        temporarily _cur_t = _next_t
          _save_position
          if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
            temporarily _cur_t = _on_t
              if (_next_t.type == TokenType.KEYWORD_FUNCTION_TYPE)
                temporarily _cur_t = _on_t
                  _restore_position
                  r_type
                  r_list_or_optional_type
                  r_access_args
                  if (not disable_output) _push( TypeAccess(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)), 2 )
                  _cur_t = _previous_cur_t
                  return
                endTemporarily
              endIf
            endTemporarily
          endIf
          _restore_position
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
        temporarily _cur_t = _next_t
          _save_position
          if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
            temporarily _cur_t = _on_t
              if (_next_t.type == TokenType.SYMBOL_CLOSE_PAREN)
                temporarily _cur_t = _on_t
                  _discard_position
                  _begin_list
                  if (disable_output)     _discard_list
                  else                    _push_list( IDList(_list_t) )
                  r_remaining_generic_function_definition
                  _cur_t = _previous_cur_t
                  return
                endTemporarily
              else
                r_expression
                if ((_next_t.type == TokenType.SYMBOL_COLON))
                  _restore_position
                  r_named_tuple_or_tuple_type
                  _cur_t = _previous_cur_t
                  return
                endIf
                if (_consume(TokenType.SYMBOL_CLOSE_PAREN))
                  if ((not ((_next_t.type == TokenType.KEYWORD_WITH) or (_next_t.type == TokenType.SYMBOL_FAT_ARROW))))
                    _discard_position
                    _cur_t = _previous_cur_t
                    return
                  endIf
                endIf
                _restore_position
                _save_position
                r_anonymous_tuple_or_tuple_type
                if ((not ((_next_t.type == TokenType.SYMBOL_FAT_ARROW) or (_next_t.type == TokenType.KEYWORD_WITH))))
                  _discard_position
                  _cur_t = _previous_cur_t
                  return
                endIf
                _restore_position
                _consume(TokenType.SYMBOL_OPEN_PAREN)
                _begin_list
                r_identifier
                while (_consume(TokenType.SYMBOL_COMMA))
                  r_identifier
                endWhile
                if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
                if (disable_output)     _discard_list
                else                    _push_list( IDList(_list_t) )
                r_remaining_generic_function_definition
                _cur_t = _previous_cur_t
                return
              endIf
            endTemporarily
          endIf
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _next_t
          _save_position
          _consume(TokenType.SYMBOL_OPEN_SQUARE)
          r_consume_eols
          r_expression
          if ((_next_t.type == TokenType.SYMBOL_COLON))
            _restore_position
            r_type
            this.ip = ip
            use_Table
            ip = this.ip
            if ((_next_t.type == TokenType.SYMBOL_OPEN_CURLY))
              r_literal_table
              if (not disable_output) _push( TypedLiteralTable(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)->(as KeyValuePairList)), 2 )
            else
              r_access_args
              if (not disable_output) _push( TypeAccess(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)), 2 )
            endIf
            _cur_t = _previous_cur_t
            return
          else
            _restore_position
            r_literal_list
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_OPEN_CURLY)
        temporarily _cur_t = _next_t
          r_literal_table
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS)
        temporarily _cur_t = _on_t
          _begin_list
          if (disable_output)     _discard_list
          else                    _push_list( LiteralList(_list_t) )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_FOR_EACH)
        temporarily _cur_t = _next_t
          r_inline_forEach
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_UNDEFINED)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralUndefined(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_FUNCTION)
        temporarily _cur_t = _next_t
          r_function_definition
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE_GT)
        temporarily _cur_t = _on_t
          _begin_list
          r_expression
          if (disable_output)     _discard_list
          else                    _push_list( Args(_list_t) )
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
          if (not disable_output) _push( Access(_cur_t,"set_state",_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NATIVE)
        temporarily _cur_t = _on_t
          r_native_code
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_VALUE_LIST)
        temporarily _cur_t = _on_t
          r_value_list
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_VALUE_TABLE)
        temporarily _cur_t = _on_t
          r_value_table
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_DOLLAR)
        temporarily _cur_t = _on_t
          this.ip = ip
          on_generic_fn_arg
          ip = this.ip
          if (not disable_output) _push( GenericFnArg(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.GENERIC_FN_ARG)
        temporarily _cur_t = _on_t
          this.ip = ip
          on_generic_fn_arg
          ip = this.ip
          if (not disable_output) _push( GenericFnArg(_cur_t), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.META_DEFAULT_VALUE)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
          r_type
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          if (not disable_output) _push( DefaultValue(_cur_t,_node_arg(-1)->(as Type)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_THIS_TYPE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( Type(_cur_t,"ThisType"), 0 )
          if (not disable_output) _push( TypeContext(_cur_t,_node_arg(-1)->(as Type)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_FUNCTION_TYPE)
        temporarily _cur_t = _next_t
          r_type
          r_optional_args
          if (not disable_output) _push( TypeAccess(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_LTLT)
        temporarily _cur_t = _on_t
          r_type
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          this.ip = ip
          use_Introspection
          ip = this.ip
          if (not disable_output) _push( GetTypeInfo(_cur_t,_node_arg(-1)->(as Type)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_NEW)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
          r_expression
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          r_args
          if (not disable_output) _push( New(_cur_t,_node_arg(-2),_node_arg(-1)->(as Args)), 2 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.META_IS_COMPOUND)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
          r_expression
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          if (not disable_output) _push( IsCompound(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.META_IS_ENUM)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
          r_expression
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          if (not disable_output) _push( IsEnum(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.META_IS_PRIMITIVE)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
          r_expression
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          if (not disable_output) _push( IsPrimitive(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.META_IS_REFERENCE)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
          r_expression
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          if (not disable_output) _push( IsReference(_cur_t,_node_arg(-1)), 1 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.META_FILE_BYTES)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
          r_string
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          this.ip = ip
          filename_to_file_bytes
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_FILE_STRING)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
          r_string
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          this.ip = ip
          filename_to_file_string
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_EXISTS)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
          r_expression
          if (not disable_output) _push( CommandExists(_cur_t,_node_arg(-1)), 1 )
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_value_expression
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_CURLY)
        temporarily _cur_t = _on_t
          r_value_table
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          r_value_list
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      r_expression
      _cur_t = _previous_cur_t

    method r_value_list
      local _previous_cur_t = _cur_t
      this.ip = ip
      use_Value
      ip = this.ip
      r_consume_eols
      if (_consume(TokenType.SYMBOL_CLOSE_SQUARE))
        if (not disable_output) _push( EmptyValueList(_cur_t), 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _begin_list
      r_value_expression
      r_consume_eols
      while ((_consume(TokenType.SYMBOL_COMMA) or (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
        r_consume_eols
        r_value_expression
        r_consume_eols
      endWhile
      if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
      if (disable_output)     _discard_list
      else                    _push_list( Args(_list_t) )
      if (not disable_output) _push( ValueList(_cur_t,_node_arg(-1)), 1 )
      _cur_t = _previous_cur_t
      return

    method r_value_table
      local _previous_cur_t = _cur_t
      this.ip = ip
      use_Value
      ip = this.ip
      r_consume_eols
      if (_consume(TokenType.SYMBOL_CLOSE_CURLY))
        if (not disable_output) _push( EmptyValueTable(_cur_t), 0 )
        _cur_t = _previous_cur_t
        return
      endIf
      _begin_list
      r_key_value_pair
      r_consume_eols
      while ((_consume(TokenType.SYMBOL_COMMA) or (not (_next_t.type == TokenType.SYMBOL_CLOSE_CURLY))))
        r_key_value_pair
      endWhile
      if (not _consume(TokenType.SYMBOL_CLOSE_CURLY)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_CURLY )
      if (disable_output)     _discard_list
      else                    _push_list( KeyValuePairList(_list_t) )
      if (not disable_output) _push( ValueTable(_cur_t,_node_arg(-1)->(as KeyValuePairList)), 1 )
      _cur_t = _previous_cur_t
      return

    method r_key_value_pair
      local _previous_cur_t = _cur_t
      r_consume_eols
      if (_consume(TokenType.SYMBOL_COLON))
        if (_next_t.type == TokenType.IDENTIFIER)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
            if (not disable_output) _push( null, 0 )
            if (not disable_output) _push( Access(_cur_t,_cur_t.content,_node_arg(-1)), 1 )
          endTemporarily
        elseIf (_next_t.type == TokenType.STRING)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
            this.ip = ip
            clone
            ip = this.ip
          endTemporarily
        else
          _throw_syntax_error("Identifier or literal string expected.")
          _cur_t = _previous_cur_t
          return
        endIf
      else
        if (_next_t.type == TokenType.IDENTIFIER)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          endTemporarily
        elseIf (_next_t.type == TokenType.STRING)
          temporarily _cur_t = _on_t
            if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
          endTemporarily
        else
          _throw_syntax_error("Identifier or literal string expected.")
          _cur_t = _previous_cur_t
          return
        endIf
        r_consume_eols
        if (not _consume(TokenType.SYMBOL_COLON)) _throw_syntax_error( &expected=TokenType.SYMBOL_COLON )
        r_consume_eols
        r_value_expression
      endIf
      if (not disable_output) _push( KeyValuePair(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      r_consume_eols
      _cur_t = _previous_cur_t

    method r_type_access_or_typed_literal_list
      local _previous_cur_t = _cur_t
      if ((_next_t.type == TokenType.SYMBOL_OPEN_SQUARE))
        r_remaining_typed_literal_list
      else
        r_access_args
        if (not disable_output) _push( TypeAccess(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)), 2 )
        r_subclass
      endIf
      _cur_t = _previous_cur_t

    method r_anonymous_tuple_or_tuple_type
      local _previous_cur_t = _cur_t
      _save_position
      r_anonymous_tuple
      if (((_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS) or (_next_t.type == TokenType.SYMBOL_QUESTION)))
        _restore_position
        r_type
        r_type_access_or_typed_literal_list
      else
        _discard_position
      endIf
      _cur_t = _previous_cur_t

    method r_anonymous_tuple
      local _previous_cur_t = _cur_t
      _consume(TokenType.SYMBOL_OPEN_PAREN)
      _begin_list
      r_consume_eols
      r_expression
      r_consume_eols
      while (_consume(TokenType.SYMBOL_COMMA))
        r_consume_eols
        r_expression
        r_consume_eols
      endWhile
      if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      if (disable_output)     _discard_list
      else                    _push_list( AnonymousTuple(_list_t) )
      _cur_t = _previous_cur_t

    method r_named_tuple_or_tuple_type
      local _previous_cur_t = _cur_t
      _save_position
      r_named_tuple
      if (((_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS) or (_next_t.type == TokenType.SYMBOL_QUESTION)))
        _restore_position
        r_type
        r_type_access_or_typed_literal_list
      else
        _discard_position
      endIf
      _cur_t = _previous_cur_t

    method r_named_tuple
      local _previous_cur_t = _cur_t
      _consume(TokenType.SYMBOL_OPEN_PAREN)
      _begin_list
      r_named_tuple_element
      while (_consume(TokenType.SYMBOL_COMMA))
        r_named_tuple_element
      endWhile
      if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      if (disable_output)     _discard_list
      else                    _push_list( NamedTuple(_list_t) )
      _cur_t = _previous_cur_t

    method r_named_tuple_element
      local _previous_cur_t = _cur_t
      r_consume_eols
      r_identifier
      r_consume_eols
      if (not _consume(TokenType.SYMBOL_COLON)) _throw_syntax_error( &expected=TokenType.SYMBOL_COLON )
      r_consume_eols
      r_expression
      r_consume_eols
      if (not disable_output) _push( NamedTupleElement(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
      _cur_t = _previous_cur_t
      return

    method r_remaining_generic_function_definition
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_WITH)
        temporarily _cur_t = _next_t
          r_with_values
        endTemporarily
      else
        if (not disable_output) _push( null, 0 )
      endIf
      if (not _consume(TokenType.SYMBOL_FAT_ARROW)) _throw_syntax_error( &expected=TokenType.SYMBOL_FAT_ARROW )
      r_single_line_statements
      if (not disable_output) _push( GenericFunctionDefinition(_cur_t,_node_arg(-3)->(as IDList),_node_arg(-2)->(as WithValues),_node_arg(-1)), 3 )
      _cur_t = _previous_cur_t
      return

    method r_native_code
      local _previous_cur_t = _cur_t
      if (_consume(TokenType.SYMBOL_OPEN_PAREN))
        r_string
        if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
      else
        r_string
      endIf
      if (_consume(TokenType.SYMBOL_ARROW))
        r_type
        if (not disable_output) _push( NativeExpression(_cur_t,_string_arg(-2),_node_arg(-1)->(as Type)), 2 )
        _cur_t = _previous_cur_t
        return
      else
        if (not disable_output) _push( NativeStatement(_cur_t,_string_arg(-1)), 1 )
        _cur_t = _previous_cur_t
        return
      endIf

    method r_literal_list
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          _begin_list
          r_consume_eols
          if (_consume(TokenType.SYMBOL_CLOSE_SQUARE))
            if (disable_output)     _discard_list
            else                    _push_list( LiteralList(_list_t) )
            _cur_t = _previous_cur_t
            return
          endIf
          r_expression
          r_consume_eols
          while ((not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE)))
            if (_consume(TokenType.SYMBOL_COMMA))
              r_consume_eols
            endIf
            r_expression
            r_consume_eols
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
          if (disable_output)     _discard_list
          else                    _push_list( LiteralList(_list_t) )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_remaining_typed_literal_list
      local _previous_cur_t = _cur_t
      r_literal_list
      if (not disable_output) _push( TypedLiteralList(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)), 2 )
      _cur_t = _previous_cur_t
      return

    method r_literal_table
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_CURLY)
        temporarily _cur_t = _on_t
          _begin_list
          r_consume_eols
          if (_consume(TokenType.SYMBOL_CLOSE_CURLY))
            if (disable_output)     _discard_list
            else                    _push_list( KeyValuePairList(_list_t) )
            _cur_t = _previous_cur_t
            return
          endIf
          r_literal_table_entry
          r_consume_eols
          while ((not (_next_t.type == TokenType.SYMBOL_CLOSE_CURLY)))
            if (_consume(TokenType.SYMBOL_COMMA))
              r_consume_eols
            endIf
            r_literal_table_entry
            r_consume_eols
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_CURLY)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_CURLY )
          if (disable_output)     _discard_list
          else                    _push_list( KeyValuePairList(_list_t) )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_literal_table_entry
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
        endTemporarily
      else
        r_expression
      endIf
      if (not _consume(TokenType.SYMBOL_COLON)) _throw_syntax_error( &expected=TokenType.SYMBOL_COLON )
      r_expression
      if (not disable_output) _push( KeyValuePair(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      _cur_t = _previous_cur_t
      return

    method r_preprocess
      local _previous_cur_t = _cur_t
      while ((_position < _limit))
        r_process_another
      endWhile
      if (not disable_output) _push( null, 0 )
      _cur_t = _previous_cur_t
      return

    method r_process_another
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.META_DEFINE)
        temporarily _cur_t = _on_t
          this.ip = ip
          mark_token
          ip = this.ip
          if (_next_t.type == TokenType.IDENTIFIER)
            temporarily _cur_t = _on_t
              buffer.clear
              buffer.print ""
              this.ip = ip
              collect_token_string
              ip = this.ip
              while (((_position < _limit) and (not (_next_t.type == TokenType.EOL))))
                this.ip = ip
                collect_next_token
                ip = this.ip
              endWhile
              this.ip = ip
              create_definition
              ip = this.ip
            endTemporarily
          else
            _throw_syntax_error("Identifier expected.")
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      elseIf (_next_t.type == TokenType.META_JOIN_IDS)
        temporarily _cur_t = _on_t
          this.ip = ip
          begin_join_ids
          ip = this.ip
          if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
          r_process_another
          while ((_consume(TokenType.SYMBOL_COMMA) or (not (_next_t.type == TokenType.SYMBOL_CLOSE_PAREN))))
            r_process_another
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          this.ip = ip
          end_join_ids
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_INCLUDE)
        temporarily _cur_t = _on_t
          r_collect_meta_filepath
          include_attribute_optional = false
          r_include_attributes
          this.ip = ip
          include_filepath
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_IS_DEFINED)
        temporarily _cur_t = _on_t
          if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
          if (_next_t.type == TokenType.IDENTIFIER)
            temporarily _cur_t = _on_t
              this.ip = ip
              on_is_defined
              ip = this.ip
            endTemporarily
          else
            _throw_syntax_error("Identifier expected.")
            _cur_t = _previous_cur_t
            return
          endIf
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_LOCAL_DEFINE)
        temporarily _cur_t = _on_t
          this.ip = ip
          mark_token
          ip = this.ip
          if (_next_t.type == TokenType.IDENTIFIER)
            temporarily _cur_t = _on_t
              buffer.clear
              buffer.print ""
              this.ip = ip
              collect_token_string
              ip = this.ip
              while (((_position < _limit) and (not (_next_t.type == TokenType.EOL))))
                this.ip = ip
                collect_next_token
                ip = this.ip
              endWhile
              this.ip = ip
              create_local_definition
              ip = this.ip
            endTemporarily
          else
            _throw_syntax_error("Identifier expected.")
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      elseIf (_next_t.type == TokenType.META_LOCAL_MACRO)
        temporarily _cur_t = _on_t
          r_identifier
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
          _begin_list
          r_placeholder
          while (_consume(TokenType.SYMBOL_COMMA))
            r_placeholder
          endWhile
          if (disable_output)     _discard_list
          else                    _push_list( Placeholders(_list_t) )
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          if ((_next_t.type == TokenType.EOL))
            r_consume_eols
            _save_position
            while (((_position < _limit) and (not (_next_t.type == TokenType.META_END_LOCAL_MACRO))))
              _read
            endWhile
            if (disable_output) _discard_position
            else                _create_token_list
            if (not _consume(TokenType.META_END_LOCAL_MACRO)) _throw_syntax_error( &expected=TokenType.META_END_LOCAL_MACRO )
          else
            _save_position
            while (((_position < _limit) and (not (_next_t.type == TokenType.EOL))))
              _read
            endWhile
            if (disable_output) _discard_position
            else                _create_token_list
            r_consume_eols
          endIf
          this.ip = ip
          define_macro
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_LOWERCASE)
        temporarily _cur_t = _on_t
          this.ip = ip
          begin_join_lowercase
          ip = this.ip
          if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
          r_process_another
          while ((_consume(TokenType.SYMBOL_COMMA) or (not (_next_t.type == TokenType.SYMBOL_CLOSE_PAREN))))
            r_process_another
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          this.ip = ip
          end_join_lowercase
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_MACRO)
        temporarily _cur_t = _on_t
          r_identifier
          if (not _consume(TokenType.SYMBOL_LTLT)) _throw_syntax_error( &expected=TokenType.SYMBOL_LTLT )
          _begin_list
          r_placeholder
          while (_consume(TokenType.SYMBOL_COMMA))
            r_placeholder
          endWhile
          if (disable_output)     _discard_list
          else                    _push_list( Placeholders(_list_t) )
          if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
          if ((_next_t.type == TokenType.EOL))
            r_consume_eols
            _save_position
            while (((_position < _limit) and (not (_next_t.type == TokenType.META_END_MACRO))))
              _read
            endWhile
            if (disable_output) _discard_position
            else                _create_token_list
            if (not _consume(TokenType.META_END_MACRO)) _throw_syntax_error( &expected=TokenType.META_END_MACRO )
          else
            _save_position
            while (((_position < _limit) and (not (_next_t.type == TokenType.EOL))))
              _read
            endWhile
            if (disable_output) _discard_position
            else                _create_token_list
            r_consume_eols
          endIf
          this.ip = ip
          define_macro
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_REQUIRE_ROGUE)
        temporarily _cur_t = _on_t
          if (_next_t.type == TokenType.STRING)
            temporarily _cur_t = _on_t
              this.ip = ip
              require_rogue_version
              ip = this.ip
              _cur_t = _previous_cur_t
              return
            endTemporarily
          else
            _throw_syntax_error("Expected a literal string containing a version number.")
            _cur_t = _previous_cur_t
            return
          endIf
        endTemporarily
      elseIf (_next_t.type == TokenType.META_ROGUE_VERSION)
        temporarily _cur_t = _on_t
          this.ip = ip
          create_rogue_version_string
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_SOURCE_FILEPATH)
        temporarily _cur_t = _on_t
          this.ip = ip
          create_source_filepath
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_SOURCE_LINE)
        temporarily _cur_t = _on_t
          this.ip = ip
          create_source_line
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_TARGET)
        temporarily _cur_t = _on_t
          if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
            temporarily _cur_t = _on_t
              this.ip = ip
              check_target
              ip = this.ip
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            endTemporarily
          else
            this.ip = ip
            check_target
            ip = this.ip
          endIf
        endTemporarily
      elseIf (_next_t.type == TokenType.META_JOIN_STRINGS)
        temporarily _cur_t = _on_t
          this.ip = ip
          begin_join_strings
          ip = this.ip
          if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
          r_process_another
          while ((_consume(TokenType.SYMBOL_COMMA) or (not (_next_t.type == TokenType.SYMBOL_CLOSE_PAREN))))
            r_process_another
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          this.ip = ip
          end_join_strings
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.META_UPPERCASE)
        temporarily _cur_t = _on_t
          this.ip = ip
          begin_join_uppercase
          ip = this.ip
          if (not _consume(TokenType.SYMBOL_OPEN_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_PAREN )
          r_process_another
          while ((_consume(TokenType.SYMBOL_COMMA) or (not (_next_t.type == TokenType.SYMBOL_CLOSE_PAREN))))
            r_process_another
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          this.ip = ip
          end_join_uppercase
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.KEYWORD_USES)
        temporarily _cur_t = _on_t
          this.ip = ip
          rewrite_cur_token
          ip = this.ip
          r_collect_meta_filepath
          _save_position
          r_uses_attributes
          _restore_position
          this.ip = ip
          uses_filepath
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      elseIf (_next_t.type == TokenType.IDENTIFIER)
        temporarily _cur_t = _on_t
          this.ip = ip
          insert_definition
          ip = this.ip
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      this.ip = ip
      rewrite_token
      ip = this.ip
      _cur_t = _previous_cur_t

    method r_include_attributes
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
        temporarily _cur_t = _on_t
          while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
            r_include_attribute
            _consume(TokenType.SYMBOL_COMMA)
          endWhile
          if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
        endTemporarily
      endIf
      _cur_t = _previous_cur_t

    method r_include_attribute
      local _previous_cur_t = _cur_t
      if (_next_t.content and _next_t.content == "optional")
        temporarily _cur_t = _on_t
          include_attribute_optional = true
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Illegal $include attribute. Expected [optional].")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_meta_expression
      local _previous_cur_t = _cur_t
      r_meta_term
      _cur_t = _previous_cur_t

    method r_meta_term
      local _previous_cur_t = _cur_t
      if (_next_t.type == TokenType.KEYWORD_TRUE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralLogical(_cur_t,_string_to_Logical("true")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.KEYWORD_FALSE)
        temporarily _cur_t = _on_t
          if (not disable_output) _push( LiteralLogical(_cur_t,_string_to_Logical("false")), 0 )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
        temporarily _cur_t = _on_t
          r_meta_expression
          if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
          _cur_t = _previous_cur_t
          return
        endTemporarily
      endIf
      _throw_syntax_error("Invalid metacondition.")
      _cur_t = _previous_cur_t
      return
      _cur_t = _previous_cur_t

    method r_collect_meta_filepath
      local _previous_cur_t = _cur_t
      this.ip = ip
      mark_token
      ip = this.ip
      buffer.clear
      buffer.print ""
      if (_next_t.type == TokenType.STRING)
        temporarily _cur_t = _on_t
          this.ip = ip
          collect_token_string
          ip = this.ip
        endTemporarily
      else
        while ((((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE))) and (not (_next_t.type == TokenType.EOL))))
          if (_next_t.type == TokenType.IDENTIFIER)
            temporarily _cur_t = _on_t
              this.ip = ip
              collect_token_string
              ip = this.ip
            endTemporarily
          elseIf (_next_t.type == TokenType.INTEGER)
            temporarily _cur_t = _on_t
              this.ip = ip
              collect_token_string
              ip = this.ip
            endTemporarily
          elseIf (_next_t.type == TokenType.REAL_NUMBER)
            temporarily _cur_t = _on_t
              this.ip = ip
              collect_token_string
              ip = this.ip
            endTemporarily
          elseIf (_next_t.type == TokenType.SYMBOL_TILDE)
            temporarily _cur_t = _on_t
              this.ip = ip
              collect_token_string
              ip = this.ip
            endTemporarily
          elseIf (_next_t.type == TokenType.SYMBOL_SLASH)
            temporarily _cur_t = _on_t
              this.ip = ip
              collect_token_string
              ip = this.ip
            endTemporarily
          elseIf (_next_t.type == TokenType.SYMBOL_COLON)
            temporarily _cur_t = _on_t
              this.ip = ip
              collect_token_string
              ip = this.ip
            endTemporarily
          elseIf (_next_t.type == TokenType.SYMBOL_PERIOD)
            temporarily _cur_t = _on_t
              this.ip = ip
              collect_token_string
              ip = this.ip
            endTemporarily
          elseIf (_next_t.type == TokenType.SYMBOL_BACKSLASH)
            temporarily _cur_t = _on_t
              this.ip = ip
              collect_token_string
              ip = this.ip
            endTemporarily
          else
            _throw_syntax_error("Unsupported filepath character. Put the filepath in quotes.")
            _cur_t = _previous_cur_t
            return
          endIf
        endWhile
      endIf
      _cur_t = _previous_cur_t

    method r_additional_node_types
      local _previous_cur_t = _cur_t
      if (not disable_output) _push( CallDynamicMethod(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      if (not disable_output) _push( CallGlobalMethod(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( CallMethodPointer(_cur_t,_node_arg(-4),_node_arg(-3)->(as TypeList),_node_arg(-2),_node_arg(-1)->(as Type)), 4 )
      if (not disable_output) _push( CallProcedure(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( CallStaticMethod(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      if (not disable_output) _push( CallThisDynamicMethod(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( CallThisStaticMethod(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( CleanupBlock(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      if (not disable_output) _push( Compare(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      if (not disable_output) _push( Conditional(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      if (not disable_output) _push( ControlStructure(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( Convert(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( ConvertToByte(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( ConvertToCharacter(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( ConvertToInt32(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( ConvertToInt64(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( ConvertToLogical(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( ConvertToReal32(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( ConvertToReal64(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( CreateObject(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)), 2 )
      if (not disable_output) _push( CreateObject(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)->(as Local)), 2 )
      if (not disable_output) _push( CreateCompound(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)->(as Args)), 2 )
      if (not disable_output) _push( DefaultArg(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( DummyInitialValue(_cur_t), 0 )
      if (not disable_output) _push( EnumValue(_cur_t,_node_arg(-2)->(as Type),_string_arg(-1)), 2 )
      if (not disable_output) _push( EnumValueDef(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( EmptyCompound(_cur_t,_node_arg(-1)->(as Type)), 1 )
      if (not disable_output) _push( Escape(_cur_t), 0 )
      if (not disable_output) _push( ForEachControl(_cur_t,_string_arg(-3),_node_arg(-2)->(as ForEachAt),_node_arg(-1)->(as ForEachCollection)), 3 )
      if (not disable_output) _push( FunctionReturnValue(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( IfConditionalContext(_cur_t,_node_arg(-2)->(as ConditionalContext),_node_arg(-1)), 2 )
      if (not disable_output) _push( InlineAssignment(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( IntrospectionGetObjectProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( Iterator(_cur_t,_node_arg(-4),_node_arg(-3),_node_arg(-2),_node_arg(-1)), 4 )
      if (not disable_output) _push( GetGlobalProperty(_cur_t,_node_arg(-1)->(as Property)), 1 )
      if (not disable_output) _push( GetLocal(_cur_t,_node_arg(-1)->(as Local)), 1 )
      if (not disable_output) _push( GetProperty(_cur_t,_node_arg(-2),_node_arg(-1)->(as Property)), 2 )
      if (not disable_output) _push( GetThisProperty(_cur_t,_node_arg(-1)->(as Property)), 1 )
      if (not disable_output) _push( GetSingleton(_cur_t,_node_arg(-1)->(as Type)), 1 )
      if (not disable_output) _push( Literal(_cur_t), 0 )
      if (not disable_output) _push( LiteralNullOptional(_cur_t,_node_arg(-1)->(as Type)), 1 )
      if (not disable_output) _push( LiteralPrimitive(_cur_t), 0 )
      if (not disable_output) _push( LiteralInt32(_cur_t,_integer_arg(-1)), 1 )
      if (not disable_output) _push( LiteralInt64(_cur_t,_integer_arg(-1)), 1 )
      if (not disable_output) _push( LiteralReal32(_cur_t,_real_arg(-1)), 1 )
      if (not disable_output) _push( LiteralReal64(_cur_t,_real_arg(-1)), 1 )
      if (not disable_output) _push( LocalDeclaration(_cur_t,_node_arg(-1)->(as Local)), 1 )
      if (not disable_output) _push( Logicalized(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( NativeProperty(_cur_t,_string_arg(-1)), 1 )
      if (not disable_output) _push( OpAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
      if (not disable_output) _push( PreDecrementLocal(_cur_t,_node_arg(-1)->(as Local)), 1 )
      if (not disable_output) _push( Procedure(_cur_t,_string_arg(-5),_node_arg(-4)->(as Parameters),_node_arg(-3)->(as Type),_node_arg(-2)->(as Attributes),_node_arg(-1)->(as LocalScope)), 5 )
      if (not disable_output) _push( PushStackTraceCutoff(_cur_t), 0 )
      if (not disable_output) _push( CreateRange(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)), 3 )
      if (not disable_output) _push( ReturnOnException(_cur_t), 0 )
      if (not disable_output) _push( SetGlobalProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( SetLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( SetProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
      if (not disable_output) _push( SetSingleton(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)), 2 )
      if (not disable_output) _push( SetThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( Stepper(_cur_t,_node_arg(-1)), 1 )
      if (not disable_output) _push( Switch(_cur_t,_node_arg(-3),_node_arg(-2)->(as WhichCases),_node_arg(-1)), 3 )
      if (not disable_output) _push( TypeContext(_cur_t,_node_arg(-1)->(as Type)), 1 )
      if (not disable_output) _push( TypeIndex(_cur_t,_node_arg(-1)->(as Type)), 1 )
      if (not disable_output) _push( WideningCast(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
      if (not disable_output) _push( ResolvedOpAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( ResolvedOpAndAssignProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( AddAndAssignGlobalProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( AddAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( AddAndAssignProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
      if (not disable_output) _push( AddAndAssignThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( SubtractAndAssignGlobalProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( SubtractAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( SubtractAndAssignProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
      if (not disable_output) _push( SubtractAndAssignThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( MultiplyAndAssignGlobalProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( MultiplyAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( MultiplyAndAssignProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
      if (not disable_output) _push( MultiplyAndAssignThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( DivideAndAssignGlobalProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( DivideAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( DivideAndAssignProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
      if (not disable_output) _push( DivideAndAssignThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitwiseAndAndAssignGlobalProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitwiseAndAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitwiseAndAndAssignProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
      if (not disable_output) _push( BitwiseAndAndAssignThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitwiseOrAndAssignGlobalProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitwiseOrAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitwiseOrAndAssignProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
      if (not disable_output) _push( BitwiseOrAndAssignThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitwiseXorAndAssignGlobalProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitwiseXorAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitwiseXorAndAssignProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
      if (not disable_output) _push( BitwiseXorAndAssignThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitShiftLeftAndAssignGlobalProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitShiftLeftAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitShiftLeftAndAssignProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
      if (not disable_output) _push( BitShiftLeftAndAssignThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitShiftRightXAndAssignGlobalProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitShiftRightXAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
      if (not disable_output) _push( BitShiftRightXAndAssignProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
      if (not disable_output) _push( BitShiftRightXAndAssignThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
      if (not disable_output) _push( DecrementGlobalProperty(_cur_t,_node_arg(-1)->(as Property)), 1 )
      if (not disable_output) _push( DecrementLocal(_cur_t,_node_arg(-1)->(as Local)), 1 )
      if (not disable_output) _push( DecrementProperty(_cur_t,_node_arg(-2),_node_arg(-1)->(as Property)), 2 )
      if (not disable_output) _push( DecrementThisProperty(_cur_t,_node_arg(-1)->(as Property)), 1 )
      if (not disable_output) _push( IncrementGlobalProperty(_cur_t,_node_arg(-1)->(as Property)), 1 )
      if (not disable_output) _push( IncrementLocal(_cur_t,_node_arg(-1)->(as Local)), 1 )
      if (not disable_output) _push( IncrementProperty(_cur_t,_node_arg(-2),_node_arg(-1)->(as Property)), 2 )
      if (not disable_output) _push( IncrementThisProperty(_cur_t,_node_arg(-1)->(as Property)), 1 )
      _cur_t = _previous_cur_t

endClass

class ParserPosition( position:Int32, cmd_stack_count:Int32, cur_t:Token ) [compound];
