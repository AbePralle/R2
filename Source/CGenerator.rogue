module R2

augment
  METHODS
    method Block.needs_semicolon->Logical
      return false

    method Cmd.needs_semicolon->Logical
      return true

    method Type.c_name->String
      throw t.error( "[INTERNAL] $.c_name() is undefined." (type_name) )

    method Module.write_c_routine_header( r:Routine, writer:CWriter )
      if (r.return_type)
        writer.print( r.return_type.c_name ).print( ' ' )
      else
        writer.print( "void " )
      endIf
      writer.print( r.name )
      writer.print( "(" )
      writer.print( ")" )

    method Module.generate_c_header( writer:CWriter )
      forEach (r in routines)
        write_c_routine_header( r, writer )
        writer.println ";"
      endForEach

    method Module.generate_c_code( writer:CWriter )
      forEach (r in routines)
        write_c_routine_header( r, writer )
        writer.println
        writer.println( "{" )
        writer.indent += 2

        CGenerator( this, writer ).visit( r.statements )

        writer.indent -= 2
        writer.println( "}" )
      endForEach

    method Program.generate_c
      # Combine on_launch from all modules into default module on_launch
      local r_on_launch = default_module.routines[ "on_launch()" ]
      assert r_on_launch
      if (r_on_launch.statements.count)
        local cmd_block = Block( r_on_launch.t )
        cmd_block.statements.add( forEach in r_on_launch.statements )
        r_on_launch.statements.clear
        r_on_launch.statements.add( cmd_block )
      endIf

      forEach (m in modules)
        if (m is not default_module)
          local r = m.routines[ "on_launch()" ]
          if (r)
            m.routines.remove( r )
            if (r.statements.count)
              local cmd_block = Block( r.t )
              cmd_block.statements.add( forEach in r.statements )
              r_on_launch.statements.add( cmd_block )
            endIf
          endIf
        endIf
      endForEach

      r_on_launch.resolve

      local h_writer = CWriter( File("Test.h"), &header )

      (forEach in modules).generate_c_header( h_writer )
      h_writer.close

      local c_writer = CWriter( File("Test.c") )

      (forEach in modules).generate_c_code( c_writer )
      c_writer.println @|
                        |int main( int argc, char* argv[] )
                        |{
      c_writer.indent += 2

      c_writer.println @|on_launch();
                        |return 0;

      c_writer.indent -= 2
      c_writer.println @|}

      c_writer.close

endAugment

class CGenerator : Visitor
  PROPERTIES
    writer         : CWriter
    this_module    : Module
    this_type      : Type
    this_procedure : Procedure

  METHODS
    method init( this_module, writer )

    method on_visit( cmd:Cmd )
      throw UnsupportedOperationError("CGenerator.on_visit($)"(cmd.type_name))

    method on_visit( cmd:CmdList )
      visit_children( cmd )

    method on_visit( cmd:Block )
      writer.println '{'
      writer.indent += 2
      visit_children( cmd )
      writer.indent -= 2
      writer.println '}'

    #method on_visit( cmd:LocalDeclarations )
    #  visit_children( cmd )

    #method on_visit( cmd:LocalDef )

    method on_visit( cmd:Statements )
      forEach (statement in cmd)
        visit( statement )
        if (statement.needs_semicolon) writer.println( ';' )
      endForEach

    method on_visit( cmd:PrintString )
      writer.print( ''printf( "$" )''(cmd.operand->String.to_escaped_ascii('"')) )

    method on_visit( cmd:PrintNewline )
      writer.print( ''putchar( '\\n' )'' )
endClass

# write_print()
augment
  METHODS
    method Cmd.write_print( writer:CWriter )
      throw UnsupportedOperationError("$.write_print()"(type_name))

    method LiteralInt32.write_print( writer:CWriter )
      writer.print ''printf( "%d", $ )'' (value)

    method LiteralString.write_print( writer:CWriter )
      writer.print ''printf( "$" )'' (value.to_escaped_ascii(''"''))
endAugment

