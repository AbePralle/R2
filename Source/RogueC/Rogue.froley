================================================================================
# Rogue.froley
================================================================================

--------------------------------------------------------------------------------
tokens
--------------------------------------------------------------------------------
EOL(end of line)             [content]
CHARACTER      character     [content]
BINARY_INTEGER integer       [content]
OCTAL_INTEGER  integer       [content]
HEX_INTEGER    integer       [content]
INTEGER        integer       [content]
REAL_NUMBER    real          [content]
STRING         string        [content]
IDENTIFIER     identifier    [content]
SYMBOL_DOLLAR  $
PLACEHOLDER    $placeholder  [content]

----------------------------------------------------------------------
tokens Keywords
----------------------------------------------------------------------
KEYWORD_AND            and
KEYWORD_AUGMENT        augment
KEYWORD_BLOCK          block
KEYWORD_CATCH          catch       [structural]
KEYWORD_CLASS          class       [structural]
KEYWORD_DEFINITIONS    DEFINITIONS [structural]
KEYWORD_DOWN_TO        downTo
KEYWORD_ELSE           else        [structural]
KEYWORD_ELSE_IF        elseIf
KEYWORD_END_BLOCK      endBlock    [structural]
KEYWORD_END_CLASS      endClass    [structural]
KEYWORD_END_FOR_EACH   endForEach  [structural]
KEYWORD_END_IF         endIf       [structural]
KEYWORD_END_LOOP       endLoop     [structural]
KEYWORD_END_ROUTINE    endRoutine  [structural]
KEYWORD_END_TRY        endTry      [structural]
KEYWORD_END_WHICH      endWhich    [structural]
KEYWORD_END_WHILE      endWhile    [structural]
KEYWORD_EXPORT         export
KEYWORD_FALSE          false
KEYWORD_FOR_EACH       forEach
KEYWORD_GLOBAL         global
KEYWORD_GLOBAL_PROPERTIES(GLOBAL PROPERTIES) [structural]
KEYWORD_GLOBAL_METHODS(GLOBAL METHODS)       [structural]
KEYWORD_IF             if
KEYWORD_IMPORT         import
KEYWORD_INCLUDE        include
KEYWORD_IS             is
KEYWORD_LOCAL          local
KEYWORD_LOOP           loop
KEYWORD_METHOD         method      [structural]
KEYWORD_METHODS        METHODS     [structural]
KEYWORD_MODULE         module      [structural]
KEYWORD_NATIVE_SECTION NATIVE      [structural]
KEYWORD_NATIVE         native
KEYWORD_NATIVE_HEADER  nativeHeader
KEYWORD_NATIVE_CODE    nativeCode
KEYWORD_NO_ACTION      noAction
KEYWORD_NOT            not
KEYWORD_NULL           null
KEYWORD_OR             or
KEYWORD_PI             pi
KEYWORD_PROPERTIES     PROPERTIES  [structural]
KEYWORD_RETURN         return
KEYWORD_ROUTINE        routine     [structural]
KEYWORD_THIS           this
KEYWORD_THROW          throw
KEYWORD_TRUE           true
KEYWORD_TRY            try
KEYWORD_UNDEFINED      undefined
KEYWORD_USES           uses        [structural]
KEYWORD_WHICH          which
KEYWORD_WHILE          while
KEYWORD_XOR            xor

----------------------------------------------------------------------
tokens Symbols
----------------------------------------------------------------------
META_DEFINE  $define   [meta]
META_INCLUDE $include  [meta]

SYMBOL_AMPERSAND             &
SYMBOL_ARROW                 ->
SYMBOL_ASTERISK              *
SYMBOL_AT                    @
SYMBOL_BACKSLASH             \
SYMBOL_BANG                  !
SYMBOL_CARET                 ^
SYMBOL_CLOSE_CURLY           }   [structural]
SYMBOL_CLOSE_SQUARE          ]   [structural]
SYMBOL_CLOSE_PAREN           )   [structural]
SYMBOL_COLON                 :   [structural]
SYMBOL_COLON_COLON           ::
SYMBOL_COMMA                 ,   [structural]
SYMBOL_DOTDOT                ..
SYMBOL_DOTDOTLT              ..<
SYMBOL_DOTDOTGT              ..>
SYMBOL_DOUBLE_VERTICAL_BAR   ||  [structural]
SYMBOL_EMPTY_SQUARE_BRACKETS []
SYMBOL_EQ                    ==
SYMBOL_EQUALS                =
SYMBOL_GE                    >=
SYMBOL_GT                    >
SYMBOL_GTGT                  >>  [structural]
SYMBOL_LE                    <=
SYMBOL_LEFT_SHIFT            :<<:
SYMBOL_LEFT_SHIFT_EQUALS     :<<:=
SYMBOL_LITERAL_OPEN_SQUARE   @[
SYMBOL_LT                    <
SYMBOL_LTLT                  <<
SYMBOL_MINUS                 -
SYMBOL_MINUS_MINUS           --
SYMBOL_NE                    !=
SYMBOL_OPEN_CURLY            {
SYMBOL_OPEN_SQUARE           [
SYMBOL_OPEN_PAREN            (
SYMBOL_PERCENT               %
SYMBOL_PERIOD                .
SYMBOL_PLUS                  +
SYMBOL_PLUS_PLUS             ++
SYMBOL_QUESTION              ?
SYMBOL_QUESTION_COLON        ?:
SYMBOL_RIGHT_SHIFT           :>>:
SYMBOL_RIGHT_SHIFT_EQUALS    :>>:=
SYMBOL_RIGHT_SHIFT_X         :>>>:
SYMBOL_RIGHT_SHIFT_X_EQUALS  :>>>:=
SYMBOL_SEMICOLON             ;
SYMBOL_SLASH                 /
SYMBOL_TILDE                 ~
SYMBOL_VERTICAL_BAR          |

SYMBOL_PLUS_EQUALS           +=
SYMBOL_MINUS_EQUALS          -=
SYMBOL_TIMES_EQUALS          *=
SYMBOL_DIVIDE_EQUALS         /=
SYMBOL_MOD_EQUALS            %=
SYMBOL_AND_EQUALS            &=
SYMBOL_OR_EQUALS             |=

----------------------------------------------------------------------
scanner
----------------------------------------------------------------------
- tokenize_another
  consume [ \r\t]*                 # whitespace
  markPosition
  scan_comment

  if (not hasAnother)
    create EOL
    halt
  endIf

  if (consume("..."))
    while (hasAnother and not consume('\n')) read
    restart
  endIf

  match input
    produceAny Symbols
    case '\n': produce EOL
    case '"':  tokenize_string
    case "'":  tokenize_character_or_string
    case "''": tokenize_two_quote_string
    case "@|": tokenize_verbatim_string
  endMatch

  if (scan('$'))
    if (scan([_a-zA-Z0-9]*)) produce PLACEHOLDER
    produce SYMBOL_DOLLAR
  endIf

  scan_id_or_keyword
  scan_number

  syntaxError

- scan_comment
  if (consume('#'))
    if (consume('{'))
      count = 1
      while (hasAnother)
        ch = read
        if (ch == '\n')
          create EOL
        elseIf (ch == '#')
          if (consume('{')) ++count
        elseIf (ch == '}')
          if (consume('#'))
            --count
            if (count == 0) restart
          endIf
        endIf
      endWhile
      syntaxError "Unterminated multi-line comment."
    else
      # Single line comment
      if scan [^\n]*
        consume '\n'
        produce EOL
      endIf
    endIf

  elseIf (consume({"----"[-]*}) or consume({"===="[=]*}))
    # HR comments
    scan [^\n]*
    consume '\n'
    produce EOL

  else
    return

  endIf

- scan_id_or_keyword
  if (not scan([_a-zA-Z][_a-zA-Z0-9]*)) return

  match buffer
    produceAny Keywords
    case "GLOBAL"
      # "GLOBAL PROPERTIES" / "GLOBAL METHODS"
      if (consume [ ]+)
        collect ' '
        if (scan([_a-zA-Z][_a-zA-Z0-9]*))
          match buffer
            case "GLOBAL PROPERTIES" -> KEYWORD_GLOBAL_PROPERTIES
            case "GLOBAL METHODS"    -> KEYWORD_GLOBAL_METHODS
            others
              syntaxError "Expected 'GLOBAL PROPERTIES' or 'GLOBAL METHODS'."
          endMatch
        endIf
      endIf
    others
      produce IDENTIFIER
  endMatch

- scan_number
  if (not nextIs([0-9]) or nextIs([.][0-9])) return

  match input
    case "0b"
      base = 2
      scan_binary_integer
      produce BINARY_INTEGER
    case "0c"
      base = 8
      scan_octal_integer
      produce OCTAL_INTEGER
    case "0x"
      base = 16
      scan_hex_integer
      produce HEX_INTEGER
    others
      scan_integer
      if (nextIs('.'))
        ch = peek(1)
        if (ch >= 'a' and ch <= 'z' or ch >= 'A' and ch <= 'Z' or ch == '_' or ch == '.') produce INTEGER
      endIf
      if (not scan('.')) produce INTEGER
      scan_integer
      if (scan([eE]))
        scan [+-]
        if (not scan([0-9]+)) syntaxError "Integer exponent expected."
      endIf
      produce REAL_NUMBER
  endMatch

- scan_integer
  while (scan([0-9]+))
    if (not consume([_]+)) return
  endWhile
  return

- scan_binary_integer
  while (scan([01]+))
    if (not consume([_]+)) return
  endWhile
  return

- scan_octal_integer
  while (scan([0-7]+))
    if (not consume([_]+)) return
  endWhile
  return

- scan_hex_integer
  while (scan([0-9A-Fa-f]+))
    if (not consume([_]+)) return
  endWhile
  return

- tokenize_string
  scan_string
  produce STRING

- scan_string
  while (hasAnother and not nextIs('"'))
    scan_character
  endWhile
  mustConsume '"'
  return

- tokenize_character_or_string
  if (consume('\'')) produce STRING
  scan_character
  if (consume('\'')) produce CHARACTER
  while (hasAnother and not nextIs('\''))
    scan_character
  endWhile
  mustConsume('\'')
  produce STRING

- scan_single_quote_string
  while (hasAnother and not nextIs('\''))
    scan_character
  endWhile
  mustConsume '\''
  return

- tokenize_two_quote_string
  scan_two_quote_string
  produce STRING

- scan_two_quote_string
  while (hasAnother and not nextIs("''"))
    scan_character
  endWhile
  mustConsume "''"
  return

- scan_character
  if (not hasAnother) syntaxError "Unterminated string - unexpected end of file."
  ch = read
  if (ch == '\n')
    syntaxError "Unterminated string - unexpected end of line."
  endIf
  if (ch != '\\')
    collect ch
    return
  endIf

  if (consume('b')) collect Character(8); return
  if (consume('e')) collect Character(27); return
  if (consume('f')) collect Character(12); return
  if (consume('n')) collect '\n'; return
  if (consume('r')) collect '\r'; return
  if (consume('t')) collect '\t'; return
  if (consume('v')) collect Character(11); return
  if (consume('0')) collect Character(0); return
  if (consume('/')) collect '/'; return
  if (consume('?')) collect '?'; return
  if (consume('\''))collect '\''; return
  if (consume('\\'))collect '\\'; return
  if (consume('"')) collect '"'; return
  if (consume('x'))
    hex2 = 0
    read_hex2
    collect Character(hex2)
    return
  endIf
  if (consume('u'))
    read_hex4
    collect Character(hex4)
    return
  endIf
  if (consume('['))
    hex_digit = 0
    read_hex_digit
    value = hex_digit
    digits = 1
    while (digits < 6 and nextIs([0-9a-fA-F]))
      read_hex_digit
      value = value * 16 + hex_digit
      ++digits
    endWhile
    mustConsume ']'
    collect Character(value)
    return
  endIf
  buffer = ""
  collect "Invalid escape sequence '\\" ch
  collect "'. Supported: \\b \\e \\f \\n \\r \\t \\v \\0 \\? \\/ \\' \\\\ \\\" \\xHH \\uHHHH \\[H*]."
  syntaxError buffer

- read_hex4
  read_hex2
  hex4 = hex2 * 256
  read_hex2
  hex4 = hex4 + hex2
  return

- read_hex2
  read_hex_digit
  hex2 = hex_digit * 16
  read_hex_digit
  hex2 = hex2 + hex_digit
  return

- read_hex_digit
  if (not nextIs([0-9a-fA-F])) syntaxError "Hex digit expected (0-9, a-f, or A-F)."
  ch = read
  if (ch >= 'a' and ch <= 'f')
    hex_digit = (ch - Integer('a')) + 10
  elseIf (ch >= 'A' and ch <= 'F')
    hex_digit = (ch - Integer('A')) + 10
  else
    hex_digit = ch - Integer('0')
  endIf
  return

- tokenize_verbatim_string
  scan_verbatim_string
  produce STRING

- scan_verbatim_string
  while (hasAnother)
    scan [^\n]*
    consume '\n'
    consume [ ]*
    if (not consume('|')) return
    collect '\n'
  endWhile
  return


----------------------------------------------------------------------
parser
----------------------------------------------------------------------
- program_elements
  beginList
    while (hasAnother) program_element
  produceList

- consume_eols
  while (consume(EOL)) noAction

- must_consume_eols
  if (not consume(EOL)) syntaxError "End of line expected."
  while (consume(EOL)) noAction

- consume_eols_and_semicolons
  while (consume(EOL) or consume(';')) noAction

- program_element
  consume_eols
  if (not hasAnother) return

  if (nextIs("class"))
    savePosition
    ++disable_output

    consume("class")
    identifier
    template_parameters
    class
    call on_parsed_class

    --disable_output
    discardPosition

    return
  endIf

  on "module"
    call parse_module_id
    module_attributes
    produce DefineModule(name:String,attributes:Attributes)
  endOn

  on "routine"
    identifier
    procedure_parameters
    procedure_return_type
    procedure_attributes
    if (consume(':'))
      single_line_statements
    else
      multi_line_statements
      mustConsume "endRoutine"
    endIf
    create LocalScope(statements):ControlStructure
    produce Routine(name:String,parameters:Parameters,return_type:Type,attributes:Attributes,body:LocalScope):Procedure
  endOn

  on "uses" string uses_attributes -> UsesModule(path,attributes:Attributes)

  if (nextHasAttribute(structural))
    syntaxError
  endIf

  procedure_body

- procedure_attributes
  beginList
    on '['
      while (hasAnother and not nextIs(']'))
        procedure_attribute
        consume ','
      endWhile
      mustConsume(']')
    endOn
  produceList Attributes

- procedure_attribute
  on @"append" -> AttributeAppend
  on @"insert" -> AttributeInsert
  syntaxError "Illegal procedure attribute. Expected one or more of [append insert]."

- procedure_body
  multi_line_statements

- procedure_parameters
  beginList
    if (not consume('(')) produceList
    if (consume(')')) produceList
    procedure_parameter
    while (consume(',')) procedure_parameter
    mustConsume ')'
  produceList Parameters

- procedure_parameter
  consume_eols
  on IDENTIFIER optional_initial_value optional_type -> Local(name=content,initial_value,type:Type)
  #on '&' identifier optional_initial_value optional_type -> FlagParameter(name:String,initial_value,type:Type):Parameter
  mustConsume IDENTIFIER  # generate error message

- optional_initial_value
  if (consume('=')) consume_eols; expression
  else              createNull

- procedure_return_type
  if (not consume('->')) produceNull
  type

- id_or_type
  type_name
  if (not nextIs("<<")) return
  type_args
  produce Type(name:String,type_args:TemplateArgs)

- type
  type_name
  if (nextIs("<<")) type_args
  else              createNull
  produce Type(name:String,type_args:TemplateArgs)

- type_args
  consume("<<")
  beginList
    consume_eols
    if (not consume(">>"))
      template_arg_tokens
      consume_eols
      while (consume(','))
        consume_eols
        template_arg_tokens
        consume_eols
      endWhile
      mustConsume(">>")
    endIf
  createList TemplateArgs

- template_arg_tokens
  savePosition
  while (hasAnother and not nextIs(',') and not nextIs(">>"))
    read
  endWhile
  produceTokenList

- type_name
  #identifier
  #on "[]": create Join(a:String,b="[]")
  savePosition
  on "::"
    create Identifier(name="\"Rogue\"":String)
    identifier
    create ModuleQualifiedID(context,name:String)
    discardPosition
  elseOnOthers
    restorePosition
    identifier
  endOn

  while nextIs("::")
    on "::"
      identifier
      create ModuleQualifiedID(context,name:String)
    endOn
  endWhile

  #while (consume("[]")) noAction TODO

- optional_type
  if (consume(':')) type
  else              createNull

- identifier
  on IDENTIFIER  -> Identifier(name=content)
  if (nextIs(PLACEHOLDER))
    if (not disable_output) syntaxError
    on PLACEHOLDER -> Identifier(name=content)
  endIf
  syntaxError "Identifier expected."

- string
  on STRING -> LiteralString(value=content):Literal
  syntaxError "Literal string expected."

- module_attributes
  beginList
    on '['
      while (hasAnother and not nextIs(']'))
        module_attribute
        consume ','
      endWhile
      mustConsume(']')
    endOn
  produceList Attributes

- module_attribute
  #on "export" -> AttributeExport
  syntaxError "Illegal module attribute."

- class_attributes
  beginList
    on '['
      while (hasAnother and not nextIs(']'))
        class_attribute
        consume ','
      endWhile
      mustConsume(']')
    endOn
  produceList Attributes

- class_attribute
  on @"singleton" -> AttributeSingleton
  if (consume @"essential")
    call class_attribute_essential
    produce AttributeEssential
  elseIf (consume @"primitive")
    produce AttributePrimitive
  elseIf (consume @"aspect")
    produce AttributeAspect
  endIf
  syntaxError "Illegal class attribute. Expected one or more of [aspect essential primitive singleton]."

- class
  constructor_properties
  base_types
  class_attributes
  if (consume(';'))
    createNull
  else
    class_sections
    mustConsume "endClass"
  endIf
  produce Class( constructor_properties:Parameters, base_types:TypeList, attributes:Attributes, sections )

- placeholder
  on PLACEHOLDER -> Placeholder(name=content)
  syntaxError "'$Placeholder' name expected."

- template_parameters
  on "<<"
    beginList
      if (not consume(">>"))
        placeholder
        while (consume(','))
          placeholder
        endWhile
        mustConsume ">>"
      endIf
    produceList
  endOn
  produceNull

- constructor_properties
  if (not nextIs('(')) produceNull
  procedure_parameters

- base_types
  beginList
    if (not consume(':')) produceList TypeList
    type
    while (hasAnother and (nextIs(',') or nextIs(IDENTIFIER)))
      if (consume(',')) consume_eols
      type
    endWhile
  produceList TypeList

- attributes
  beginList
    if (not consume('[')) produceList
    if (consume(']')) produceList
    while (hasAnother and not nextIs(']'))
      identifier
      if (consume(',')) consume_eols
      else              consume_eols; consume(',')
    endWhile
    mustConsume ']'
  produceList Attributes

- class_sections
  beginList
  if (not consume(';'))
    while (not nextIs("endClass")) class_section
  endIf
  produceList

- class_section
  consume_eols
  on "GLOBAL METHODS"
    consume_eols
    while (nextIs("method"))
      global_method
      consume_eols
    endWhile
    return
  elseOn "METHODS"
    consume_eols
    while (nextIs("method"))
      method
      consume_eols
    endWhile
    return
  elseOn "PROPERTIES"
    consume_eols
    while (not nextHasAttribute(structural))
      properties
      consume_eols
    endWhile
    return
  elseOn "NATIVE"
    consume_eols
    while (not nextHasAttribute(structural))
      native_code_blocks
      consume_eols
    endWhile
    return
  elseOn "DEFINITIONS"
    consume_eols
    while (not nextHasAttribute(structural))
      definition
      consume_eols
    endWhile
    return
  endOn
  if (not nextIs("endClass")) syntaxError

- native_code_blocks
  consume_eols
  while (not nextHasAttribute(structural))
    native_code_block
    consume_eols
  endWhile

- native_code_block
  on "nativeHeader"
    consume_eols
    string
    produce NativeHeader( content:String )
  elseOn "nativeCode"
    consume_eols
    string
    produce NativeCode( content:String )
  endOn
  syntaxError "Expected 'nativeHeader' or 'nativeCode'."

- definition
  on IDENTIFIER
    mustConsume '='
    expression
    produce Definition(name=content,value)
  endOn
  mustConsume IDENTIFIER  # generate error


- forEach_loop
  on "forEach"
    if consume('(')
      consume_eols
      forEach_control
      consume_eols
      mustConsume(')')
    else
      forEach_control
    endIf
    if (consume(EOL))
      multi_line_statements
      wrap_in_local_scope
      mustConsume "endForEach"
    else
      single_line_statements
      wrap_in_local_scope
    endIf
    produce ForEach(condition:ForEachControl,statements)
  endOn

- forEach_control
  identifier
  forEach_optional_at
  if (consume(@"in"))
    forEach_collection
    produce ForEachInControl(name:String,optional_at:ForEachAt,collection:ForEachCollection):ForEachControl
  elseIf (consume(@"of"))
    forEach_collection
    produce ForEachOfControl(name:String,optional_at:ForEachAt,collection:ForEachCollection):ForEachControl
  else
    syntaxError "Expected 'in' or 'of'."
  endIf

- forEach_optional_at
  if (not consume(@"at")) produceNull
  identifier
  produce ForEachAt(name:String)

- forEach_collection
  savePosition
  createNull  # collection_name
  expression  # collection
  if (nextIs('='))
    restorePosition  # whoops
    identifier       # collection_name
    mustConsume('=')
    expression       # collection
  else
    discardPosition
  endIf

  on ".."
    expression
    create RangeUpTo(left,right):Range
  elseOn "..<"
    expression
    create RangeUpToLessThan(left,right):Range
  elseOn "..>"
    expression
    create RangeDownToGreaterThan(left,right):Range
  elseOn "downTo"
    expression
    create RangeDownTo(left,right):Range
  endOn

  if (consume(@"from")) expression
  else                  createNull

  if (consume(@"step")) expression
  else                  createNull

  produce ForEachCollection(name:String,data,starting_index,step_size)

- if_statement
  on "if"
    expression
    if (consume(EOL))
      # Multi-line 'if'
      multi_line_statements
      wrap_in_local_scope
      if_statement_multi_line_elseIf_else
      mustConsume 'endIf'
    else
      # Single-line 'if'
      single_line_statements
      wrap_in_local_scope
      if_statement_single_line_elseIf_else
    endIf
    produce If(condition,statements,cmd_else:If):Conditional
  endOn

- if_statement_multi_line_elseIf_else
  savePosition
  on 'elseIf'
    expression
    if (consume(EOL))
      # This elseIf is multi-line; good to keep going
      discardPosition
      multi_line_statements
      wrap_in_local_scope
      if_statement_multi_line_elseIf_else
      produce If(condition,statements,cmd_else:If):Conditional
    else
      # This single-line elseIf is outside the scope of the 'if' we're currently parsing.
      restorePosition
      produceNull
    endIf
  elseOn 'else'
    if (consume(EOL))
      # This else is multi-line; good to keep going
      discardPosition
      createNull
      multi_line_statements
      wrap_in_local_scope
      createNull
      produce If(condition,statements,cmd_else:If):Conditional
    else
      # This single-line else is outside the scope of the 'if' we're currently parsing.
      restorePosition
      produceNull
    endIf
  elseOnOthers
    discardPosition
    produceNull
  endOn

- if_statement_single_line_elseIf_else
  savePosition
  on 'elseIf'
    expression
    if (consume(EOL))
      # This elseIf is multi-line and outside our scope
      restorePosition
      produceNull
    else
      # This elseIf is single line; keep going
      discardPosition
      single_line_statements
      wrap_in_local_scope
      if_statement_single_line_elseIf_else
      produce If(condition,statements,cmd_else:If):Conditional
    endIf
  elseOn 'else'
    if (consume(EOL))
      # This else is multi-line and outside our scope
      restorePosition
      produceNull
    else
      # This else is single line; keep going
      discardPosition
      createNull
      single_line_statements
      wrap_in_local_scope
      createNull
      produce If(condition,statements,cmd_else:If):Conditional
    endIf
  elseOnOthers
    discardPosition
    produceNull
  endOn

- inline_which
  on "which"
    consume_eols
    mustConsume '{'
    consume_eols
    beginList
      inline_which_case
      consume_eols
      while (consume("||"))
        consume_eols
        inline_which_case
        consume_eols
      endWhile
    createList InlineWhichCases
    mustConsume '}'
    produce InlineWhich(cases:InlineWhichCases)
  endOn

- inline_which_case
  expression
  consume_eols
  if (consume(':')) expression; consume_eols
  else              createNull
  produce InlineWhichCase(condition,value)

- wrap_in_local_scope
  create LocalScope(statements):ControlStructure


- method
  on "method"
    identifier
    procedure_parameters
    procedure_return_type
    procedure_attributes
    consume(':')
    multi_line_statements
    create LocalScope(statements):ControlStructure
    produce Method(name:String,parameters:Parameters,return_type:Type,attributes:Attributes,body:LocalScope):Procedure
  endOn

- global_method
  on "method"
    identifier
    procedure_parameters
    procedure_return_type
    procedure_attributes
    consume(':')
    multi_line_statements
    create LocalScope(statements):ControlStructure
    produce GlobalMethod(name:String,parameters:Parameters,return_type:Type,attributes:Attributes,body:LocalScope):Procedure
  endOn

- properties
  beginList
    consume_eols
    property_declaration
    while (consume(','))
      consume_eols
      property_declaration
    endWhile
  createList
  optional_type
  attributes
  produce PropertyDeclarations( declarations, type:Type, attributes:Attributes )

- property_declaration
  on IDENTIFIER
    optional_initial_value
    createNull
    produce Property( name=content, initial_value, type:Type )
  elseOn "native"
    string
    produce NativeCProperty( expression:String ):NativeProperty
  endOn
  mustConsume IDENTIFIER  # throws error

- multi_line_statements
  consume_eols_and_semicolons
  if (not hasAnother) syntaxError
  beginList
  while (hasAnother and not nextHasAttribute(structural))
    control_structure
    consume_eols_and_semicolons
  endWhile
  produceList Statements

- single_line_statements
  beginList

  if (consume(EOL)) produceList Statements
  statement
  while (consume(';'))
    statement
  endWhile
  must_consume_eols

  produceList Statements

- control_structure
  on     "local"   local_declarations: return
  onPeek "block"   block:              return
  onPeek "forEach" forEach_loop:       return
  onPeek "if"      if_statement:       return
#{
  onPeek "loop"    loop:               return
  onPeek "while"   while_loop:         return
}#
  onPeek "try"     try_catch:          return
  statement

- args
  beginList

  if consume '('
    consume_eols
    if (consume(')')) produceList
    consume_eols
    while (hasAnother and not nextHasAttribute(structural))
      arg
      consume_eols
      consume ','
      consume_eols
    endWhile
    mustConsume ')'
  else
    while (hasAnother and not nextHasAttribute(structural) and not nextIs(EOL))
      arg
      if (consume ',') consume_eols
    endWhile
  endIf

  produceList Args

- arg
  expression

- statement
  #on "noAction": return
  on @"print"     args -> Print(args)
  on @"println"   args -> Println(args)
  on "return"     optional_expression -> Return(result)
  on "throw"      expression -> Throw(exception)

  onPeek "nativeHeader"
    native_code_block
    return
  elseOnPeek "nativeCode"
    native_code_block
    return
  endOn

  on "++" expression -> Preincrement(operand):Stepper
  on "--" expression -> Predecrement(operand):Stepper

  expression

  on "++" -> Postincrement(operand):Stepper
  on "--" -> Postdecrement(operand):Stepper

  on "=" expression -> Assign(target,new_value)

- local_declarations
  beginList
    consume_eols
    local_declaration
    while (consume(','))
      consume_eols
      local_declaration
    endWhile
  createList
  optional_type

  produce LocalDeclarations( declarations, type:Type )

- local_declaration
  on IDENTIFIER
    optional_initial_value
    createNull
    produce Local( name=content, initial_value, type:Type )
  endOn
  mustConsume IDENTIFIER  # throws error

- block
  on "block"
    multi_line_statements
    mustConsume "endBlock"
  endOn
  produce Block(statements):ControlStructure

#{
- loop
  on "loop"
    on EOL
      createNull # loop_count
      multi_line_statements
      mustConsume "endLoop"
    elseOnOthers
      expression
      if (consume(EOL)) multi_line_statements; mustConsume "endLoop"
      else              single_line_statements
    endOn
    produce Loop(loop_count,statements)
  endOn

- while_loop
  on "while"
    expression
    if (consume(EOL)) multi_line_statements; mustConsume "endWhile"
    else              single_line_statements
    produce While(condition,statements)
  endOn
}#

- try_catch
  on "try"
    multi_line_statements
    catches
    mustConsume "endTry"
    produce Try(statements,catches:Catches):ControlStructure
  endOn

- catches
  beginList
    while (nextIs("catch"))
      on "catch"
        if (consume('('))
          catch_clause
          mustConsume ')'
        else
          catch_clause
        endIf
        multi_line_statements
        create Catch(var_name:String,exception_type:Type,statements):ControlStructure
      endOn
    endWhile
  produceList Catches

- catch_clause
  savePosition
  identifier
  if (consume(':'))
    discardPosition
    type
  else
    restorePosition
    createNull
    type
  endIf

- module_path
  beginList
    identifier
    while (consume('/'))
      identifier
    endWhile
  produceList

- uses_attributes
  beginList
    on '['
      while (hasAnother and not nextIs(']'))
        uses_attribute
        consume ','
      endWhile
      mustConsume(']')
    endOn
  produceList Attributes

- uses_attribute
  on "export"    -> AttributeExport
  if (consume @"noInclude")
    call uses_attribute_no_include
    return
  endIf
  syntaxError "Illegal 'uses' attribute. Expected any of [export noInclude]."

#- import_module_by_path_or_filepath
#  on STRING
#    produce ImportModuleByFilepath(filepath=content)
#  endOn
#
#  beginList
#    identifier
#    while (consume('/'))
#      identifier
#    endWhile
#  createList
#
#  produce ImportModuleByPath(segments)

- access_args
  if (not nextIs('(')) produceNull
  args

- optional_expression
  if (nextIs(EOL) or nextIs(';')) produceNull
  expression

- expression
  op_and_assign

- op_and_assign
  on "+=" expression -> AddAndAssign(target,operand):OpAndAssign
#{
  #on "-=", expression -> SubtractAndAssign(target,operand):OpAndAssign
  #on "*=", expression -> MultiplyAndAssign(target,operand):OpAndAssign
  #on "/=", expression -> DivideAndAssign(target,operand):OpAndAssign
  #on "%=", expression -> ModAndAssign(target,operand):OpAndAssign
  #on "&=", expression -> BitwiseAndAndAssign(target,operand):OpAndAssign
  on "|=", expression -> BitwiseOrAndAssign(target,operand):OpAndAssign
  on ":<<:="  expression -> LeftShiftAndAssign(target,operand):OpAndAssign
  on ":>>:="  expression -> RightShiftAndAssign(target,operand):OpAndAssign
  on ":>>>:=" expression -> RightShiftXAndAssign(target,operand):OpAndAssign
}#
  logical_xor

- logical_xor [binary]
  on "xor" -> LogicalXor

- logical_or [binary]
  on "or" -> LogicalOr

- logical_and [binary]
  on "and" -> LogicalAnd

- comparison [binary]
  on "==" -> CompareEQ
  on "!=" -> CompareNE
  on "<"  -> CompareLT
  on ">"  -> CompareGT
  on "<=" -> CompareLE
  on ">=" -> CompareGE

- reference_comparison
  bitwise_xor
  on "is"
    if (consume("not"))
      reference_comparison
      produce IsNot(left,right):Binary
    else
      reference_comparison
      produce Is(left,right):Binary
    endIf
  endOn

- bitwise_xor [binary]
  on '~' -> BitwiseXor

- bitwise_or  [binary]
  on '|' -> BitwiseOr

- bitwise_and [binary]
  on '&' -> BitwiseAnd

- bitwise_shift [binary]
  on ":<<:"  -> LeftShift
  on ":>>:"  -> RightShift
  on ":>>>:" -> RightShiftX

- add_subtract [binary]
  on "+" -> Add
  on "-" -> Subtract

- multiply_divide_mod [binary]
  on "*" -> Multiply
  on "/" -> Divide
  on "%" -> Mod

- power [binary]
  on "^" -> Power

- pre_unary [preUnary]
  on "!"   -> BitwiseNot
  on "not" -> LogicalNot
  on "-"   -> Negate
  on "++"  -> Preincrement
  on "--"  -> Predecrement

- post_unary [postUnary]
  on "++"  -> Postincrement
  on "--"  -> Postdecrement

- access
  term
  access_inner

- access_inner
  on '.'
    identifier
    access_args
    create ContextAccess(context,name:String,args)
    access_inner
  elseOn "->"
    type
    create ConvertToType(operand,to_type:Type)
    access_inner
  elseOn '['
    expression
    mustConsume(']')
    create IndexAccess(context,index)
    access_inner
  endOn

- term
  on STRING         -> LiteralString(value=content):Literal
  on INTEGER        -> LiteralInteger(content=content:String,base="10":Integer)
  on HEX_INTEGER    -> LiteralInteger(content=content:String,base="16":Integer)
  on BINARY_INTEGER -> LiteralInteger(content=content:String,base="2":Integer)
  on OCTAL_INTEGER  -> LiteralInteger(content=content:String,base="8":Integer)
  on REAL_NUMBER    -> LiteralReal64(value=content:Real)
  on CHARACTER      -> LiteralCharacter(value=content:Character)
  onPeek IDENTIFIER
    id_or_type
    access_args
    produce Access( name:String, args )
  endOn
  on "true"               -> LiteralLogical(value="true":Logical)
  on "false"              -> LiteralLogical(value="false":Logical)
  on "null"               -> LiteralNull
  on "pi"                 -> LiteralPi
  on "this"               -> This
  onPeek "which" inline_which: return
  on '(', expression, ')':   return
#{
  onPeek "[" literal_list -> LiteralValueList(args)
  on "[]"                 -> EmptyList

  on "import"
    if (consume('('))
      string
      mustConsume ')'
    else
      string
    endIf
    produce ImportModule(filepath:String)
  endOn
}#
  on "native"
    native_code
    return
  endOn

  syntaxError

- native_code
  if consume("(")
    string
    mustConsume ")"
  else
    string
  endIf
  if consume("->")
    type
    produce NativeExpression(content:String,result_type)
  else
    produce NativeStatement(content:String)
  endIf


#{
- literal_list
  on '['
    beginList
    if (consume(']')) produceList  # Empty list
    consume_eols
    expression
    consume_eols
    while (not nextIs(']'))
      if (consume(',')) consume_eols
      expression
      consume_eols
    endWhile
    mustConsume( ']' )
    produceList Args
  endOn
}#

- preprocess
  while (hasAnother)
    process_another
  endWhile
  produceNull

- process_another
  on "$define"
    call mark_token
    on IDENTIFIER
      buffer = ""
      call collect_token_string
      while (hasAnother and not nextIs(EOL))
        call collect_next_token
      endWhile
      call create_definition
    elseOnOthers
      syntaxError "Identifier expected."
    endOn

  elseOn "$include"
    collect_meta_filepath
    call include_filepath
    return

  elseOn "uses"
    call rewrite_cur_token
    collect_meta_filepath
    savePosition
    uses_attributes
    restorePosition
    call uses_filepath
    return

  elseOn IDENTIFIER
    call insert_definition
    return

  endOn
  call rewrite_token

- collect_meta_filepath
  call mark_token
  buffer = ""
  on STRING
    call collect_token_string
  elseOnOthers
    while (hasAnother and not nextIs('[') and not nextIs(EOL))
      on IDENTIFIER:      call collect_token_string
      elseOn INTEGER:     call collect_token_string
      elseOn REAL_NUMBER: call collect_token_string
      elseOn '~':         call collect_token_string
      elseOn '/':         call collect_token_string
      elseOn ':':         call collect_token_string
      elseOn '.':         call collect_token_string
      elseOn '\\':        call collect_token_string
      elseOnOthers:       syntaxError "Unsupported filepath character. Put the filepath in quotes."
    endWhile
  endOn

- additional_node_types
  create AddAndAssignLocal(info:Local,operand)
  create Convert(operand)
  create ConvertToByte(operand):Convert
  create ConvertToCharacter(operand):Convert
  create ConvertToInt32(operand):Convert
  create ConvertToInt64(operand):Convert
  create ConvertToLogical(operand):Convert
  create ConvertToReal32(operand):Convert
  create ConvertToReal64(operand):Convert
  create CallDynamicMethod(context,args):CallProcedure
  create CallGlobalMethod(args):CallProcedure
  create CallProcedure(args)
  create CallRoutine(args):CallProcedure
  create CallStaticMethod(context,args):CallProcedure
  create CallThisDynamicMethod(args):CallProcedure
  create CallThisStaticMethod(args):CallProcedure
  create Compare(left,right):Binary
  create Conditional(condition,statements):ControlStructure
  create ControlStructure(initialization,statements)
  create CreateObject(of_type:Type,info:Local)
  create DummyInitialValue
  create ForEachControl(name:String,optional_at:ForEachAt,collection:ForEachCollection)
  create Iterator(control,condition,statements,upkeep):Conditional
  create GetLocal(info:Local)
  create GetProperty(context,info:Property)
  create GetThisProperty(info:Property)
  create GetSingleton(type:Type)
  create Literal
  create LiteralInt32(value:Integer):LiteralInteger
  create LiteralInt64(value:Integer):LiteralInteger
  create LocalScope:ControlStructure
  create NativeProperty( expression:String )
  create OpAndAssign(target,operand)
  create PrintCharacter(operand):PrintValue
  create PrintInt32(operand):PrintValue
  create PrintInt64(operand):PrintValue
  create PrintLogical(operand):PrintValue
  create PrintNewline
  create PrintReal64(operand):PrintValue
  create PrintString(operand):PrintValue
  create PrintValue(operand)
  create Procedure(name:String,parameters:Parameters,return_type:Type,attributes:Attributes,body:LocalScope)
  create Range(left,right):Binary
  create ReturnOnException
  create SetLocal(info:Local,new_value)
  create SetProperty(context,info:Property,new_value)
  create SetThisProperty(info:Property,new_value)
  create Stepper(operand)
  create TypeContext(type:Type)
  create CreateObject(of_type:Type,args)

--------------------------------------------------------------------------------
nativeTypes
--------------------------------------------------------------------------------
