module Rogue

class Finalizer : Visitor
  METHODS
    method apply
      # Remove special aspects that implement augments
      forEach (m in Program.modules)
        forEach (type in m.types)
          if (type.aspects)
            type.aspects.discard( $.attributes.is_augment )
          endIf
        endForEach
      endForEach

      BuildDynamicMethodTable().apply
      CullUnusedElements().apply
      Program.dynamic_methods.clear
      BuildDynamicMethodTable().apply  # Rebuild using new, slimmer program
      forEach (method_group in Program.dynamic_methods)
        if (method_group.count > 1)
          (forEach in method_group).attributes.dynamic_dispatch = true
        endIf
      endForEach

      Program.apply( AssignIDs() )
      Program.apply( this )

    method on_visit( cmd:CallDynamicMethod )
      ensure_dynamic_dispatch( cmd.info->(as Method) )
      visit_children( cmd )

    method on_visit( cmd:CallThisDynamicMethod )
      ensure_dynamic_dispatch( cmd.info->(as Method) )
      visit_children( cmd )

    method ensure_dynamic_dispatch( m:Method )
      if (m.type_context.is_aspect or m.attributes.is_abstract)
        if (not Program.dynamic_methods.contains(m.dynamic_signature))
          m.attributes.dynamic_dispatch = true
          m.attributes.is_placeholder = true
          Program.dynamic_methods[m.dynamic_signature] = Method[][m]
        endIf
      endIf

    method on( cmd:GetProperty )->Cmd
      if (cmd.info.type_context.is_enum)
        if (cmd.info.name == "value")
          local create_compound = cmd.context->(as CreateCompound)
          if (create_compound)
            return create_compound.args.first
          endIf
        endIf
      endIf
      return cmd

    method on_visit( cmd:GenericFunctionDefinition )
      throw cmd.t.error( "Generic functions must be passed as an argument or assigned to a variable with specialized Function type." )

    method on_visit_type( type:Type )
      type.base_type_lookup_index = Program.base_type_lookup.count
      if (type.base_class)
        type.base_type_ids.add( type.base_class.id )
      endIf
      if (type.aspects)
        type.base_type_ids.add( (forEach in type.aspects).id )
      endIf
      Program.base_type_lookup.add( forEach in type.base_type_ids )

      prior.on_visit_type( type )

    method on_visit( m:Method )
      if (this_type.is_reference)
        if (m.type_context is this_type)
          if (this_type.base_class)
            local base_m = this_type.base_class.methods[ m.signature ]
            if (base_m) base_m.attributes.is_overridden = true
          endIf
        else
          assert (not m.inheriting_types.contains(this_type))
          m.inheriting_types.add( this_type )
        endIf
      endIf
      visit_children( m )

    method on_visit( p:Property )
      p.initial_value = null

    method on_visit( cmd:TypeContext )
      throw cmd.t.error( "Unused type context." )

endClass
