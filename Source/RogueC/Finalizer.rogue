module Rogue

class Finalizer : Visitor
  METHODS
    method apply
      # Remove special aspects that implement augments
      forEach (m in Program.modules)
        forEach (type in m.types)
          if (type.aspects)
            type.aspects.discard( $.attributes.is_augment )
          endIf
        endForEach
      endForEach

      Program.apply( AssignIDs() )
      Program.apply( this )

      forEach (method_group in Program.dynamic_methods)
        # Remove aspect methods and abstract methods, keeping at least one
        # of them if there are no concrete methods.
        local first = method_group.first
        forEach (m in writer=method_group.rewriter)
          if (not (m.type_context.is_aspect or m.attributes.is_abstract))
            writer.write( m )
          endIf
        endForEach
        if (method_group.is_empty)
          first.attributes.is_placeholder = true
          method_group.add( first )
        endIf

        if (method_group.count > 1)
          (forEach in method_group).attributes.dynamic_dispatch = true
        endIf
      endForEach

    method on( cmd:GetProperty )->Cmd
      if (cmd.info.type_context.is_enum)
        if (cmd.info.name == "value")
          local create_compound = cmd.context->(as CreateCompound)
          if (create_compound)
            return create_compound.args.first
          endIf
        endIf
      endIf
      return cmd

    method on_visit( cmd:GenericFunctionDefinition )
      throw cmd.t.error( "Generic functions must be passed as an argument or assigned to a variable with specialized Function type." )

    method on_visit_type( type:Type )
      type.base_type_lookup_index = Program.base_type_lookup.count
      if (type.base_class)
        type.base_type_ids.add( type.base_class.id )
      endIf
      if (type.aspects)
        type.base_type_ids.add( (forEach in type.aspects).id )
      endIf
      Program.base_type_lookup.add( forEach in type.base_type_ids )

      if (type.is_aspect) return
      prior.on_visit_type( type )

    method on_visit( m:Method )
      #if (m.type_context.is_aspect or m.attributes.is_abstract) return
      if (this_type.is_reference)
        if (m.type_context is this_type)
          if (this_type.base_class)
            local base_m = this_type.base_class.methods[ m.signature ]
            if (base_m) base_m.attributes.is_overridden = true
          endIf

          local full_sig = m.full_signature
          local methods = Program.dynamic_methods[full_sig]
          if (not methods)
            methods = Method[]
            Program.dynamic_methods[full_sig] = methods
          endIf
          methods.add( m )
        else
          assert (not m.inheriting_types.contains(this_type))
          m.inheriting_types.add( this_type )
        endIf
      endIf
      visit_children( m )

    method on_visit( p:Property )
      p.initial_value = null

    method on_visit( cmd:TypeContext )
      throw cmd.t.error( "Unused type context." )

endClass
