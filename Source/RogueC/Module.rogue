module Rogue

class Module
  PROPERTIES
    t    : Token
    name : String

    used_modules      = UsedModule[]
    implicit_context  = Type[]
    global_statements : Statements
    templates         = StringTable<<Template>>()
    augments          = StringTable<<String[]>>()
    next_augment_id   = 0

    types             = StringTable<<Type>>()
    m_on_launch       : GlobalMethod

    attributes        : Attributes

    native_headers = String[]
    native_code    = String[]

    is_organized   : Logical

  METHODS
    method init( t, name )
      attributes = Attributes(t)
      Program.modules[ name ] = this
      ensure global_statements(t)

      if (name != "Rogue")
        uses_module( Program.default_module )
      endIf

      # Each module gets a Routine class to store routines as GLOBAL METHODS.
      local tokens = Token[]
      tokens.add( t.cloned(TokenType.EOL) )
      tokens.add( t.cloned(TokenType.KEYWORD_END_CLASS) )
      local new_template = Template( t, this, "Routine", &placeholders=Token[], tokens, 0 )
      templates["Routine<<0>>"] = new_template

    method collect_used_modules
      # Ensure we have a flat list of all modules we should search for types in.
      temporarily attributes.is_visiting = true
        forEach (used_m in used_modules)
          used_m.m.collect_exported_modules( this )
        endForEach
      endTemporarily

      (forEach in used_modules).m.attributes.is_collected = false

      # Every module has type Rogue::Global as an implicit context.
      implicit_context.add( Program.type_Global )

      # Add each class ModuleName::Routine to list of implicit contexts if it exists.
      # Each routine is converted in to a global method of its module's Routine class.
      local type_Routine = Type( t, Program.default_module, "Routine" )
      implicit_context.add( type_Routine )
      forEach (used_m in used_modules)
        type_Routine = Type( t, used_m.m, "Routine" )
        implicit_context.add( type_Routine )
      endForEach

    method collect_exported_modules( target:Module )
      if (attributes.is_visiting or attributes.is_collected) return
      attributes.is_collected = true

      temporarily attributes.is_visiting = true
        forEach (used_m in used_modules)
          if (used_m.is_exported)
            target.uses_module( used_m.m )
            used_m.m.collect_exported_modules( target )
          endIf
        endForEach
      endTemporarily

    method description->String
      return name

    method find_template( name:String, &extended_search )->Template
      local result = templates[ name ]
      if (result) return result

      if (extended_search)
        forEach (used_m in used_modules)
          result = used_m.m.find_template( name )
          if (result) escapeForEach
        endForEach
      endIf

      return result

    method must_find_template( t:Token, template_name:String, type_name:String, &extended_search )->Template
      local result = find_template( template_name, &=extended_search )
      if (result) return result
      throw t.error( "Reference to undefined class '$::$'."(this,type_name) )

    method find_type( name:String, &extended_search )->Type
      local result = types[ name ]
      if (result) return result

      if (extended_search)
        forEach (used_m in used_modules)
          result = used_m.m.find_type( name )
          if (result) return result
        endForEach
      endIf

      # Handle non-parameterized templates here by checking for a match with <<0>> template parameters.
      if (not name.ends_with('>'))  # avoid wasted effort for most type names
        local template = find_template( name+"<<0>>", &=extended_search )
        if (template)
          return Type( template.t, template, name )
        endIf
      endIf

      return null

    method must_find_type( t:Token, name:String, &extended_search )->Type
      local result = find_type( name, &=extended_search )
      if (result) return result
      throw t.error( "Reference to undefined class '$::$'."(this,name) )

    method instantiate_essential_and_api_types
      if (attributes.is_essential or attributes.is_api)
        # Instantiate one of each template with 0 type parameters
        temporarily Program.current_module = this
          forEach (templ in templates)
            if (templ.placeholders.count == 0)
              if (not types.contains(templ.name))
                  Type( templ.t, templ.name )
              endIf
            endIf
          endForEach
        endTemporarily
      endIf

      if (attributes.is_essential)
        (forEach in types).attributes.is_essential = true
      endIf
      if (attributes.is_api)
        (forEach in types).attributes.is_api = true
      endIf

    method organize_methods
      if (is_organized) return
      is_organized = true

      # Instantiate any essential templates
      forEach (t in templates)
        if (t.attributes.is_essential)
          Type( t.tokens.first, t.name )
        endIf
      endForEach

      # Add global statements to Routine.on_launch()
      local type_Routine = Type( t, Program.default_module, "Routine" )
      local r = type_Routine.global_methods[ "on_launch()" ]
      if (not r)
        r = GlobalMethod( t, type_Routine, "on_launch" )
        r.statements.add( forEach in global_statements )
        r.organize
        type_Routine.global_methods[ r.signature ] = r
      else
        r.statements.add( forEach in global_statements )
      endIf
      m_on_launch = r

    method to->String
      return name

    method uses_module( m:Module, &is_exported )
      if (m is this) return
      # happens when this is the default module because all modules implicitly "use" default module

      forEach (existing_m in used_modules)
        if (existing_m.m is m) return # already added
      endForEach

      used_modules.add( UsedModule(m,&=is_exported) )

endClass

class UsedModule( m:Module, is_exported:Logical ) [compound]
  METHODS
    method to->String
      return m.name
endClass

