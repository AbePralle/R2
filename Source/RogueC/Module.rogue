module Rogue

class Module
  ROGUE_ATTRIBUTE( is_visiting, 1 )
  ROGUE_ATTRIBUTE( is_collecting_routines,  2 )

  PROPERTIES
    t    : Token
    name : String

    used_modules      = UsedModule[]
    types             = StringTable<<Type>>()
    global_statements : Statements
    routines          = StringTable<<Routine>>()
    templates         = StringTable<<Template>>()

    attributes : Int32

    native_headers = String[]
    native_code    = String[]

  METHODS
    method init( t, name )
      Program.modules[ name ] = this
      ensure global_statements(t)

      #{
    method add_routine( r:Routine )
      ensure routines_by_name[ r.name ]
      routines_by_name[ r.name ].add( r )

    method collect_global_statements( statements:Cmd )
      statements.add( forEach in global_statements )
      global_statements.clear
      }#

    method collect_routines( r_name:String, list:Procedure[], &is_limited )
      if (is_collecting_routines) return
      forEach (r in routines)
        if (r.name == r_name) list.add( r )
      endForEach

      temporarily is_collecting_routines = true
        forEach (used_m in used_modules)
          if (not is_limited or used_m.is_exported)
            used_m.m.collect_routines( r_name, list, &is_limited )
          endIf
        endForEach
      endTemporarily

    method collect_used_modules
      # Ensure we have a flat list of all modules we should search for types in.
      temporarily is_visiting = true
        forEach (used_m in used_modules)
          if (used_m.is_exported) used_m.m.collect_used_modules( this )
        endForEach
      endTemporarily

    method collect_used_modules( target:Module )
      if (is_visiting) return

      temporarily is_visiting = true
        forEach (used_m in used_modules)
          if (used_m.is_exported)
            target.uses_module( used_m.m )
            used_m.m.collect_used_modules( target )
          endIf
        endForEach
      endTemporarily

    method description->String
      return name

      #{
    method find_routine( name:String, parameter_count:Int32 )->Routine
      local routines = routines_by_name[ name ]
      if (not name) return null
      forEach (r in routines)
        if (r.parameters.count == parameter_count) return r
      endForEach
      return null
      }#

    method find_type( name:String, &extended_search )->Type
      local result = types[ name ]
      if (result) return result

      local template = templates[ "$<<0>>"(name) ]
      if (template)
        local type = Type( template.tokens.first, this, name, Type.OBJECT )
        template.generate( null, type )
        return type
      endIf

      if (extended_search)
        forEach (used_m in used_modules)
          result = used_m.m.find_type( name )
          if (result) escapeForEach
        endForEach
      endIf

      return result

      #{
    method must_find_type( t:Token, name:String )->Type
      local result = find_type( name )
      if (result) return result
      throw t.error( "No such type '$'." (name) )
      }#

    method organize
      local r = routines[ "on_launch()" ]
      if (not r)
        r = Routine( t, this, "on_launch" )
        r.organize
        routines[ r.signature ] = r
      endIf
      r.statements.add( forEach in global_statements )

      #local organizer = Organizer( this )
      #organizer.visit( forEach in types )
      #organizer.visit( null, forEach in (forEach in routines_by_name) )

    method resolve
      local resolver = Resolver( this )
      #resolver.visit( forEach in types )
      resolver.visit( null, forEach in routines )

      #{
    method type( name:String )->Type
      local result = find_type( name )
      if (result) return result
      return Type( t, name )
      }#

    method uses_module( m:Module, &is_exported )
      if (m is this) return
      # happens when this is the default module because all modules implicitly "use" default module

      forEach (existing_m in used_modules)
        if (existing_m.m is m) return # already added
      endForEach

      used_modules.add( UsedModule(m,&=is_exported) )

endClass

class UsedModule( m:Module, is_exported:Logical ) [compound]
endClass

