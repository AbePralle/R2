module Rogue

class Module
  PROPERTIES
    t    : Token
    name : String

    used_modules      = UsedModule[]
    global_statements : Statements
    templates         = StringTable<<Template>>()
    types             = StringTable<<Type>>()
    routines          = StringTable<<Routine>>()

    attributes        : Attributes

    native_headers = String[]
    native_code    = String[]

  METHODS
    method init( t, name )
      attributes = Attributes(t)
      Program.modules[ name ] = this
      ensure global_statements(t)

    method add( r:Routine )
      routines[ r.signature ] = r

    method collect_routines( r_name:String, list:Procedure[], &is_limited )
      if (attributes.is_visiting) return

      organize

      forEach (r in routines)
        if (r.name == r_name) list.add( r )
      endForEach

      temporarily attributes.is_visiting = true
        forEach (used_m in used_modules)
          if (not is_limited or used_m.is_exported)
            used_m.m.collect_routines( r_name, list, &is_limited )
          endIf
        endForEach
      endTemporarily

    method collect_used_modules
      # Ensure we have a flat list of all modules we should search for types in.
      temporarily attributes.is_visiting = true
        forEach (used_m in used_modules)
          if (used_m.is_exported) used_m.m.collect_used_modules( this )
        endForEach
      endTemporarily

    method collect_used_modules( target:Module )
      if (attributes.is_visiting) return

      temporarily attributes.is_visiting = true
        forEach (used_m in used_modules)
          if (used_m.is_exported)
            target.uses_module( used_m.m )
            used_m.m.collect_used_modules( target )
          endIf
        endForEach
      endTemporarily

    method description->String
      return name

    method find_type( name:String, &extended_search )->Type
      local result = types[ name ]
      if (result) return result

      local template = templates[ "$<<0>>"(name) ]
      if (template)
        local type = Type( template.tokens.first, this, name, 0 )
        template.generate( type )
        return type
      endIf

      if (extended_search)
        forEach (used_m in used_modules)
          result = used_m.m.find_type( name )
          if (result) escapeForEach
        endForEach
      endIf

      return result

    method organize
      if (attributes.is_organized) return
      attributes.is_organized = true

      # Instantiate any essential templates
      forEach (t in templates)
        if (t.attributes.is_essential)
          Type( t.tokens.first, t.name )
        endIf
      endForEach

      local r = routines[ "on_launch()" ]
      if (not r)
        r = Routine( t, this, "on_launch" )
        r.organize
        routines[ r.signature ] = r
      endIf
      r.statements.add( forEach in global_statements )

    method uses_module( m:Module, &is_exported )
      if (m is this) return
      # happens when this is the default module because all modules implicitly "use" default module

      forEach (existing_m in used_modules)
        if (existing_m.m is m) return # already added
      endForEach

      used_modules.add( UsedModule(m,&=is_exported) )

endClass

class UsedModule( m:Module, is_exported:Logical ) [compound]
endClass

