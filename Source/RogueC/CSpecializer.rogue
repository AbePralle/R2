module Rogue

class CSpecializer : Visitor
  PROPERTIES
    writer         : CWriter
    autoname_index = 0

    current_statements : ListRewriter<<Cmd>>
    insert_in_init     : Logical
    control_stack      = ControlStructure[]

  METHODS
    method add_local( t:Token, base:String, type:Type )->Local
      local v = Local( t, autoname(base), null, type )
      v.c_name = "$_$" (v.name,this_procedure.locals.count)
      this_procedure.locals.add( v )
      assert control_stack.count
      control_stack.last.locals.add( v )
      return v

    method autoname( base:String )->String
      local result = "_auto_$_$"(base,autoname_index)
      ++autoname_index
      return result

    method insert( cmd:Cmd )
      if (insert_in_init)
        control_stack.last.initialization.add( cmd )
      else
        current_statements.write( cmd )
      endIf

    method on( cmd:ControlStructure )->Cmd
      control_stack.add( cmd )
      visit_content( cmd )
      control_stack.remove_last
      return cmd

    method on_visit( cmd:If )
      control_stack.add( cmd )
      temporarily insert_in_init = true
        cmd.condition = visit( cmd.condition )
      endTemporarily
      cmd.statements = visit( cmd.statements )
      control_stack.remove_last

    method on_visit( cmd:LiteralString )
      local str = cmd.value
      if (not Program.unique_strings.contains(str))
        use builder = StringBuilder.pool
          builder.print( "str_" )
          forEach (i in 0..<str.count.or_smaller(20))
            local ch = str[i]
            if (ch.is_letter or ch.is_number) builder.print( ch )
            else builder.print( '_' )
          endForEach
          local c_name = builder->String
          if (Program.c_name_strings.contains(c_name))
            local n = 1
            while (Program.c_name_strings.contains(c_name))
              local c_name_2 = c_name + "_" + n
              if (not Program.c_name_strings.contains(c_name_2))
                c_name = c_name_2
                escapeWhile
              endIf
              ++n
            endWhile
          endIf
          Program.unique_strings[ str ] = c_name;
          Program.c_name_strings[ c_name ] = str;
        endUse
      endIf

    method on( cmd:LogicalAnd )->Cmd
      if (cmd.left.needs_decomposition or cmd.right.needs_decomposition)
        local t = cmd.t
        local v = add_local( t, "and", cmd.left.type )
        cmd.left = visit( cmd.left )
        insert( SetLocal(t,v,cmd.left) )
        local statements = LocalScope( t, Statements(t,SetLocal(t,v,cmd.right)) )
        insert( visit( If(t, GetLocal(t,v), statements, null) ) )
        return GetLocal(t,v)
      endIf
      return cmd

    method on( cmd:LogicalOr )->Cmd
      if (cmd.left.needs_decomposition or cmd.right.needs_decomposition)
        local t = cmd.t
        local v = add_local( t, "or", cmd.left.type )
        cmd.left = visit( cmd.left )
        insert( SetLocal(t,v,cmd.left) )
        local statements = LocalScope( t, Statements(t,SetLocal(t,v,cmd.right)) )
        insert( visit( If(t, LogicalNot(t,GetLocal(t,v)), statements, null) ) )
        return GetLocal(t,v)
      endIf
      return cmd

    method on_visit( cmd:Procedure )
      autoname_index = 0

      cmd.c_result_name = "_auto_result"

      forEach (p at i in cmd.parameters)
        block p = p->(as Local)
          p.c_name = "$_$" (p.name,i)
        endBlock
      endForEach

      local di = cmd.parameters.count
      forEach (v at i in cmd.locals) v.c_name = "$_$"(v.name,i+di)

      visit_children( cmd )

    method on_visit( cmd:Statements )
      temporarily current_statements = cmd.list.rewriter
        forEach (statement in current_statements)
          statement = visit( statement )
          if (statement) current_statements.write( statement )
        endForEach
      endTemporarily

endClass

augment ControlStructure
  PROPERTIES
    c_escape_label_name : String

  METHODS
    method c_escape_label_name( cgen:CGenerator )->String
      if (not @c_escape_label_name)
        @c_escape_label_name = cgen.autoname("escape")
      endIf
      return @c_escape_label_name

    method has_cleanup_code->Logical
      forEach (v in locals)
        if (v.type.is_reference)
          return true
        endIf
      endForEach
      return false
endAugment

augment Local
  PROPERTIES
    c_name : String
endAugment

augment Procedure
  PROPERTIES
    c_name        : String
    c_result_name : String

  METHODS
    method c_name->String
      throw UnsupportedOperationError()

    method has_cleanup_code->Logical
      forEach (p in parameters)
        if (p.type.is_reference and not p.is_anchored)
          return true
        endIf
      endForEach

      return body.has_cleanup_code
endAugment

augment Program
  PROPERTIES
    c_name_strings = StringTable<<String>>()
endAugment

augment Type
  PROPERTIES
    c_name : String   # e.g. RogueString
    c_type : String   # e.g. RogueString*

  METHODS
    method c_type->String
      if (@c_type) return @c_type
      @c_type = c_name
      if (is_reference) @c_type += "*"
      return @c_type

    method c_name->String
      if (@c_name) return @c_name
      @c_name = "$$" (module_context.c_name,name)
      return @c_name

endAugment

augment
  METHODS
    method GlobalMethod.c_name->String
      if (@c_name) return @c_name
      use builder = StringBuilder.pool
        builder.print( type_context.c_name ).print( "__" )
        builder.print( name )
        if (parameters.count)
          builder.print '_'
          forEach (p in parameters)
            builder.print( "_" ).print( p.type.c_name )
          endForEach
        endIf
        c_name = builder
        return @c_name
      endUse

    method Method.c_name->String
      if (@c_name) return @c_name
      use builder = StringBuilder.pool
        builder.print( type_context.c_name ).print( "__" )
        builder.print( name )
        if (parameters.count)
          builder.print '_'
          forEach (p in parameters)
            builder.print( "_" ).print( p.type.c_name )
          endForEach
        endIf
        c_name = builder
        return @c_name
      endUse

    method Module.c_name->String
      return name

    method Property.c_name->String
      return name

    method Routine.c_name->String
      if (@c_name) return @c_name
      use builder = StringBuilder.pool
        builder.print( module_context.c_name ).print( "___" )
        builder.print( name )
        if (parameters.count)
          builder.print "_"
          forEach (p in parameters)
            builder.print( "_" ).print( p.type.c_name )
          endForEach
        endIf
        c_name = builder
        return @c_name
      endUse

endAugment

