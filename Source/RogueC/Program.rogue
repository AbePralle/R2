module Rogue

class Program [singleton]
  PROPERTIES
    t                    = Token( TokenType.EOI, "R2" )
    include_search_paths = String[]
    included_files       = StringTable<<Token[]>>()
    definitions          = StringTable<<Token[]>>()

    modules        = StringTable<<Module>>()
    default_module : Module
    current_module : Module

    type_Logical   : Type
    type_Byte      : Type
    type_Character : Type
    type_Int32     : Type
    type_Int64     : Type
    type_Real32    : Type
    type_Real64    : Type

    type_null      : Type
    type_Object    : Type
    type_String    : Type

    unique_strings = StringTable<<String>>()
    c_name_strings = StringTable<<String>>()

  METHODS
    method init
      Program = this  # update singleton reference
      default_module = get_module( t, "Rogue" )
      current_module = default_module

      type_Logical   = TypeLogical( t )
      type_Byte      = TypeByte( t )
      type_Character = TypeCharacter( t )
      type_Int32     = TypeInt32( t )
      type_Int64     = TypeInt64( t )
      type_Real32    = TypeReal32( t )
      type_Real64    = TypeReal64( t )

      type_null      = Type( t, "null", Type.OBJECT, &unlisted )
      type_Object    = Type( t, "Object", Type.OBJECT )
      type_String    = TypeString( t )

    method add_include_search_path( path:String )
      if (not include_search_paths.contains(path))
        include_search_paths.add( path )
      endIf

    method apply( visitor:Visitor )
      forEach (m in modules.values)
        temporarily visitor.this_module = m
          visitor.visit( m )
        endTemporarily
      endForEach

    method description->String
      return "Program"

    method get_module( t:Token, name:String )->Module
      local m = modules[ name ]
      if (m) return m

      m = Module( t, name )
      modules[ name ] = m
      return m

    method find_include( t:Token, filepath:String )->String
      if (File.exists(filepath))
        if (File.is_folder(filepath))
          local fpath = "$/$.rogue" (filepath,File.filename(filepath))
          if (File.exists(fpath)) return File.abs(fpath)
          throw t.error( "Use $includeFolder to include all Rogue files in '$'."('$',filepath) )
        else
          return File.abs(filepath)
        endIf
      elseIf (File.exists(filepath.with_trailing(".rogue")))
        filepath .= with_trailing( ".rogue" )
        return File.abs(filepath)
      else
        return null
      endIf

    method include( filepath:String )
      include( t, filepath )

    method include( t:Token, filepath:String, &is_optional )
      local found = find_include( t, filepath )
      if (not found)
        forEach (path in include_search_paths)
          found = find_include( t, path/filepath )
          if (found) escapeForEach
        endForEach
      endIf

      if (found)           filepath = found
      elseIf (is_optional) return
      else                 throw t.error( "Include not found: $"(filepath) )

      if (included_files.contains(filepath)) return
      included_files[ filepath ] = null # placeholder

      temporarily current_module = Program.default_module
        local tokens = Scanner( File(filepath) ).tokenize
        Parser( tokens ).preprocess
        included_files[filepath] = tokens

        # First parser pass collects class templates but does not build an AST
        Parser(tokens).[collecting_templates=true,disable_output=1].parse
      endTemporarily

    method resolve
      (forEach in modules).collect_used_modules

      # We've collected all class templates.
      (forEach in (forEach in modules).types).ensure_definition

      # Reparse the tokens for each file.
      forEach (file_tokens in included_files)
        temporarily current_module = Program.default_module
          local elements = Parser(file_tokens).parse
          if (elements)
            local collector = Collector()
            collector.visit( forEach in elements )
          endIf
        endTemporarily
      endForEach

      (forEach in modules).organize
      apply( Resolver() )
      apply( Finalizer() )

endClass
