module Rogue

class Program [singleton]
  PROPERTIES
    t                    = Token( TokenType.EOI, "R2" )
    include_search_paths = String[]
    included_files       = StringTable<<Token[]>>()
    definitions          = StringTable<<Token[]>>()

    real_bits       : Int32 # Set with --real=32 compile option
    using_arc       = true  # Automatic Reference Counting

    modules         = StringTable<<Module>>()
    default_module  : Module
    current_module  : Module

    type_Logical    : Type
    type_Byte       : Type
    type_Character  : Type
    type_Int32      : Type
    type_Int64      : Type
    type_Real32     : Type
    type_Real64     : Type
    type_Real       : Type

    type_null       : Type
    type_Global     : Type
    type_Math       : Type
    type_Object     : Type
    type_String     : Type
    type_Exception  : Type

    is_modified     : Logical

    unique_strings  = StringTable<<String>>()
    dynamic_methods = StringTable<<Method[]>>()

  METHODS
    method init
      Program = this  # update singleton reference
      default_module = get_module( t, "Rogue" )
      current_module = default_module

      type_Logical   = TypeLogical( t )
      type_Byte      = TypeByte( t )
      type_Character = TypeCharacter( t )
      type_Int32     = TypeInt32( t )
      type_Int64     = TypeInt64( t )
      type_Real32    = TypeReal32( t )
      type_Real64    = TypeReal64( t )
      real_bits      = 64  # default; calls set_real_bits

      type_null      = Type( t, "null", Attribute.OBJECT, &unlisted )
      type_Global    = Type( t, "Global", Attribute.OBJECT|Attribute.SINGLETON )
      type_Math      = Type( t, get_module(t,"Math"), "Math", Attribute.OBJECT )
      type_Object    = Type( t, "Object", Attribute.OBJECT )
      type_String    = TypeString( t )
      type_Exception = Type( t, "Exception", Attribute.OBJECT )

    method add_include_search_path( path:String )
      if (not include_search_paths.contains(path))
        include_search_paths.add( path )
      endIf

    method apply( visitor:InspectionVisitor )
      is_modified = true

      while (is_modified)
        is_modified = false

        forEach (m in modules)
          temporarily visitor.this_module = m
            visitor.visit( m )
          endTemporarily
        endForEach
      endWhile

    method apply( visitor:Visitor )
      is_modified = true

      while (is_modified)
        is_modified = false

        forEach (m in modules)
          temporarily visitor.this_module = m
            visitor.visit( m )
          endTemporarily
        endForEach
      endWhile

    method description->String
      return "Program"

    method get_module( t:Token, name:String )->Module
      local m = modules[ name ]
      if (m) return m

      m = Module( t, name )
      modules[ name ] = m
      return m

    method find_include( t:Token, filepath:String )->String
      if (File.exists(filepath))
        if (File.is_folder(filepath))
          local fpath = "$/$.rogue" (filepath,File.filename(filepath))
          if (File.exists(fpath)) return File.abs(fpath)
          throw t.error( "Use $includeFolder to include all Rogue files in '$'."('$',filepath) )
        else
          return File.abs(filepath)
        endIf
      elseIf (File.exists(filepath.with_trailing(".rogue")))
        filepath .= with_trailing( ".rogue" )
        return File.abs(filepath)
      else
        return null
      endIf

    method include( filepath:String )
      include( t, filepath )

    method include( t:Token, filepath:String, &is_optional )
      local found = find_include( t, filepath )
      if (not found)
        forEach (path in include_search_paths)
          found = find_include( t, path/filepath )
          if (found) escapeForEach
        endForEach
      endIf

      if (found)           filepath = found
      elseIf (is_optional) return
      else                 throw t.error( "Include not found: $"(filepath) )

      if (included_files.contains(filepath)) return
      included_files[ filepath ] = null # placeholder

      temporarily current_module = Program.default_module
        local tokens = Scanner( File(filepath) ).tokenize
        Parser( tokens ).preprocess
        included_files[filepath] = tokens

        # First parser pass collects class templates but does not build an AST
        Parser(tokens).[collecting_templates=true,disable_output=1].parse
      endTemporarily

    method resolve
      (forEach in modules.values).collect_used_modules

      # We've collected all class templates.
      (forEach in (forEach in modules.values).types).ensure_definition

      # Reparse the tokens for each file.
      forEach (file_tokens in included_files)
        temporarily current_module = Program.default_module
          local elements = Parser(file_tokens).parse
          if (elements)
            local collector = Collector()
            collector.visit( forEach in elements )
          endIf
        endTemporarily
      endForEach

      (forEach in modules).organize

      apply( Resolver() )
      Finalizer().apply

    method set_real_bits( @real_bits )
      definitions//Real = [t.cloned( TokenType.IDENTIFIER, "Real"+real_bits )]
      if (real_bits == 64) type_Real = type_Real64
      else                 type_Real = type_Real32

endClass
