module Rogue

class Template
  PROPERTIES
    t            : Token
    name         : String
    placeholders : Token[]
    tokens       = Token[]
    attributes   : Attributes

  METHODS
    method init( t, name, placeholders, tokens, attributes:Int32 )
      this.attributes = Attributes( t )
      this.attributes.flags = attributes

    method description->String
      return name

    method generate( type:Type )
      type.attributes.flags |= attributes.flags
      type.attributes.is_defined = true

      type._template = this
      local template_tokens = tokens

      local replacements = Template.replacements( placeholders, type.type_args )
      template_tokens = Template.make_replacements( template_tokens, replacements )

      Program.unorganized_types.add( type )
      local is_first_unorganized_type = (Program.unorganized_types.count == 1)
      type.class_def = Parser( template_tokens ).parse( Parser.ip_class )->(as Class)

      incorporate_augments( type, name, replacements )        # e.g. List
      if (type.name != name)
        incorporate_augments( type, type.name, replacements )   # e.g. Byte[]
      endIf

      if (is_first_unorganized_type) Program.organize_types
      Program.is_modified = true

    method incorporate_augments( type:Type, name:String, replacements:Table<<String,Token[]>> )
      local class_def = type.class_def->(as Class)
      assert class_def
      assert type.module_context

      local augments = type.module_context.augments[name]
      if (augments and augments.count)
        forEach (augment_name in augments)
          local augment_template = type.module_context.templates[augment_name]
          local augment_tokens = augment_template.tokens
          augment_tokens = Template.make_replacements( augment_tokens, replacements )

          local augment_type = Type( t, augment_name, augment_template.attributes.flags, null )
          class_def.base_types.add( augment_type )
          augment_type.attributes.is_defined = true
          Program.unorganized_types.add( augment_type )

          augment_type.class_def = Parser( augment_tokens ).parse( Parser.ip_class )
        endForEach
      endIf

  GLOBAL METHODS
    method make_replacements( tokens:Token[], replacements:Table<<String,Token[]>> )->Token[]
      if (not replacements) return tokens # unmodified

      local processed_tokens = Token[]( tokens.count * 1.1 )

      forEach (t in tokens)
        if (t.type == TokenType.PLACEHOLDER)
          local replacement = replacements[t.content]
          if (replacement)
            processed_tokens.add( forEach in replacement )
          else
            throw t.error( "Invalid template placeholder '$'."(t.content) )
          endIf
        else
          processed_tokens.add( t )
        endIf
      endForEach

      return processed_tokens

    method replacements( placeholders:Token[], type_args:TemplateArgs )->Table<<String,Token[]>>
      if (not type_args) return null
      assert placeholders.count == type_args.count

      local replacements = Table<<String,Token[]>>()
      forEach (placeholder at i in placeholders)
        replacements[placeholder] = type_args[i].tokens
      endForEach

      return replacements

endClass
