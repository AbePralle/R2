module Rogue
uses Utility/WorkList

# Generated by Froley. Will not be overwritten; customize as desired.
$include "ParserCore.rogue"

class Parser : ParserCore
  PROPERTIES
    processed_tokens      : Token[]
    marked_token          : Token
    token_buffer          = Token[]
    inserted_tokens       = Token[]
    id_start_stack        = Int32[]
    string_start_stack    = Int32[]
    collecting_templates  = false
    _attribute_no_include = false
    _attribute_essential  = false

    augment_t            : Token
    augment_context_name : String

  METHODS
    method preprocess
      processed_tokens = Token[]( _tokens.count * 1.2 )
      parse( ip_preprocess )
      _tokens.clear
      _tokens.add( processed_tokens )

    method set_augment_context_name
      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      augment_t = _tokens[i1]

      use builder = StringBuilder.pool
        local depth = 0
        forEach (t at i in _tokens.from(i1,i2))
          which (t.type)
            case TokenType.EOL
              if (depth > 0) throw t.error( "Expected '>>', found end of line." )
              escapeForEach
            case TokenType.SYMBOL_COLON
              if (depth > 0)
                escapeForEach
              endIf
            case TokenType.SYMBOL_LTLT
              ++depth
            case TokenType.SYMBOL_GTGT
              --depth
              if (depth < 0)  throw t.error( "Unexpected '>>'." )
              if (depth == 0)
                builder.print ">>"
                escapeForEach
              endIf
          endWhich
          builder.print t->String
        endForEach
        if (depth > 0) throw _tokens[i1].error( "Unterminated '<<'." )
        augment_context_name = builder
      endUse

    method batch_augment_create_method
      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      local name = augment_context_name
      local m = Program.current_module
      local base_name = name.before_first('<')
      if (base_name.contains(':'))
        local module_name = base_name.before_last( "::" )
        if (module_name == "") module_name = "Rogue"
        m = Program.get_module( augment_t, module_name )
        name .= after_last("::")
      endIf

      # Create a special aspect that will be incorporated into the designated class
      local aspect_name = "$-$-augment-$"(m.name,base_name,m.next_augment_id)
      ++m.next_augment_id

      if (not m.augments.contains(name)) m.augments[name] = String[]
      m.augments[name].add( aspect_name )

      # Wrap tokens:
      #     METHODS
      #       method <tokens>
      #   endClass
      tokens.insert( tokens.last.cloned(TokenType.KEYWORD_METHOD,null) )
      tokens.insert( tokens.last.cloned(TokenType.EOL,null) )
      tokens.insert( tokens.last.cloned(TokenType.KEYWORD_METHODS,null) )
      tokens.insert( tokens.last.cloned(TokenType.EOL,null) )
      tokens.add( tokens.last.cloned(TokenType.EOL,null) )
      tokens.add( tokens.last.cloned(TokenType.KEYWORD_END_CLASS,null) )
      tokens.add( tokens.last.cloned(TokenType.EOL,null) )

      m.templates[aspect_name] = Template( augment_t, m, aspect_name, Token[], tokens, Attribute.ASPECT|Attribute.AUGMENT )

    method begin_join_ids
      id_start_stack.add( processed_tokens.count )

    method end_join_ids
      local i1 = id_start_stack.remove_last
      if (i1 >= processed_tokens.count) return

      local t = processed_tokens[i1]
      if (t.type != TokenType.IDENTIFIER) t .= cloned( TokenType.IDENTIFIER, t->String )
      forEach (i in i1+1..<processed_tokens.count)
        t.content += processed_tokens[i]->String
      endForEach
      processed_tokens.discard_from( i1 )
      processed_tokens.add( t )

    method begin_join_strings
      string_start_stack.add( processed_tokens.count )

    method end_join_strings
      local i1 = string_start_stack.remove_last
      if (i1 >= processed_tokens.count) return

      local t = processed_tokens[i1]
      if (t.type != TokenType.STRING) t .= cloned( TokenType.STRING, t->String )
      forEach (i in i1+1..<processed_tokens.count)
        t.content += processed_tokens[i]->String
      endForEach
      processed_tokens.discard_from( i1 )
      processed_tokens.add( t )

    method define_macro
      assert _cmd_stack.count >= 3
      local tokens = _cmd_stack.remove_last->(as TokenList).tokens
      local placeholders = _cmd_stack.remove_last->(as Identifiers)
      local id_node = _cmd_stack.remove_last

      local macros = Program.macros[id_node->String]
      if (not macros)
        macros = Macro[]
        Program.macros[id_node->String] = macros
      endIf

      forEach (m in macros)
        if (m.placeholders.count == placeholders.count)
          throw m.t.error( "A definition of macro $($) already exists."(id_node->String,placeholders.count) )
        endIf
      endForEach

      macros.add( Macro(id_node.t,id_node->String,placeholders,tokens) )

    method class_attribute_essential
      _attribute_essential = true

    method create_definition
      local def_name = buffer->String
      Program.definitions[ def_name ] = token_buffer
      use history = WorkList<<String>>
        detect_definition_cycle( history, def_name, token_buffer )
      endUse
      token_buffer = Token[]

    method collect_next_token
      token_buffer.add( _read )

    method collect_token_string
      buffer.print _cur_t->String

    method detect_definition_cycle( history:String[], name:String, tokens:Token[] )
      if (history.contains(name))
        throw marked_token.error( "Definition of '$' results in an infinite cycle."(name) )
      endIf

      history.add( name )
      forEach (t in tokens)
        if (t.type == TokenType.IDENTIFIER)
          local entry = Program.definitions.find( t->String )
          if (entry)
            detect_definition_cycle( history, entry.key, entry.value )
          endIf
        endIf
      endForEach
      history.remove_last

    method insert_definition
      local def = Program.definitions[ _cur_t->String ]
      if (def)
        if (def.count > 0)
          --_position
          _tokens.shift( _position, &delta=def.count-1 )
          forEach (t at i in def)
            _tokens[_position+i] = t
          endForEach
          _limit += def.count - 1
          if (_position < _limit) _next_t = _tokens[_position]
        endIf
        return
      endIf

      if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
        local macros = Program.macros[ _cur_t->String ]
        if (macros)
          _save_position
          _execute( ip_macro_args )
          local args = _cmd_stack.remove_last
          forEach (m in macros)
            if (m.placeholders.count == args.count)
              _discard_position

              # Expand macro here
              local replacements = StringTable<<Token[]>>()
              forEach (placeholder at i in m.placeholders)
                replacements[placeholder->String] = args[i]->(as TokenList).tokens
              endForEach

              use expanded_tokens = WorkList<<Token>>
                forEach (t in m.tokens)
                  if (t.type == TokenType.IDENTIFIER)
                    local replacement = replacements[ t.content ]
                    if (replacement)
                      expanded_tokens.add( forEach in replacement )
                    else
                      expanded_tokens.add( t )
                    endIf
                  else
                    expanded_tokens.add( t )
                  endIf
                endForEach

                # Insert expanded tokens
                _tokens.shift( _position, &delta=expanded_tokens.count )
                forEach (t at i in expanded_tokens)
                  _tokens[_position+i] = t
                endForEach
                _limit += expanded_tokens.count
                if (_position < _limit) _next_t = _tokens[_position]
              endUse
              return
            endIf
          endForEach

          # No macro matches arg count
          _restore_position
        endIf
      endIf

      processed_tokens.add( _cur_t )

    method mark_token
      marked_token = _cur_t
      _attribute_no_include = false

    method has_another->Logical
      return _position < _limit or inserted_tokens.count

    method include_filepath
      Program.include( marked_token, buffer->String )

    method join
      if (not disable_output and _cmd_stack.count >= 2)
        local b = _cmd_stack.remove_last
        local a = _cmd_stack.remove_last
        _cmd_stack.add( Identifier(b.t, a->String + b->String) )
      endIf

    method join_adjacent_literal_strings
      if (not disable_output and _cmd_stack.count >= 2)
        local a = _cmd_stack[_cmd_stack.count-2]->(as LiteralString)
        local b = _cmd_stack.remove_last->(as LiteralString)  # we already know b is a literal string
        a.value += b.value
      endIf

    method swap
      if (not disable_output and _cmd_stack.count >= 2)
        local b = _cmd_stack.remove_last
        local a = _cmd_stack.remove_last
        _cmd_stack.add( b )
        _cmd_stack.add( a )
      endIf

    method uses_attribute_no_include
      _attribute_no_include = true

    method uses_filepath
      # First pass $include's the given file
      local filepath = buffer->String
      if (filepath == "") throw marked_token.error( "Module path expected." )
      processed_tokens.add( marked_token.cloned(TokenType.STRING,filepath) )
      if (not _attribute_no_include)
        Program.include( marked_token, filepath, &is_optional )
      endIf

    method on_parsed_augment
      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      local name = augment_context_name
      local m = Program.current_module
      local base_name = name.before_first('<')
      if (base_name.contains(':'))
        local module_name = base_name.before_last( "::" )
        if (module_name == "") module_name = "Rogue"
        m = Program.get_module( augment_t, module_name )
        name .= after_last("::")
      endIf

      # Create a special aspect that will be incorporated into the designated class
      local aspect_name = "$-$-augment-$"(m.name,base_name,m.next_augment_id)
      ++m.next_augment_id

      if (not m.augments.contains(name)) m.augments[name] = String[]
      m.augments[name].add( aspect_name )

      # Change 'endAugment' to 'endClass'
      forEach (t at i in tokens step -1)
        if (t.type == TokenType.KEYWORD_END_AUGMENT)
          tokens[i] = t.cloned(TokenType.KEYWORD_END_CLASS,null)
          escapeForEach
        endIf
      endForEach

      m.templates[aspect_name] = Template( augment_t, m, aspect_name, Token[], tokens, Attribute.ASPECT|Attribute.AUGMENT )

    method on_uses_module
      assert _cmd_stack.count >= 2
      local attributes = _cmd_stack.remove_last->(as Attributes)
      local path = _cmd_stack.remove_last
      if (collecting_templates)
        local m = Program.get_module( path.t, File.filename(path) )
        Program.current_module.uses_module( m, &is_exported=attributes.is_exported )
      endIf

    method on_parsed_class
      create_type_template

    method on_parsed_enum
      local _template = create_type_template
      if (_template)
        _template.attributes.is_enum = true
        _template.attributes.is_compound = true
      endIf

    method create_type_template->Template
      local attributes : Int64
      if (_attribute_essential) attributes |= Attribute.ESSENTIAL
      _attribute_essential = false

      if (not collecting_templates) return null

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      assert tokens.count
      local class_t = tokens.first

      local name = tokens[1]
      local placeholders = Token[]
      if (i2 >= i1 + 4 and tokens[2].type == TokenType.SYMBOL_LTLT)
        forEach (t at i in tokens from 3)
          if (t.type == TokenType.SYMBOL_GTGT)
            tokens.discard( 0, i+1 )  # remove "class Name<<...>>>"
            escapeForEach
          endIf
          if (t.type == TokenType.PLACEHOLDER) placeholders.add( t )
        endForEach
      else
        tokens.discard( 0, 2 )   # remove "class Name"
      endIf

      local m = Program.current_module
      local extended_name = "$<<$>>"(name,placeholders.count)
      if (m.templates[extended_name])
        throw tokens.first.error( "A $-parameter template '$' already exists."(placeholders.count,name) )
      endIf

      local result = Template( class_t, m, name, placeholders, tokens, attributes )
      m.templates[extended_name] = result
      return result

    method on_parsed_routine
      local attributes : Int64
      if (_attribute_essential) attributes |= Attribute.ESSENTIAL
      _attribute_essential = false

      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      assert tokens.count
      local def_t = tokens.first

      # 'routine' -> 'method'
      def_t .= cloned( TokenType.KEYWORD_METHOD )
      tokens[0] = def_t

      tokens.insert( def_t.cloned(TokenType.EOL) )
      tokens.insert( def_t.cloned(TokenType.KEYWORD_GLOBAL_METHODS) )
      tokens.insert( def_t.cloned(TokenType.EOL) )
      tokens.add( tokens.last.cloned(TokenType.EOL,null) )
      tokens.add( tokens.last.cloned(TokenType.KEYWORD_END_CLASS) )

      local m = Program.current_module
      # Make this an augment of class Routine

      # Create a special aspect that will be incorporated into the designated class
      local aspect_name = "$-Routine-augment-$"(m.name,m.next_augment_id)
      ++m.next_augment_id

      if (not m.augments.contains("Routine")) m.augments["Routine"] = String[]
      m.augments["Routine"].add( aspect_name )

      attributes |= Attribute.ASPECT | Attribute.AUGMENT
      m.templates[aspect_name] = Template( augment_t, m, aspect_name, Token[], tokens, attributes )

    method parse_module_id
      # Doing this natively because we need to also switch context to the parsed module
      # so that we can store class templates in the appropriate module.
      local t = _next_t
      buffer.clear
      if (_consume(TokenType.SYMBOL_COLON_COLON))
        buffer.print "Rogue::" # default module
      elseIf (t.type != TokenType.IDENTIFIER)
        if (not disable_output) _push( null, 0 )
        Program.current_module = Program.default_module
        return
      endIf

      if (_next_t.type != TokenType.IDENTIFIER) _throw_syntax_error( "Identifier expected." )
      buffer.print _read.content

      while (_consume(TokenType.SYMBOL_COLON_COLON))
        buffer.print "::"
        if (_next_t.type != TokenType.IDENTIFIER) _throw_syntax_error( "Identifier expected." )
        buffer.print _read.content
      endWhile

      local module_id = buffer->String
      if (not disable_output) _push( Identifier(t,module_id), 0 )
      Program.current_module = Program.get_module( t, module_id )

    method _peek->Token
      if (inserted_tokens.count) return inserted_tokens.last
      return prior._peek

    method print_peek
      println "$:$.$: $"(_next_t.filepath,_next_t.line,_next_t.column,_next_t)

    method print_stack
      @trace _cmd_stack
      #if (_cmd_stack.count and _cmd_stack.last) @trace _cmd_stack.last.type_name

    method print_trace
      @trace _next_t

    method print_stack_trace
      println StackTrace()

    method _read->Token
      if (inserted_tokens.count) return inserted_tokens.remove_last
      return prior._read

    method rewrite_cur_token
      processed_tokens.add( _cur_t )

    method rewrite_token
      processed_tokens.add( _read )

    method store_statement_args
      if (disable_output) return

      local args = _cmd_stack.remove_last->(as Args)
      assert args?
      block access = _cmd_stack.last->(as Access)
        if (access)
          if (access.args) throw args.t.error( "Unexpected expression." )
          access.args = args
          return
        endIf
      endBlock

      block access = _cmd_stack.last->(as ContextAccess)
        if (access)
          if (not access.args) access.args = args
          else throw args.t.error( "Unexpected expression." )
          return
        endIf
      endBlock

      throw args.t.error( "Unexpected expression." )

endClass
