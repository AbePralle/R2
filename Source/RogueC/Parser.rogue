module Rogue
uses Utility/WorkList

# Generated by Froley. Will not be overwritten; customize as desired.
$include "ParserCore.rogue"

class Parser : ParserCore
  PROPERTIES
    processed_tokens : Token[]
    marked_token     : Token
    token_buffer     = Token[]
    inserted_tokens  = Token[]
    collecting_templates = false
    _attribute_no_include = false

  METHODS
    method preprocess
      processed_tokens = Token[]( _tokens.count * 1.2 )
      parse( ip_preprocess )
      _tokens.clear
      _tokens.add( processed_tokens )

    method create_definition
      local def_name = buffer->String
      Program.definitions[ def_name ] = token_buffer
      use history = WorkList<<String>>
        detect_definition_cycle( history, def_name, token_buffer )
      endUse
      token_buffer = Token[]

    method collect_next_token
      token_buffer.add( _read )

    method collect_token_string
      buffer.print _cur_t->String

    method detect_definition_cycle( history:String[], name:String, tokens:Token[] )
      if (history.contains(name))
        throw marked_token.error( "Definition of '$' results in an infinite cycle."(name) )
      endIf

      history.add( name )
      forEach (t in tokens)
        if (t.type == TokenType.IDENTIFIER)
          local entry = Program.definitions.find( t->String )
          if (entry)
            detect_definition_cycle( history, entry.key, entry.value )
          endIf
        endIf
      endForEach
      history.remove_last

    method insert_definition
      local def = Program.definitions[ _cur_t->String ]
      if (def) insert_definition( forEach in def step -1 )
      else     processed_tokens.add( _cur_t )

    method insert_definition( t:Token )
      if (t.type == TokenType.IDENTIFIER)
        local def = Program.definitions[ t->String ]
        if (def)
          insert_definition( forEach in def step -1 )
          return
        endIf
      endIf
      inserted_tokens.add( t )

    method mark_token
      marked_token = _cur_t
      _attribute_no_include = false

    method has_another->Logical
      return _position < _limit or inserted_tokens.count

    method include_filepath
      Program.include( marked_token, buffer->String )

    method uses_attribute_no_include
      _attribute_no_include = true

    method uses_filepath
      # First pass $include's the given file
      local filepath = buffer->String
      if (filepath == "") throw marked_token.error( "Module path expected." )
      processed_tokens.add( marked_token.cloned(TokenType.STRING,filepath) )
      if (not _attribute_no_include)
        Program.include( marked_token, filepath, &is_optional )
      endIf

    method on_parsed_class
      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = Token[]( (i2-i1)+1 )
      tokens.add( _tokens[forEach in i1..i2] )
      assert tokens.count
      local name = tokens[1]
      local placeholders = Token[]
      if (i2 >= i1 + 4 and tokens[2].type == TokenType.SYMBOL_LTLT)
        forEach (t in tokens from 3)
          if (t.type == TokenType.SYMBOL_GTGT) escapeForEach
          if (t.type == TokenType.PLACEHOLDER) placeholders.add( t )
        endForEach
      endIf

      local m = Program.current_module
      local extended_name = "$<<$>>"(name,placeholders.count)
      if (m.templates[extended_name])
        throw tokens.first.error( "A $-parameter template '$' already exists."(placeholders.count,name) )
      endIf
      m.templates[extended_name] = Template( name, placeholders, tokens )

    method parse_module_id
      # Doing this natively because we need to also switch context to the parsed module
      # so that we can store class templates in the appropriate module.
      local t = _next_t
      buffer.clear
      if (_consume(TokenType.SYMBOL_COLON_COLON))
        buffer.print "Rogue::" # default module
      elseIf (t.type != TokenType.IDENTIFIER)
        if (not disable_output) _push( null, 0 )
        Program.current_module = Program.default_module
        return
      endIf

      if (_next_t.type != TokenType.IDENTIFIER) _throw_syntax_error( "Identifier expected." )
      buffer.print _read.content

      while (_consume(TokenType.SYMBOL_COLON_COLON))
        buffer.print "::"
        if (_next_t.type != TokenType.IDENTIFIER) _throw_syntax_error( "Identifier expected." )
        buffer.print _read.content
      endWhile

      local module_id = buffer->String
      if (not disable_output) _push( Identifier(t,module_id), 0 )
      Program.current_module = Program.get_module( t, module_id )

    method rewrite_cur_token
      processed_tokens.add( _cur_t )

    method rewrite_token
      processed_tokens.add( _read )

    method _peek->Token
      if (inserted_tokens.count) return inserted_tokens.last
      return prior._peek

    method _read->Token
      if (inserted_tokens.count) return inserted_tokens.remove_last
      return prior._read

    method print_stack
      @trace _list_starts
      @trace _cmd_stack
endClass
