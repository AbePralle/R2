module Rogue
uses Utility/WorkList

# Generated by Froley. Will not be overwritten; customize as desired.
$include "ParserCore.rogue"

class Parser : ParserCore
  PROPERTIES
    processed_tokens : Token[]
    marked_token     : Token
    token_buffer     = Token[]
    inserted_tokens  = Token[]
    collecting_templates  = false
    _attribute_no_include = false
    _attribute_essential  = false

    augment_t            : Token
    augment_context_name : String

  METHODS
    method preprocess
      processed_tokens = Token[]( _tokens.count * 1.2 )
      parse( ip_preprocess )
      _tokens.clear
      _tokens.add( processed_tokens )

    method set_augment_context_name
      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      augment_t = _tokens[i1]

      use builder = StringBuilder.pool
        local depth = 0
        forEach (t at i in _tokens.from(i1,i2))
          which (t.type)
            case TokenType.EOL
              if (depth > 0) throw t.error( "Expected '>>', found end of line." )
              escapeForEach
            case TokenType.SYMBOL_COLON
              if (depth > 0)
                escapeForEach
              endIf
            case TokenType.SYMBOL_LTLT
              ++depth
            case TokenType.SYMBOL_GTGT
              --depth
              if (depth < 0)  throw t.error( "Unexpected '>>'." )
              if (depth == 0)
                builder.print ">>"
                escapeForEach
              endIf
          endWhich
          builder.print t->String
        endForEach
        if (depth > 0) throw _tokens[i1].error( "Unterminated '<<'." )
        augment_context_name = builder
      endUse

    method batch_augment_create_method
      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      local name = augment_context_name
      local m = Program.current_module
      local base_name = name.before_first('<')
      if (base_name.contains(':'))
        local module_name = base_name.before_last( "::" )
        if (module_name == "") module_name = "Rogue"
        m = Program.get_module( augment_t, module_name )
        name .= after_last("::")
      endIf

      # Create a special aspect that will be incorporated into the designated class
      local aspect_name = "$-$-augment-$"(m.name,base_name,m.next_augment_id)
      ++m.next_augment_id

      if (not m.augments.contains(name)) m.augments[name] = String[]
      m.augments[name].add( aspect_name )

      # Wrap tokens:
      #     METHODS
      #       method <tokens>
      #   endClass
      tokens.insert( tokens.last.cloned(TokenType.KEYWORD_METHOD,null) )
      tokens.insert( tokens.last.cloned(TokenType.EOL,null) )
      tokens.insert( tokens.last.cloned(TokenType.KEYWORD_METHODS,null) )
      tokens.insert( tokens.last.cloned(TokenType.EOL,null) )
      tokens.add( tokens.last.cloned(TokenType.EOL,null) )
      tokens.add( tokens.last.cloned(TokenType.KEYWORD_END_CLASS,null) )
      tokens.add( tokens.last.cloned(TokenType.EOL,null) )

      m.templates[aspect_name] = Template( augment_t, aspect_name, Token[], tokens, Attribute.ASPECT|Attribute.AUGMENT )

    method class_attribute_essential
      _attribute_essential = true

    method create_definition
      local def_name = buffer->String
      Program.definitions[ def_name ] = token_buffer
      use history = WorkList<<String>>
        detect_definition_cycle( history, def_name, token_buffer )
      endUse
      token_buffer = Token[]

    method collect_next_token
      token_buffer.add( _read )

    method collect_token_string
      buffer.print _cur_t->String

    method detect_definition_cycle( history:String[], name:String, tokens:Token[] )
      if (history.contains(name))
        throw marked_token.error( "Definition of '$' results in an infinite cycle."(name) )
      endIf

      history.add( name )
      forEach (t in tokens)
        if (t.type == TokenType.IDENTIFIER)
          local entry = Program.definitions.find( t->String )
          if (entry)
            detect_definition_cycle( history, entry.key, entry.value )
          endIf
        endIf
      endForEach
      history.remove_last

    method insert_definition
      local def = Program.definitions[ _cur_t->String ]
      if (def) insert_definition( forEach in def step -1 )
      else     processed_tokens.add( _cur_t )

    method insert_definition( t:Token )
      if (t.type == TokenType.IDENTIFIER)
        local def = Program.definitions[ t->String ]
        if (def)
          insert_definition( forEach in def step -1 )
          return
        endIf
      endIf
      inserted_tokens.add( t )

    method mark_token
      marked_token = _cur_t
      _attribute_no_include = false

    method has_another->Logical
      return _position < _limit or inserted_tokens.count

    method include_filepath
      Program.include( marked_token, buffer->String )

    method join
      if (not disable_output and _cmd_stack.count >= 2)
        local b = _cmd_stack.remove_last
        local a = _cmd_stack.remove_last
        _cmd_stack.add( Identifier(b.t, a->String + b->String) )
      endIf

    method join_adjacent_literal_strings
      if (not disable_output and _cmd_stack.count >= 2)
        local a = _cmd_stack[_cmd_stack.count-2]->(as LiteralString)
        local b = _cmd_stack.remove_last->(as LiteralString)  # we already know b is a literal string
        a.value += b.value
      endIf

    method swap
      if (not disable_output and _cmd_stack.count >= 2)
        local b = _cmd_stack.remove_last
        local a = _cmd_stack.remove_last
        _cmd_stack.add( b )
        _cmd_stack.add( a )
      endIf

    method uses_attribute_no_include
      _attribute_no_include = true

    method uses_filepath
      # First pass $include's the given file
      local filepath = buffer->String
      if (filepath == "") throw marked_token.error( "Module path expected." )
      processed_tokens.add( marked_token.cloned(TokenType.STRING,filepath) )
      if (not _attribute_no_include)
        Program.include( marked_token, filepath, &is_optional )
      endIf

    method on_parsed_augment
      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      local name = augment_context_name
      local m = Program.current_module
      local base_name = name.before_first('<')
      if (base_name.contains(':'))
        local module_name = base_name.before_last( "::" )
        if (module_name == "") module_name = "Rogue"
        m = Program.get_module( augment_t, module_name )
        name .= after_last("::")
      endIf

      # Create a special aspect that will be incorporated into the designated class
      local aspect_name = "$-$-augment-$"(m.name,base_name,m.next_augment_id)
      ++m.next_augment_id

      if (not m.augments.contains(name)) m.augments[name] = String[]
      m.augments[name].add( aspect_name )

      # Change 'endAugment' to 'endClass'
      forEach (t at i in tokens step -1)
        if (t.type == TokenType.KEYWORD_END_AUGMENT)
          tokens[i] = t.cloned(TokenType.KEYWORD_END_CLASS,null)
          escapeForEach
        endIf
      endForEach

      m.templates[aspect_name] = Template( augment_t, aspect_name, Token[], tokens, Attribute.ASPECT|Attribute.AUGMENT )

    method on_parsed_class
      create_type_template

    method on_parsed_enum
      local _template = create_type_template
      if (_template)
        _template.attributes.is_enum = true
        _template.attributes.is_compound = true
      endIf

    method create_type_template->Template
      local attributes = 0
      if (_attribute_essential) attributes |= Attribute.ESSENTIAL
      _attribute_essential = false

      if (not collecting_templates) return null

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      assert tokens.count
      local class_t = tokens.first

      local name = tokens[1]
      local placeholders = Token[]
      if (i2 >= i1 + 4 and tokens[2].type == TokenType.SYMBOL_LTLT)
        forEach (t at i in tokens from 3)
          if (t.type == TokenType.SYMBOL_GTGT)
            tokens.discard( 0, i+1 )  # remove "class Name<<...>>>"
            escapeForEach
          endIf
          if (t.type == TokenType.PLACEHOLDER) placeholders.add( t )
        endForEach
      else
        tokens.discard( 0, 2 )   # remove "class Name"
      endIf

      local m = Program.current_module
      local extended_name = "$<<$>>"(name,placeholders.count)
      if (m.templates[extended_name])
        throw tokens.first.error( "A $-parameter template '$' already exists."(placeholders.count,name) )
      endIf

      local result = Template( class_t, name, placeholders, tokens, attributes )
      m.templates[extended_name] = result
      return result

    method on_parsed_routine
      local attributes = 0
      if (_attribute_essential) attributes |= Attribute.ESSENTIAL
      _attribute_essential = false

      if (not collecting_templates) return

      local i1 = _saved_positions.last.position
      local i2 = _position - 1
      local tokens = _tokens.from( i1, i2 ).to_list

      assert tokens.count
      local def_t = tokens.first

      # 'routine' -> 'method'
      def_t .= cloned( TokenType.KEYWORD_METHOD )
      tokens[0] = def_t

      tokens.insert( def_t.cloned(TokenType.EOL) )
      tokens.insert( def_t.cloned(TokenType.KEYWORD_GLOBAL_METHODS) )
      tokens.insert( def_t.cloned(TokenType.EOL) )
      tokens.add( tokens.last.cloned(TokenType.EOL,null) )
      tokens.add( tokens.last.cloned(TokenType.KEYWORD_END_CLASS) )

      local m = Program.current_module
      #if (m.templates["Routine<<0>>"])
        # Make this an augment of class Routine

        # Create a special aspect that will be incorporated into the designated class
        local aspect_name = "$-Routine-augment-$"(m.name,m.next_augment_id)
        ++m.next_augment_id

        if (not m.augments.contains("Routine")) m.augments["Routine"] = String[]
        m.augments["Routine"].add( aspect_name )

        attributes |= Attribute.ASPECT | Attribute.AUGMENT
        m.templates[aspect_name] = Template( augment_t, aspect_name, Token[], tokens, attributes )

        #{
      else
        # Make this into class Routine
        local new_template = Template( def_t, "Routine", &placeholders=Token[], tokens, attributes )
        m.templates["Routine<<0>>"] = new_template

      endIf
      }#


    method parse_module_id
      # Doing this natively because we need to also switch context to the parsed module
      # so that we can store class templates in the appropriate module.
      local t = _next_t
      buffer.clear
      if (_consume(TokenType.SYMBOL_COLON_COLON))
        buffer.print "Rogue::" # default module
      elseIf (t.type != TokenType.IDENTIFIER)
        if (not disable_output) _push( null, 0 )
        Program.current_module = Program.default_module
        return
      endIf

      if (_next_t.type != TokenType.IDENTIFIER) _throw_syntax_error( "Identifier expected." )
      buffer.print _read.content

      while (_consume(TokenType.SYMBOL_COLON_COLON))
        buffer.print "::"
        if (_next_t.type != TokenType.IDENTIFIER) _throw_syntax_error( "Identifier expected." )
        buffer.print _read.content
      endWhile

      local module_id = buffer->String
      if (not disable_output) _push( Identifier(t,module_id), 0 )
      Program.current_module = Program.get_module( t, module_id )

    method _peek->Token
      if (inserted_tokens.count) return inserted_tokens.last
      return prior._peek

    method print_stack
      @trace _list_starts
      @trace _cmd_stack

    method print_trace
      @trace _next_t

    method _read->Token
      if (inserted_tokens.count) return inserted_tokens.remove_last
      return prior._read

    method rewrite_cur_token
      processed_tokens.add( _cur_t )

    method rewrite_token
      processed_tokens.add( _read )

    method store_statement_args
      if (disable_output) return

      local args = _cmd_stack.remove_last->(as Args)
      assert args?
      block access = _cmd_stack.last->(as Access)
        if (access)
          if (access.args) throw args.t.error( "Unexpected expression." )
          access.args = args
          return
        endIf
      endBlock

      block access = _cmd_stack.last->(as ContextAccess)
        if (access)
          if (not access.args) access.args = args
          else throw args.t.error( "Unexpected expression." )
          return
        endIf
      endBlock

      throw args.t.error( "Unexpected expression." )

endClass
