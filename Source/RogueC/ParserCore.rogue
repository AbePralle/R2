module Rogue

# Generated by Froley. WARNING: WILL BE OVERWRITTEN.
$define PARSER_EXISTS true

$include "Cmd.rogue"
$include "FrameStack.rogue"
$include "Scanner.rogue"
$include "Visitor.rogue"

class ParserCore [abstract]
  DEFINITIONS
    ip_program_elements = 0
    ip_consume_eols = 1
    ip_must_consume_eols = 2
    ip_consume_eols_and_semicolons = 3
    ip_program_element = 4
    ip_procedure_attributes = 5
    ip_procedure_attribute = 6
    ip_procedure_body = 7
    ip_procedure_parameters = 8
    ip_procedure_parameter = 9
    ip_optional_initial_value = 10
    ip_procedure_return_type = 11
    ip_id_or_type = 12
    ip_type = 13
    ip_remaining_type = 14
    ip_type_args = 15
    ip_template_arg_tokens = 16
    ip_type_name = 17
    ip_optional_type = 18
    ip_identifier = 19
    ip_string = 20
    ip_module_attributes = 21
    ip_module_attribute = 22
    ip_class_attributes = 23
    ip_class_attribute = 24
    ip_class = 25
    ip_placeholder = 26
    ip_template_parameters = 27
    ip_constructor_properties = 28
    ip_base_types = 29
    ip_attributes = 30
    ip_class_sections = 31
    ip_class_section = 32
    ip_native_code_blocks = 33
    ip_native_code_block = 34
    ip_definition = 35
    ip_forEach_loop = 36
    ip_forEach_control = 37
    ip_forEach_optional_at = 38
    ip_forEach_collection = 39
    ip_if_statement = 40
    ip_if_statement_multi_line_elseIf_else = 41
    ip_if_statement_single_line_elseIf_else = 42
    ip_inline_which = 43
    ip_inline_which_case = 44
    ip_wrap_in_local_scope = 45
    ip_method = 46
    ip_global_method = 47
    ip_properties = 48
    ip_property_declaration = 49
    ip_multi_line_statements = 50
    ip_single_line_statements = 51
    ip_control_structure = 52
    ip_args = 53
    ip_arg = 54
    ip_statement = 55
    ip_local_declarations = 56
    ip_local_declaration = 57
    ip_block = 58
    ip_try_catch = 59
    ip_catches = 60
    ip_catch_clause = 61
    ip_module_path = 62
    ip_uses_attributes = 63
    ip_uses_attribute = 64
    ip_access_args = 65
    ip_optional_expression = 66
    ip_expression = 67
    ip_op_and_assign = 68
    ip_logical_xor = 69
    ip_logical_xor__inner = 70
    ip_logical_or = 71
    ip_logical_or__inner = 72
    ip_logical_and = 73
    ip_logical_and__inner = 74
    ip_comparison = 75
    ip_comparison__inner = 76
    ip_reference_comparison = 77
    ip_bitwise_xor = 78
    ip_bitwise_xor__inner = 79
    ip_bitwise_or = 80
    ip_bitwise_or__inner = 81
    ip_bitwise_and = 82
    ip_bitwise_and__inner = 83
    ip_bitwise_shift = 84
    ip_bitwise_shift__inner = 85
    ip_add_subtract = 86
    ip_add_subtract__inner = 87
    ip_multiply_divide_mod = 88
    ip_multiply_divide_mod__inner = 89
    ip_power = 90
    ip_power__inner = 91
    ip_pre_unary = 92
    ip_post_unary = 93
    ip_post_unary__inner = 94
    ip_access = 95
    ip_access_inner = 96
    ip_context_block_command = 97
    ip_term = 98
    ip_native_code = 99
    ip_preprocess = 100
    ip_process_another = 101
    ip_collect_meta_filepath = 102
    ip_additional_node_types = 103

  PROPERTIES
    _tokens          : Token[]
    _position        : Int32
    _limit           : Int32
    _cmd_stack       = Cmd[]
    _token_stack     = FrameStack<<Token>>()
    _list_starts     = Int32[]
    _list_tokens     = Token[]
    _next_t          : Token
    _cur_t           : Token
    _saved_positions = ParserPosition[]
    start_ip         = 0
    ip               = 0
    buffer           = StringBuilder()
    output           = StringBuilder()

    disable_output         : Int32
    procedure_returns_this : Logical

  METHODS
    method init( file:File )
      init( Scanner(file) )

    method init( filepath:String, content:String )
      init( Scanner(filepath,content) )

    method init( scanner:Scanner )
      local tokens = scanner.tokenize
      if (scanner.output.count) print scanner.output; flush
      init( tokens )

    method init( _tokens )
      _position = 0
      _limit = _tokens.count
      _cmd_stack.clear
      _token_stack.clear
      output.clear

    method on_parsed_class [abstract]

    method parse_module_id [abstract]

    method class_attribute_essential [abstract]

    method store_statement_args [abstract]

    method uses_attribute_no_include [abstract]

    method mark_token [abstract]

    method collect_token_string [abstract]

    method collect_next_token [abstract]

    method create_definition [abstract]

    method include_filepath [abstract]

    method rewrite_cur_token [abstract]

    method uses_filepath [abstract]

    method insert_definition [abstract]

    method rewrite_token [abstract]

    method has_another->Logical
      return _position < _limit

    method parse( ip=null:Int32? )->Cmd
      if (_position == _limit) return null
      if (ip) start_ip = ip.value
      _token_stack.clear
      _list_starts.clear
      _list_tokens.clear
      _next_t = _peek
      _cur_t = _next_t
      _execute( start_ip )
      _on_output_line # flush any buffered output
      if (disable_output) return null
      if (_cmd_stack.count != 1)
        @trace _cmd_stack
        throw _peek.error( "[INTERNAL] Expected exactly one command node remaining on stack." )
      endIf
      return _cmd_stack.remove_last

    method _begin_list
      _list_starts.add( _cmd_stack.count )
      _list_tokens.add( _next_t )

    method _consume( type:TokenType )->Logical
      if (_next_t.type != type) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _consume_content( content:String )->Logical
      if (not _next_t.content or _next_t.content != content) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _consume_eols
      while (_next_t.type == TokenType.EOL)
        ++_position
        _next_t = _peek
      endWhile

    method _create_token_list
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] createTokenList/produceTokenlist without prior savePosition." )
      endIf
      local i1 = _saved_positions.remove_last.position
      local limit = _position
      local list = Token[]( limit - i1 )
      forEach (i in i1..<limit) list.add( _tokens[i] )
      _push( TokenList(_tokens[i1],list), 0 )

    method _describe( type:TokenType )->String
      if (type.symbol[0].is_letter) return type.symbol
      return "'$'" (type.symbol)

    method _discard_list
      if (_list_tokens.is_empty)
        throw _peek.error( "[INTERNAL] discardList without corresponding beginList." )
      endIf
      _list_starts.remove_last
      _list_tokens.remove_last

    method _discard_position
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] No savePosition to discard." )
      endIf
      _saved_positions.remove_last

    method _list_t->Token
      if (_list_tokens.is_empty)
        throw _peek.error( "[INTERNAL] createList/produceList without corresponding beginList." )
      endIf
      return _list_tokens.remove_last

    method _must_consume_content( content:String )
      if (_consume_content(content)) return
      local expected = which{ content.contains('\''):content || "'$'"(content.to_escaped_ascii) }
      local next = _describe( _peek.type )
      _throw_syntax_error( "Expected $, found $." (expected,next) )

    method _next_is( content:String )->Logical
      if (not _next_t.content or _next_t.content != content) return false
      if (_position < _limit) ++_position; _next_t = _peek
      return true

    method _on_output_line
      # Default behavior: print out 'output' and clear it. Can override this method.
      print( output ).flush
      output.clear

    method _on_t->Token
     local result = _next_t
     ++_position
     _next_t = _peek
     return result

    method _peek->Token
      if (_position < _limit) return _tokens[ _position ]
      if (_tokens.count) return _tokens.last.cloned( TokenType.EOI )
      return Token( TokenType.EOI, null, null, 0, 0 )

    method _pop_frame
      _token_stack.pop_frame
      _cur_t = _token_stack.pop

    method _push_frame
      _token_stack.push( _cur_t )
      _token_stack.push_frame

    method _push( cmd:Cmd, node_arg_count:Int32 )
      if (node_arg_count) _cmd_stack.discard_from( _cmd_stack.count - node_arg_count )
      _cmd_stack.add( cmd )

    method _push_list( list:Cmd )
      local i1 = _list_starts.remove_last
      list.add( forEach in _cmd_stack from i1 )
      _cmd_stack.discard_from( i1 )
      _cmd_stack.add( list )

    method _read->Token
      local result = _next_t
      if (_position < _limit) ++_position; _next_t = _peek
      return result

    method _restore_position
      if (_saved_positions.is_empty)
        throw _peek.error( "[INTERNAL] No savePosition to restore." )
      endIf
      local pos = _saved_positions.remove_last
      _position = pos.position
      _cmd_stack.discard_from( pos.cmd_stack_count )
      _cur_t = pos.cur_t
      _next_t = _peek

    method _save_position
      _saved_positions.add( ParserPosition(_position,_cmd_stack.count,_cur_t) )

    method _node_arg( relative:Int32 )->Cmd
      local i = _cmd_stack.count + relative
      if (i < 0) throw _peek.error( "[INTERNAL] Not enough nodes on stack to create new Cmd." )
      return _cmd_stack[i]

    method _logical_arg( relative:Int32 )->Logical
      local node = _node_arg( relative )
      if (node is null) return false
      return node->Logical

    method _character_arg( relative:Int32 )->Character
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Character

    method _integer_arg( relative:Int32 )->Int32
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Int32

    method _real_arg( relative:Int32 )->Real64
      local node = _node_arg( relative )
      if (node is null) return 0
      return node->Real64

    method _string_arg( relative:Int32 )->String
      local node = _node_arg( relative )
      if (node is null) return null
      return node->String

    method _string_to_Logical( st:String )->Logical
      if (st.equals("false",&ignore_case)) return false
      return st->Logical

    method _string_to_Character( st:String )->Character
      if (st.count == 0) return Character(0)
      return st[0]

    method _string_to_Integer( st:String )->Int32
      return st->Int32

    method _string_to_Real( st:String )->Real64
      return st->Real64

    method _throw_syntax_error( message=null:String, expected=null:TokenType? )
      if (message is null)
        use builder = StringBuilder.pool
          local next = _describe( _peek.type )
          if (expected)
            builder.print "Expected $, found $." (_describe(expected.value),next)
          else
            builder.print "Unexpected $." (next)
          endIf
          message = builder->String
        endUse
      endIf

      throw _peek.error( message )

    method _execute( ip:Int32 )
      _push_frame
      loop
        ++ip
        which (ip-1)
          case ip_program_elements
            _begin_list
            while ((_position < _limit))
              _execute(ip_program_element)
              _pop_frame
            endWhile
            if (disable_output)     _discard_list
            else                    _push_list( CmdList(_list_t) )
            return
          case ip_consume_eols
            while (_consume(TokenType.EOL))
            endWhile
            return
          case ip_must_consume_eols
            if ((not _consume(TokenType.EOL)))
              _throw_syntax_error("End of line expected.")
            endIf
            while (_consume(TokenType.EOL))
            endWhile
            return
          case ip_consume_eols_and_semicolons
            while ((_consume(TokenType.EOL) or _consume(TokenType.SYMBOL_SEMICOLON)))
            endWhile
            return
          case ip_program_element
            _execute(ip_consume_eols)
            _pop_frame
            if ((not (_position < _limit)))
              return
            endIf
            if ((_next_t.type == TokenType.KEYWORD_CLASS))
              _save_position
              ++disable_output
              _consume(TokenType.KEYWORD_CLASS)
              _execute(ip_identifier)
              _pop_frame
              _execute(ip_template_parameters)
              _pop_frame
              _execute(ip_class)
              _pop_frame
              this.ip = ip
              on_parsed_class
              ip = this.ip
              --disable_output
              _discard_position
              return
            endIf
            if (_next_t.type == TokenType.KEYWORD_MODULE)
              temporarily _cur_t = _on_t
                this.ip = ip
                parse_module_id
                ip = this.ip
                _execute(ip_module_attributes)
                _pop_frame
                if (not disable_output) _push( DefineModule(_cur_t,_string_arg(-2),_node_arg(-1)->(as Attributes)), 2 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_ROUTINE)
              temporarily _cur_t = _on_t
                _execute(ip_identifier)
                _pop_frame
                _execute(ip_procedure_parameters)
                _pop_frame
                _execute(ip_procedure_return_type)
                _pop_frame
                _execute(ip_procedure_attributes)
                _pop_frame
                if (_consume(TokenType.SYMBOL_COLON))
                  _execute(ip_single_line_statements)
                  _pop_frame
                else
                  _execute(ip_multi_line_statements)
                  _pop_frame
                  if (not _consume(TokenType.KEYWORD_END_ROUTINE)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_ROUTINE )
                endIf
                if (not disable_output) _push( LocalScope(_cur_t,_node_arg(-1)), 1 )
                if (not disable_output) _push( Routine(_cur_t,_string_arg(-5),_node_arg(-4)->(as Parameters),_node_arg(-3)->(as Type),_node_arg(-2)->(as Attributes),_node_arg(-1)->(as LocalScope)), 5 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_USES)
              temporarily _cur_t = _on_t
                _execute(ip_string)
                _pop_frame
                _execute(ip_uses_attributes)
                _pop_frame
                if (not disable_output) _push( UsesModule(_cur_t,_node_arg(-2),_node_arg(-1)->(as Attributes)), 2 )
                return
              endTemporarily
            endIf
            if ((_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)
              _throw_syntax_error
            endIf
            _execute(ip_procedure_body)
            _pop_frame
            return
          case ip_procedure_attributes
            _begin_list
            if (procedure_returns_this)
              if (not disable_output) _push( AttributeReturnsThis(_cur_t), 0 )
              procedure_returns_this = false
            endIf
            if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
              temporarily _cur_t = _on_t
                while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
                  _execute(ip_procedure_attribute)
                  _pop_frame
                  _consume(TokenType.SYMBOL_COMMA)
                endWhile
                if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
              endTemporarily
            endIf
            if (disable_output)     _discard_list
            else                    _push_list( Attributes(_list_t) )
            return
          case ip_procedure_attribute
            if (_next_t.content and _next_t.content == "append")
              temporarily _cur_t = _on_t
                if (not disable_output) _push( AttributeAppend(_cur_t), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.content and _next_t.content == "insert")
              temporarily _cur_t = _on_t
                if (not disable_output) _push( AttributeInsert(_cur_t), 0 )
                return
              endTemporarily
            endIf
            _throw_syntax_error("Illegal procedure attribute. Expected one or more of [append insert].")
            return
          case ip_procedure_body
            _execute(ip_multi_line_statements)
            _pop_frame
            return
          case ip_procedure_parameters
            _begin_list
            if ((not _consume(TokenType.SYMBOL_OPEN_PAREN)))
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              return
            endIf
            if (_consume(TokenType.SYMBOL_CLOSE_PAREN))
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              return
            endIf
            _execute(ip_procedure_parameter)
            _pop_frame
            while (_consume(TokenType.SYMBOL_COMMA))
              _execute(ip_procedure_parameter)
              _pop_frame
            endWhile
            if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            if (disable_output)     _discard_list
            else                    _push_list( Parameters(_list_t) )
            return
          case ip_procedure_parameter
            _execute(ip_consume_eols)
            _pop_frame
            if (_next_t.type == TokenType.IDENTIFIER)
              temporarily _cur_t = _on_t
                _execute(ip_optional_initial_value)
                _pop_frame
                _execute(ip_optional_type)
                _pop_frame
                if (not disable_output) _push( Local(_cur_t,_cur_t.content,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_AMPERSAND)
              temporarily _cur_t = _on_t
                _execute(ip_identifier)
                _pop_frame
                _execute(ip_optional_initial_value)
                _pop_frame
                _execute(ip_optional_type)
                _pop_frame
                if (not disable_output) _push( Local(_cur_t,_string_arg(-3),_node_arg(-2),_node_arg(-1)->(as Type),_string_to_Logical("true")), 3 )
                return
              endTemporarily
            endIf
            if (not _consume(TokenType.IDENTIFIER)) _throw_syntax_error( &expected=TokenType.IDENTIFIER )
            return
          case ip_optional_initial_value
            if (_consume(TokenType.SYMBOL_EQUALS))
              _execute(ip_consume_eols)
              _pop_frame
              _execute(ip_expression)
              _pop_frame
            else
              if (not disable_output) _push( null, 0 )
            endIf
            return
          case ip_procedure_return_type
            if ((not _consume(TokenType.SYMBOL_ARROW)))
              if (not disable_output) _push( null, 0 )
              return
            endIf
            if (_consume(TokenType.KEYWORD_THIS))
              procedure_returns_this = true
              if (not disable_output) _push( null, 0 )
              return
            endIf
            _execute(ip_type)
            _pop_frame
            return
          case ip_id_or_type
            _execute(ip_type_name)
            _pop_frame
            if ((((_next_t.type == TokenType.SYMBOL_LTLT) or (_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS)) or (_next_t.type == TokenType.SYMBOL_QUESTION)))
              _execute(ip_remaining_type)
              _pop_frame
            endIf
            return
          case ip_type
            _execute(ip_type_name)
            _pop_frame
            _execute(ip_remaining_type)
            _pop_frame
            return
          case ip_remaining_type
            if ((_next_t.type == TokenType.SYMBOL_LTLT))
              _execute(ip_type_args)
              _pop_frame
            else
              if (not disable_output) _push( null, 0 )
            endIf
            if (not disable_output) _push( Type(_cur_t,_string_arg(-2),_node_arg(-1)->(as TemplateArgs)), 2 )
            while (((_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS) or (_next_t.type == TokenType.SYMBOL_QUESTION)))
              if (_next_t.type == TokenType.SYMBOL_EMPTY_SQUARE_BRACKETS)
                temporarily _cur_t = _on_t
                  if (not disable_output) _push( Type(_cur_t,_node_arg(-1)->(as Type)), 1 )
                endTemporarily
              elseIf (_next_t.type == TokenType.SYMBOL_QUESTION)
                temporarily _cur_t = _on_t
                  if (not disable_output) _push( Type(_cur_t,_node_arg(-1)->(as Type),_string_to_Logical("true")), 1 )
                endTemporarily
              endIf
            endWhile
            return
          case ip_type_args
            _consume(TokenType.SYMBOL_LTLT)
            _begin_list
            _execute(ip_consume_eols)
            _pop_frame
            if ((not _consume(TokenType.SYMBOL_GTGT)))
              _execute(ip_template_arg_tokens)
              _pop_frame
              _execute(ip_consume_eols)
              _pop_frame
              while (_consume(TokenType.SYMBOL_COMMA))
                _execute(ip_consume_eols)
                _pop_frame
                _execute(ip_template_arg_tokens)
                _pop_frame
                _execute(ip_consume_eols)
                _pop_frame
              endWhile
              if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
            endIf
            if (disable_output)     _discard_list
            else                    _push_list( TemplateArgs(_list_t) )
            return
          case ip_template_arg_tokens
            _save_position
            while ((((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_COMMA))) and (not (_next_t.type == TokenType.SYMBOL_GTGT))))
              _read
            endWhile
            if (disable_output) _discard_position
            else                _create_token_list
            return
          case ip_type_name
            _save_position
            if (_next_t.type == TokenType.SYMBOL_COLON_COLON)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( Identifier(_cur_t,"\"Rogue\""), 0 )
                _execute(ip_identifier)
                _pop_frame
                if (not disable_output) _push( ModuleQualifiedID(_cur_t,_node_arg(-2),_string_arg(-1)), 2 )
                _discard_position
              endTemporarily
            else
              _restore_position
              _execute(ip_identifier)
              _pop_frame
            endIf
            while ((_next_t.type == TokenType.SYMBOL_COLON_COLON))
              if (_next_t.type == TokenType.SYMBOL_COLON_COLON)
                temporarily _cur_t = _on_t
                  _execute(ip_identifier)
                  _pop_frame
                  if (not disable_output) _push( ModuleQualifiedID(_cur_t,_node_arg(-2),_string_arg(-1)), 2 )
                endTemporarily
              endIf
            endWhile
            return
          case ip_optional_type
            if (_consume(TokenType.SYMBOL_COLON))
              _execute(ip_type)
              _pop_frame
            else
              if (not disable_output) _push( null, 0 )
            endIf
            return
          case ip_identifier
            if (_next_t.type == TokenType.IDENTIFIER)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
                return
              endTemporarily
            endIf
            if ((_next_t.type == TokenType.PLACEHOLDER))
              if ((not disable_output))
                _throw_syntax_error
              endIf
              if (_next_t.type == TokenType.PLACEHOLDER)
                temporarily _cur_t = _on_t
                  if (not disable_output) _push( Identifier(_cur_t,_cur_t.content), 0 )
                  return
                endTemporarily
              endIf
            endIf
            _throw_syntax_error("Identifier expected.")
            return
          case ip_string
            if (_next_t.type == TokenType.STRING)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
                return
              endTemporarily
            endIf
            _throw_syntax_error("Literal string expected.")
            return
          case ip_module_attributes
            _begin_list
            if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
              temporarily _cur_t = _on_t
                while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
                  _execute(ip_module_attribute)
                  _pop_frame
                  _consume(TokenType.SYMBOL_COMMA)
                endWhile
                if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
              endTemporarily
            endIf
            if (disable_output)     _discard_list
            else                    _push_list( Attributes(_list_t) )
            return
          case ip_module_attribute
            _throw_syntax_error("Illegal module attribute.")
            return
          case ip_class_attributes
            _begin_list
            if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
              temporarily _cur_t = _on_t
                while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
                  _execute(ip_class_attribute)
                  _pop_frame
                  _consume(TokenType.SYMBOL_COMMA)
                endWhile
                if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
              endTemporarily
            endIf
            if (disable_output)     _discard_list
            else                    _push_list( Attributes(_list_t) )
            return
          case ip_class_attribute
            if (_next_t.content and _next_t.content == "compound")
              temporarily _cur_t = _on_t
                if (not disable_output) _push( AttributeCompound(_cur_t), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.content and _next_t.content == "singleton")
              temporarily _cur_t = _on_t
                if (not disable_output) _push( AttributeSingleton(_cur_t), 0 )
                return
              endTemporarily
            endIf
            if (_consume_content("essential"))
              this.ip = ip
              class_attribute_essential
              ip = this.ip
              if (not disable_output) _push( AttributeEssential(_cur_t), 0 )
              return
            elseIf (_consume_content("primitive"))
              if (not disable_output) _push( AttributePrimitive(_cur_t), 0 )
              return
            elseIf (_consume_content("aspect"))
              if (not disable_output) _push( AttributeAspect(_cur_t), 0 )
              return
            endIf
            _throw_syntax_error("Illegal class attribute. Expected one or more of [aspect compound essential primitive singleton].")
            return
          case ip_class
            _execute(ip_constructor_properties)
            _pop_frame
            _execute(ip_base_types)
            _pop_frame
            _execute(ip_class_attributes)
            _pop_frame
            if (_consume(TokenType.SYMBOL_SEMICOLON))
              if (not disable_output) _push( null, 0 )
            else
              _execute(ip_class_sections)
              _pop_frame
              if (not _consume(TokenType.KEYWORD_END_CLASS)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_CLASS )
            endIf
            if (not disable_output) _push( Class(_cur_t,_node_arg(-4)->(as Parameters),_node_arg(-3)->(as TypeList),_node_arg(-2)->(as Attributes),_node_arg(-1)), 4 )
            return
          case ip_placeholder
            if (_next_t.type == TokenType.PLACEHOLDER)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( Placeholder(_cur_t,_cur_t.content), 0 )
                return
              endTemporarily
            endIf
            _throw_syntax_error("'$Placeholder' name expected.")
            return
          case ip_template_parameters
            if (_next_t.type == TokenType.SYMBOL_LTLT)
              temporarily _cur_t = _on_t
                _begin_list
                if ((not _consume(TokenType.SYMBOL_GTGT)))
                  _execute(ip_placeholder)
                  _pop_frame
                  while (_consume(TokenType.SYMBOL_COMMA))
                    _execute(ip_placeholder)
                    _pop_frame
                  endWhile
                  if (not _consume(TokenType.SYMBOL_GTGT)) _throw_syntax_error( &expected=TokenType.SYMBOL_GTGT )
                endIf
                if (disable_output)     _discard_list
                else                    _push_list( CmdList(_list_t) )
                return
              endTemporarily
            endIf
            if (not disable_output) _push( null, 0 )
            return
          case ip_constructor_properties
            if ((not (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)))
              if (not disable_output) _push( null, 0 )
              return
            endIf
            _execute(ip_procedure_parameters)
            _pop_frame
            return
          case ip_base_types
            _begin_list
            if ((not _consume(TokenType.SYMBOL_COLON)))
              if (disable_output)     _discard_list
              else                    _push_list( TypeList(_list_t) )
              return
            endIf
            _execute(ip_type)
            _pop_frame
            while (((_position < _limit) and ((_next_t.type == TokenType.SYMBOL_COMMA) or (_next_t.type == TokenType.IDENTIFIER))))
              if (_consume(TokenType.SYMBOL_COMMA))
                _execute(ip_consume_eols)
                _pop_frame
              endIf
              _execute(ip_type)
              _pop_frame
            endWhile
            if (disable_output)     _discard_list
            else                    _push_list( TypeList(_list_t) )
            return
          case ip_attributes
            _begin_list
            if ((not _consume(TokenType.SYMBOL_OPEN_SQUARE)))
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              return
            endIf
            if (_consume(TokenType.SYMBOL_CLOSE_SQUARE))
              if (disable_output)     _discard_list
              else                    _push_list( CmdList(_list_t) )
              return
            endIf
            while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
              _execute(ip_identifier)
              _pop_frame
              if (_consume(TokenType.SYMBOL_COMMA))
                _execute(ip_consume_eols)
                _pop_frame
              else
                _execute(ip_consume_eols)
                _pop_frame
                _consume(TokenType.SYMBOL_COMMA)
              endIf
            endWhile
            if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
            if (disable_output)     _discard_list
            else                    _push_list( Attributes(_list_t) )
            return
          case ip_class_sections
            _begin_list
            if ((not _consume(TokenType.SYMBOL_SEMICOLON)))
              while ((not (_next_t.type == TokenType.KEYWORD_END_CLASS)))
                _execute(ip_class_section)
                _pop_frame
              endWhile
            endIf
            if (disable_output)     _discard_list
            else                    _push_list( CmdList(_list_t) )
            return
          case ip_class_section
            _execute(ip_consume_eols)
            _pop_frame
            if (_next_t.type == TokenType.KEYWORD_GLOBAL_METHODS)
              temporarily _cur_t = _on_t
                _execute(ip_consume_eols)
                _pop_frame
                while ((_next_t.type == TokenType.KEYWORD_METHOD))
                  _execute(ip_global_method)
                  _pop_frame
                  _execute(ip_consume_eols)
                  _pop_frame
                endWhile
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_METHODS)
              temporarily _cur_t = _on_t
                _execute(ip_consume_eols)
                _pop_frame
                while ((_next_t.type == TokenType.KEYWORD_METHOD))
                  _execute(ip_method)
                  _pop_frame
                  _execute(ip_consume_eols)
                  _pop_frame
                endWhile
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_PROPERTIES)
              temporarily _cur_t = _on_t
                _execute(ip_consume_eols)
                _pop_frame
                while ((not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
                  _execute(ip_properties)
                  _pop_frame
                  _execute(ip_consume_eols)
                  _pop_frame
                endWhile
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_NATIVE_SECTION)
              temporarily _cur_t = _on_t
                _execute(ip_consume_eols)
                _pop_frame
                while ((not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
                  _execute(ip_native_code_blocks)
                  _pop_frame
                  _execute(ip_consume_eols)
                  _pop_frame
                endWhile
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_DEFINITIONS)
              temporarily _cur_t = _on_t
                _execute(ip_consume_eols)
                _pop_frame
                while ((not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
                  _execute(ip_definition)
                  _pop_frame
                  _execute(ip_consume_eols)
                  _pop_frame
                endWhile
                return
              endTemporarily
            endIf
            if ((not (_next_t.type == TokenType.KEYWORD_END_CLASS)))
              _throw_syntax_error
            endIf
            return
          case ip_native_code_blocks
            _execute(ip_consume_eols)
            _pop_frame
            while ((not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?))
              _execute(ip_native_code_block)
              _pop_frame
              _execute(ip_consume_eols)
              _pop_frame
            endWhile
            return
          case ip_native_code_block
            if (_next_t.type == TokenType.KEYWORD_NATIVE_HEADER)
              temporarily _cur_t = _on_t
                _execute(ip_consume_eols)
                _pop_frame
                _execute(ip_string)
                _pop_frame
                if (not disable_output) _push( NativeHeader(_cur_t,_string_arg(-1)), 1 )
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_NATIVE_CODE)
              temporarily _cur_t = _on_t
                _execute(ip_consume_eols)
                _pop_frame
                _execute(ip_string)
                _pop_frame
                if (not disable_output) _push( NativeCode(_cur_t,_string_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            _throw_syntax_error("Expected 'nativeHeader' or 'nativeCode'.")
            return
          case ip_definition
            if (_next_t.type == TokenType.IDENTIFIER)
              temporarily _cur_t = _on_t
                if (not _consume(TokenType.SYMBOL_EQUALS)) _throw_syntax_error( &expected=TokenType.SYMBOL_EQUALS )
                _execute(ip_expression)
                _pop_frame
                if (not disable_output) _push( Definition(_cur_t,_cur_t.content,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (not _consume(TokenType.IDENTIFIER)) _throw_syntax_error( &expected=TokenType.IDENTIFIER )
            return
          case ip_forEach_loop
            if (_next_t.type == TokenType.KEYWORD_FOR_EACH)
              temporarily _cur_t = _on_t
                if (_consume(TokenType.SYMBOL_OPEN_PAREN))
                  _execute(ip_consume_eols)
                  _pop_frame
                  _execute(ip_forEach_control)
                  _pop_frame
                  _execute(ip_consume_eols)
                  _pop_frame
                  if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
                else
                  _execute(ip_forEach_control)
                  _pop_frame
                endIf
                if (_consume(TokenType.EOL))
                  _execute(ip_multi_line_statements)
                  _pop_frame
                  _execute(ip_wrap_in_local_scope)
                  _pop_frame
                  if (not _consume(TokenType.KEYWORD_END_FOR_EACH)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_FOR_EACH )
                else
                  _execute(ip_single_line_statements)
                  _pop_frame
                  _execute(ip_wrap_in_local_scope)
                  _pop_frame
                endIf
                if (not disable_output) _push( ForEach(_cur_t,_node_arg(-2)->(as ForEachControl),_node_arg(-1)), 2 )
                return
              endTemporarily
            endIf
            return
          case ip_forEach_control
            _execute(ip_identifier)
            _pop_frame
            _execute(ip_forEach_optional_at)
            _pop_frame
            if (_consume_content("in"))
              _execute(ip_forEach_collection)
              _pop_frame
              if (not disable_output) _push( ForEachInControl(_cur_t,_string_arg(-3),_node_arg(-2)->(as ForEachAt),_node_arg(-1)->(as ForEachCollection)), 3 )
              return
            elseIf (_consume_content("of"))
              _execute(ip_forEach_collection)
              _pop_frame
              if (not disable_output) _push( ForEachOfControl(_cur_t,_string_arg(-3),_node_arg(-2)->(as ForEachAt),_node_arg(-1)->(as ForEachCollection)), 3 )
              return
            else
              _throw_syntax_error("Expected 'in' or 'of'.")
            endIf
            return
          case ip_forEach_optional_at
            if ((not _consume_content("at")))
              if (not disable_output) _push( null, 0 )
              return
            endIf
            _execute(ip_identifier)
            _pop_frame
            if (not disable_output) _push( ForEachAt(_cur_t,_string_arg(-1)), 1 )
            return
          case ip_forEach_collection
            _save_position
            if (not disable_output) _push( null, 0 )
            _execute(ip_expression)
            _pop_frame
            if ((_next_t.type == TokenType.SYMBOL_EQUALS))
              _restore_position
              _execute(ip_identifier)
              _pop_frame
              if (not _consume(TokenType.SYMBOL_EQUALS)) _throw_syntax_error( &expected=TokenType.SYMBOL_EQUALS )
              _execute(ip_expression)
              _pop_frame
            else
              _discard_position
            endIf
            if (_next_t.type == TokenType.SYMBOL_DOTDOT)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not disable_output) _push( RangeUpTo(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
              endTemporarily
            elseIf (_next_t.type == TokenType.SYMBOL_DOTDOTLT)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not disable_output) _push( RangeUpToLessThan(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
              endTemporarily
            elseIf (_next_t.type == TokenType.SYMBOL_DOTDOTGT)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not disable_output) _push( RangeDownToGreaterThan(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_DOWN_TO)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not disable_output) _push( RangeDownTo(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
              endTemporarily
            endIf
            if (_consume_content("from"))
              _execute(ip_expression)
              _pop_frame
            else
              if (not disable_output) _push( null, 0 )
            endIf
            if (_consume_content("step"))
              _execute(ip_expression)
              _pop_frame
            else
              if (not disable_output) _push( null, 0 )
            endIf
            if (not disable_output) _push( ForEachCollection(_cur_t,_string_arg(-4),_node_arg(-3),_node_arg(-2),_node_arg(-1)), 4 )
            return
          case ip_if_statement
            if (_next_t.type == TokenType.KEYWORD_IF)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (_consume(TokenType.EOL))
                  _execute(ip_multi_line_statements)
                  _pop_frame
                  _execute(ip_wrap_in_local_scope)
                  _pop_frame
                  _execute(ip_if_statement_multi_line_elseIf_else)
                  _pop_frame
                  if (not _consume(TokenType.KEYWORD_END_IF)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_IF )
                else
                  _execute(ip_single_line_statements)
                  _pop_frame
                  _execute(ip_wrap_in_local_scope)
                  _pop_frame
                  _execute(ip_if_statement_single_line_elseIf_else)
                  _pop_frame
                endIf
                if (not disable_output) _push( If(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)->(as If)), 3 )
                return
              endTemporarily
            endIf
            return
          case ip_if_statement_multi_line_elseIf_else
            _save_position
            if (_next_t.type == TokenType.KEYWORD_ELSE_IF)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (_consume(TokenType.EOL))
                  _discard_position
                  _execute(ip_multi_line_statements)
                  _pop_frame
                  _execute(ip_wrap_in_local_scope)
                  _pop_frame
                  _execute(ip_if_statement_multi_line_elseIf_else)
                  _pop_frame
                  if (not disable_output) _push( If(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)->(as If)), 3 )
                  return
                else
                  _restore_position
                  if (not disable_output) _push( null, 0 )
                  return
                endIf
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_ELSE)
              temporarily _cur_t = _on_t
                if (_consume(TokenType.EOL))
                  _discard_position
                  if (not disable_output) _push( null, 0 )
                  _execute(ip_multi_line_statements)
                  _pop_frame
                  _execute(ip_wrap_in_local_scope)
                  _pop_frame
                  if (not disable_output) _push( null, 0 )
                  if (not disable_output) _push( If(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)->(as If)), 3 )
                  return
                else
                  _restore_position
                  if (not disable_output) _push( null, 0 )
                  return
                endIf
              endTemporarily
            else
              _discard_position
              if (not disable_output) _push( null, 0 )
              return
            endIf
          case ip_if_statement_single_line_elseIf_else
            _save_position
            if (_next_t.type == TokenType.KEYWORD_ELSE_IF)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (_consume(TokenType.EOL))
                  _restore_position
                  if (not disable_output) _push( null, 0 )
                  return
                else
                  _discard_position
                  _execute(ip_single_line_statements)
                  _pop_frame
                  _execute(ip_wrap_in_local_scope)
                  _pop_frame
                  _execute(ip_if_statement_single_line_elseIf_else)
                  _pop_frame
                  if (not disable_output) _push( If(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)->(as If)), 3 )
                  return
                endIf
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_ELSE)
              temporarily _cur_t = _on_t
                if (_consume(TokenType.EOL))
                  _restore_position
                  if (not disable_output) _push( null, 0 )
                  return
                else
                  _discard_position
                  if (not disable_output) _push( null, 0 )
                  _execute(ip_single_line_statements)
                  _pop_frame
                  _execute(ip_wrap_in_local_scope)
                  _pop_frame
                  if (not disable_output) _push( null, 0 )
                  if (not disable_output) _push( If(_cur_t,_node_arg(-3),_node_arg(-2),_node_arg(-1)->(as If)), 3 )
                  return
                endIf
              endTemporarily
            else
              _discard_position
              if (not disable_output) _push( null, 0 )
              return
            endIf
          case ip_inline_which
            if (_next_t.type == TokenType.KEYWORD_WHICH)
              temporarily _cur_t = _on_t
                _execute(ip_consume_eols)
                _pop_frame
                if (not _consume(TokenType.SYMBOL_OPEN_CURLY)) _throw_syntax_error( &expected=TokenType.SYMBOL_OPEN_CURLY )
                _execute(ip_consume_eols)
                _pop_frame
                _begin_list
                _execute(ip_inline_which_case)
                _pop_frame
                _execute(ip_consume_eols)
                _pop_frame
                while (_consume(TokenType.SYMBOL_DOUBLE_VERTICAL_BAR))
                  _execute(ip_consume_eols)
                  _pop_frame
                  _execute(ip_inline_which_case)
                  _pop_frame
                  _execute(ip_consume_eols)
                  _pop_frame
                endWhile
                if (disable_output)     _discard_list
                else                    _push_list( InlineWhichCases(_list_t) )
                if (not _consume(TokenType.SYMBOL_CLOSE_CURLY)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_CURLY )
                if (not disable_output) _push( InlineWhich(_cur_t,_node_arg(-1)->(as InlineWhichCases)), 1 )
                return
              endTemporarily
            endIf
            return
          case ip_inline_which_case
            _execute(ip_expression)
            _pop_frame
            _execute(ip_consume_eols)
            _pop_frame
            if (_consume(TokenType.SYMBOL_COLON))
              _execute(ip_expression)
              _pop_frame
              _execute(ip_consume_eols)
              _pop_frame
            else
              if (not disable_output) _push( null, 0 )
            endIf
            if (not disable_output) _push( InlineWhichCase(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
            return
          case ip_wrap_in_local_scope
            if (not disable_output) _push( LocalScope(_cur_t,_node_arg(-1)), 1 )
            return
          case ip_method
            if (_next_t.type == TokenType.KEYWORD_METHOD)
              temporarily _cur_t = _on_t
                _execute(ip_identifier)
                _pop_frame
                _execute(ip_procedure_parameters)
                _pop_frame
                _execute(ip_procedure_return_type)
                _pop_frame
                _execute(ip_procedure_attributes)
                _pop_frame
                _consume(TokenType.SYMBOL_COLON)
                _execute(ip_multi_line_statements)
                _pop_frame
                if (not disable_output) _push( LocalScope(_cur_t,_node_arg(-1)), 1 )
                if (not disable_output) _push( Method(_cur_t,_string_arg(-5),_node_arg(-4)->(as Parameters),_node_arg(-3)->(as Type),_node_arg(-2)->(as Attributes),_node_arg(-1)->(as LocalScope)), 5 )
                return
              endTemporarily
            endIf
            return
          case ip_global_method
            if (_next_t.type == TokenType.KEYWORD_METHOD)
              temporarily _cur_t = _on_t
                _execute(ip_identifier)
                _pop_frame
                _execute(ip_procedure_parameters)
                _pop_frame
                _execute(ip_procedure_return_type)
                _pop_frame
                _execute(ip_procedure_attributes)
                _pop_frame
                _consume(TokenType.SYMBOL_COLON)
                _execute(ip_multi_line_statements)
                _pop_frame
                if (not disable_output) _push( LocalScope(_cur_t,_node_arg(-1)), 1 )
                if (not disable_output) _push( GlobalMethod(_cur_t,_string_arg(-5),_node_arg(-4)->(as Parameters),_node_arg(-3)->(as Type),_node_arg(-2)->(as Attributes),_node_arg(-1)->(as LocalScope)), 5 )
                return
              endTemporarily
            endIf
            return
          case ip_properties
            _begin_list
            _execute(ip_consume_eols)
            _pop_frame
            _execute(ip_property_declaration)
            _pop_frame
            while (_consume(TokenType.SYMBOL_COMMA))
              _execute(ip_consume_eols)
              _pop_frame
              _execute(ip_property_declaration)
              _pop_frame
            endWhile
            if (disable_output)     _discard_list
            else                    _push_list( CmdList(_list_t) )
            _execute(ip_optional_type)
            _pop_frame
            _execute(ip_attributes)
            _pop_frame
            if (not disable_output) _push( PropertyDeclarations(_cur_t,_node_arg(-3),_node_arg(-2)->(as Type),_node_arg(-1)->(as Attributes)), 3 )
            return
          case ip_property_declaration
            if (_next_t.type == TokenType.IDENTIFIER)
              temporarily _cur_t = _on_t
                _execute(ip_optional_initial_value)
                _pop_frame
                if (not disable_output) _push( null, 0 )
                if (not disable_output) _push( Property(_cur_t,_cur_t.content,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_NATIVE)
              temporarily _cur_t = _on_t
                _execute(ip_string)
                _pop_frame
                if (not disable_output) _push( NativeCProperty(_cur_t,_string_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (not _consume(TokenType.IDENTIFIER)) _throw_syntax_error( &expected=TokenType.IDENTIFIER )
            return
          case ip_multi_line_statements
            _execute(ip_consume_eols_and_semicolons)
            _pop_frame
            if ((not (_position < _limit)))
              _throw_syntax_error
            endIf
            _begin_list
            while (((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)))
              _execute(ip_control_structure)
              _pop_frame
              _execute(ip_consume_eols_and_semicolons)
              _pop_frame
            endWhile
            if (disable_output)     _discard_list
            else                    _push_list( Statements(_list_t) )
            return
          case ip_single_line_statements
            _begin_list
            if (_consume(TokenType.EOL))
              if (disable_output)     _discard_list
              else                    _push_list( Statements(_list_t) )
              return
            endIf
            _execute(ip_statement)
            _pop_frame
            while (_consume(TokenType.SYMBOL_SEMICOLON))
              if ((not (_next_t.type == TokenType.EOL)))
                _execute(ip_statement)
                _pop_frame
              endIf
            endWhile
            _execute(ip_must_consume_eols)
            _pop_frame
            if (disable_output)     _discard_list
            else                    _push_list( Statements(_list_t) )
            return
          case ip_control_structure
            if (_next_t.type == TokenType.KEYWORD_LOCAL)
              temporarily _cur_t = _on_t
                _execute(ip_local_declarations)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_BLOCK)
              temporarily _cur_t = _next_t
                _execute(ip_block)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_FOR_EACH)
              temporarily _cur_t = _next_t
                _execute(ip_forEach_loop)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_IF)
              temporarily _cur_t = _next_t
                _execute(ip_if_statement)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_TRY)
              temporarily _cur_t = _next_t
                _execute(ip_try_catch)
                _pop_frame
                return
              endTemporarily
            endIf
            _execute(ip_statement)
            _pop_frame
            return
          case ip_args
            _begin_list
            if (_consume(TokenType.SYMBOL_OPEN_PAREN))
              _execute(ip_consume_eols)
              _pop_frame
              if (_consume(TokenType.SYMBOL_CLOSE_PAREN))
                if (disable_output)     _discard_list
                else                    _push_list( CmdList(_list_t) )
                return
              endIf
              _execute(ip_consume_eols)
              _pop_frame
              while (((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)))
                _execute(ip_arg)
                _pop_frame
                _execute(ip_consume_eols)
                _pop_frame
                _consume(TokenType.SYMBOL_COMMA)
                _execute(ip_consume_eols)
                _pop_frame
              endWhile
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            else
              while ((((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)) and (not (_next_t.type == TokenType.EOL))))
                _execute(ip_arg)
                _pop_frame
                if (_consume(TokenType.SYMBOL_COMMA))
                  _execute(ip_consume_eols)
                  _pop_frame
                endIf
              endWhile
            endIf
            if (disable_output)     _discard_list
            else                    _push_list( Args(_list_t) )
            return
          case ip_arg
            _execute(ip_expression)
            _pop_frame
            return
          case ip_statement
            if (_next_t.type == TokenType.KEYWORD_RETURN)
              temporarily _cur_t = _on_t
                _execute(ip_optional_expression)
                _pop_frame
                if (not disable_output) _push( Return(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_THROW)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not disable_output) _push( Throw(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_NATIVE_HEADER)
              temporarily _cur_t = _next_t
                _execute(ip_native_code_block)
                _pop_frame
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_NATIVE_CODE)
              temporarily _cur_t = _next_t
                _execute(ip_native_code_block)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not disable_output) _push( Preincrement(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not disable_output) _push( Predecrement(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            _execute(ip_expression)
            _pop_frame
            if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( Postincrement(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( Postdecrement(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_EQUALS)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not disable_output) _push( Assign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                return
              endTemporarily
            endIf
            if ((((_position < _limit) and (not (_next_t.type.attributes & TokenType.ATTRIBUTE_STRUCTURAL)?)) and (not (_next_t.type == TokenType.EOL))))
              _execute(ip_args)
              _pop_frame
              this.ip = ip
              store_statement_args
              ip = this.ip
            endIf
            return
          case ip_local_declarations
            _begin_list
            _execute(ip_consume_eols)
            _pop_frame
            _execute(ip_local_declaration)
            _pop_frame
            while (_consume(TokenType.SYMBOL_COMMA))
              _execute(ip_consume_eols)
              _pop_frame
              _execute(ip_local_declaration)
              _pop_frame
            endWhile
            if (disable_output)     _discard_list
            else                    _push_list( CmdList(_list_t) )
            _execute(ip_optional_type)
            _pop_frame
            if (not disable_output) _push( LocalDeclarations(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
            return
          case ip_local_declaration
            if (_next_t.type == TokenType.IDENTIFIER)
              temporarily _cur_t = _on_t
                _execute(ip_optional_initial_value)
                _pop_frame
                if (not disable_output) _push( null, 0 )
                if (not disable_output) _push( Local(_cur_t,_cur_t.content,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
                return
              endTemporarily
            endIf
            if (not _consume(TokenType.IDENTIFIER)) _throw_syntax_error( &expected=TokenType.IDENTIFIER )
            return
          case ip_block
            if (_next_t.type == TokenType.KEYWORD_BLOCK)
              temporarily _cur_t = _on_t
                _execute(ip_multi_line_statements)
                _pop_frame
                if (not _consume(TokenType.KEYWORD_END_BLOCK)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_BLOCK )
              endTemporarily
            endIf
            if (not disable_output) _push( Block(_cur_t,_node_arg(-1)), 1 )
            return
          case ip_try_catch
            if (_next_t.type == TokenType.KEYWORD_TRY)
              temporarily _cur_t = _on_t
                _execute(ip_multi_line_statements)
                _pop_frame
                _execute(ip_catches)
                _pop_frame
                if (not _consume(TokenType.KEYWORD_END_TRY)) _throw_syntax_error( &expected=TokenType.KEYWORD_END_TRY )
                if (not disable_output) _push( Try(_cur_t,_node_arg(-2),_node_arg(-1)->(as Catches)), 2 )
                return
              endTemporarily
            endIf
            return
          case ip_catches
            _begin_list
            while ((_next_t.type == TokenType.KEYWORD_CATCH))
              if (_next_t.type == TokenType.KEYWORD_CATCH)
                temporarily _cur_t = _on_t
                  if (_consume(TokenType.SYMBOL_OPEN_PAREN))
                    _execute(ip_catch_clause)
                    _pop_frame
                    if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
                  else
                    _execute(ip_catch_clause)
                    _pop_frame
                  endIf
                  _execute(ip_multi_line_statements)
                  _pop_frame
                  if (not disable_output) _push( Catch(_cur_t,_string_arg(-3),_node_arg(-2)->(as Type),_node_arg(-1)), 3 )
                endTemporarily
              endIf
            endWhile
            if (disable_output)     _discard_list
            else                    _push_list( Catches(_list_t) )
            return
          case ip_catch_clause
            _save_position
            _execute(ip_identifier)
            _pop_frame
            if (_consume(TokenType.SYMBOL_COLON))
              _discard_position
              _execute(ip_type)
              _pop_frame
            else
              _restore_position
              if (not disable_output) _push( null, 0 )
              _execute(ip_type)
              _pop_frame
            endIf
            return
          case ip_module_path
            _begin_list
            _execute(ip_identifier)
            _pop_frame
            while (_consume(TokenType.SYMBOL_SLASH))
              _execute(ip_identifier)
              _pop_frame
            endWhile
            if (disable_output)     _discard_list
            else                    _push_list( CmdList(_list_t) )
            return
          case ip_uses_attributes
            _begin_list
            if (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
              temporarily _cur_t = _on_t
                while (((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_CLOSE_SQUARE))))
                  _execute(ip_uses_attribute)
                  _pop_frame
                  _consume(TokenType.SYMBOL_COMMA)
                endWhile
                if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
              endTemporarily
            endIf
            if (disable_output)     _discard_list
            else                    _push_list( Attributes(_list_t) )
            return
          case ip_uses_attribute
            if (_next_t.type == TokenType.KEYWORD_EXPORT)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( AttributeExport(_cur_t), 0 )
                return
              endTemporarily
            endIf
            if (_consume_content("noInclude"))
              this.ip = ip
              uses_attribute_no_include
              ip = this.ip
              return
            endIf
            _throw_syntax_error("Illegal 'uses' attribute. Expected any of [export noInclude].")
            return
          case ip_access_args
            if ((not (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)))
              if (not disable_output) _push( null, 0 )
              return
            endIf
            _execute(ip_args)
            _pop_frame
            return
          case ip_optional_expression
            if (((_next_t.type == TokenType.EOL) or (_next_t.type == TokenType.SYMBOL_SEMICOLON)))
              if (not disable_output) _push( null, 0 )
              return
            endIf
            _execute(ip_expression)
            _pop_frame
            return
          case ip_expression
            _execute(ip_op_and_assign)
            _pop_frame
            return
          case ip_op_and_assign
            if (_next_t.type == TokenType.SYMBOL_PLUS_EQUALS)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not disable_output) _push( AddAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                return
              endTemporarily
            endIf
            _execute(ip_logical_xor)
            _pop_frame
            return
          case ip_logical_xor
            _execute(ip_logical_or)
            _pop_frame
            _execute(ip_logical_xor__inner)
            _pop_frame
            return
          case ip_logical_xor__inner
            if (_next_t.type == TokenType.KEYWORD_XOR)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_logical_or)
                _pop_frame
                if (not disable_output) _push( LogicalXor(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_logical_xor__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_logical_or
            _execute(ip_logical_and)
            _pop_frame
            _execute(ip_logical_or__inner)
            _pop_frame
            return
          case ip_logical_or__inner
            if (_next_t.type == TokenType.KEYWORD_OR)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_logical_and)
                _pop_frame
                if (not disable_output) _push( LogicalOr(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_logical_or__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_logical_and
            _execute(ip_comparison)
            _pop_frame
            _execute(ip_logical_and__inner)
            _pop_frame
            return
          case ip_logical_and__inner
            if (_next_t.type == TokenType.KEYWORD_AND)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_comparison)
                _pop_frame
                if (not disable_output) _push( LogicalAnd(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_logical_and__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_comparison
            _execute(ip_reference_comparison)
            _pop_frame
            _execute(ip_comparison__inner)
            _pop_frame
            return
          case ip_comparison__inner
            if (_next_t.type == TokenType.SYMBOL_EQ)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_reference_comparison)
                _pop_frame
                if (not disable_output) _push( CompareEQ(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_comparison__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_NE)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_reference_comparison)
                _pop_frame
                if (not disable_output) _push( CompareNE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_comparison__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_LT)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_reference_comparison)
                _pop_frame
                if (not disable_output) _push( CompareLT(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_comparison__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_GT)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_reference_comparison)
                _pop_frame
                if (not disable_output) _push( CompareGT(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_comparison__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_LE)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_reference_comparison)
                _pop_frame
                if (not disable_output) _push( CompareLE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_comparison__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_GE)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_reference_comparison)
                _pop_frame
                if (not disable_output) _push( CompareGE(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_comparison__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_reference_comparison
            _execute(ip_bitwise_xor)
            _pop_frame
            if (_next_t.type == TokenType.KEYWORD_IS)
              temporarily _cur_t = _on_t
                if (_consume(TokenType.KEYWORD_NOT))
                  _execute(ip_reference_comparison)
                  _pop_frame
                  if (not disable_output) _push( IsNot(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                  return
                else
                  _execute(ip_reference_comparison)
                  _pop_frame
                  if (not disable_output) _push( Is(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                  return
                endIf
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_INSTANCE_OF)
              temporarily _cur_t = _on_t
                _execute(ip_type)
                _pop_frame
                if (not disable_output) _push( InstanceOf(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_IS_COMPOUND)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( IsCompound(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_IS_PRIMITIVE)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( IsPrimitive(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_IS_REFERENCE)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( IsReference(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_IS_TYPE)
              temporarily _cur_t = _on_t
                _execute(ip_type)
                _pop_frame
                if (not disable_output) _push( IsType(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
                return
              endTemporarily
            endIf
            return
          case ip_bitwise_xor
            _execute(ip_bitwise_or)
            _pop_frame
            _execute(ip_bitwise_xor__inner)
            _pop_frame
            return
          case ip_bitwise_xor__inner
            if (_next_t.type == TokenType.SYMBOL_TILDE)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_bitwise_or)
                _pop_frame
                if (not disable_output) _push( BitwiseXor(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_bitwise_xor__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_bitwise_or
            _execute(ip_bitwise_and)
            _pop_frame
            _execute(ip_bitwise_or__inner)
            _pop_frame
            return
          case ip_bitwise_or__inner
            if (_next_t.type == TokenType.SYMBOL_VERTICAL_BAR)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_bitwise_and)
                _pop_frame
                if (not disable_output) _push( BitwiseOr(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_bitwise_or__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_bitwise_and
            _execute(ip_bitwise_shift)
            _pop_frame
            _execute(ip_bitwise_and__inner)
            _pop_frame
            return
          case ip_bitwise_and__inner
            if (_next_t.type == TokenType.SYMBOL_AMPERSAND)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_bitwise_shift)
                _pop_frame
                if (not disable_output) _push( BitwiseAnd(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_bitwise_and__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_bitwise_shift
            _execute(ip_add_subtract)
            _pop_frame
            _execute(ip_bitwise_shift__inner)
            _pop_frame
            return
          case ip_bitwise_shift__inner
            if (_next_t.type == TokenType.SYMBOL_LEFT_SHIFT)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_add_subtract)
                _pop_frame
                if (not disable_output) _push( ShiftLeft(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_bitwise_shift__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_RIGHT_SHIFT)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_add_subtract)
                _pop_frame
                if (not disable_output) _push( ShiftRight(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_bitwise_shift__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_RIGHT_SHIFT_X)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_add_subtract)
                _pop_frame
                if (not disable_output) _push( ShiftRightX(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_bitwise_shift__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_add_subtract
            _execute(ip_multiply_divide_mod)
            _pop_frame
            _execute(ip_add_subtract__inner)
            _pop_frame
            return
          case ip_add_subtract__inner
            if (_next_t.type == TokenType.SYMBOL_PLUS)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_multiply_divide_mod)
                _pop_frame
                if (not disable_output) _push( Add(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_add_subtract__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_MINUS)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_multiply_divide_mod)
                _pop_frame
                if (not disable_output) _push( Subtract(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_add_subtract__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_multiply_divide_mod
            _execute(ip_power)
            _pop_frame
            _execute(ip_multiply_divide_mod__inner)
            _pop_frame
            return
          case ip_multiply_divide_mod__inner
            if (_next_t.type == TokenType.SYMBOL_ASTERISK)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_power)
                _pop_frame
                if (not disable_output) _push( Multiply(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_multiply_divide_mod__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_SLASH)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_power)
                _pop_frame
                if (not disable_output) _push( Divide(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_multiply_divide_mod__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_PERCENT)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_power)
                _pop_frame
                if (not disable_output) _push( Mod(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_multiply_divide_mod__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_power
            _execute(ip_pre_unary)
            _pop_frame
            _execute(ip_power__inner)
            _pop_frame
            return
          case ip_power__inner
            if (_next_t.type == TokenType.SYMBOL_CARET)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_pre_unary)
                _pop_frame
                if (not disable_output) _push( Power(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_power__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_pre_unary
            if (_next_t.type == TokenType.SYMBOL_BANG)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_pre_unary)
                _pop_frame
                if (not disable_output) _push( BitwiseNot(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_NOT)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_pre_unary)
                _pop_frame
                if (not disable_output) _push( LogicalNot(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_MINUS)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_pre_unary)
                _pop_frame
                if (not disable_output) _push( Negate(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_pre_unary)
                _pop_frame
                if (not disable_output) _push( Preincrement(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
              temporarily _cur_t = _on_t
                _consume_eols
                _execute(ip_pre_unary)
                _pop_frame
                if (not disable_output) _push( Predecrement(_cur_t,_node_arg(-1)), 1 )
                return
              endTemporarily
            endIf
            _execute(ip_post_unary)
            _pop_frame
            return
          case ip_post_unary
            _execute(ip_access)
            _pop_frame
            _execute(ip_post_unary__inner)
            _pop_frame
            return
          case ip_post_unary__inner
            if (_next_t.type == TokenType.SYMBOL_PLUS_PLUS)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( Postincrement(_cur_t,_node_arg(-1)), 1 )
                _execute(ip_post_unary__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_MINUS_MINUS)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( Postdecrement(_cur_t,_node_arg(-1)), 1 )
                _execute(ip_post_unary__inner)
                _pop_frame
                return
              endTemporarily
            endIf
            return
          case ip_access
            _execute(ip_term)
            _pop_frame
            _execute(ip_access_inner)
            _pop_frame
            return
          case ip_access_inner
            if (_next_t.type == TokenType.SYMBOL_PERIOD)
              temporarily _cur_t = _on_t
                _execute(ip_identifier)
                _pop_frame
                _execute(ip_access_args)
                _pop_frame
                if (not disable_output) _push( ContextAccess(_cur_t,_node_arg(-3),_string_arg(-2),_node_arg(-1)), 3 )
                _execute(ip_access_inner)
                _pop_frame
              endTemporarily
            elseIf (_next_t.type == TokenType.SYMBOL_ARROW)
              temporarily _cur_t = _on_t
                _execute(ip_type)
                _pop_frame
                if (not disable_output) _push( ConvertToType(_cur_t,_node_arg(-2),_node_arg(-1)->(as Type)), 2 )
                _execute(ip_access_inner)
                _pop_frame
              endTemporarily
            elseIf (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
                if (not disable_output) _push( IndexedAccess(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
                _execute(ip_access_inner)
                _pop_frame
              endTemporarily
            elseIf (_next_t.type == TokenType.SYMBOL_DOT_OPEN_SQUARE)
              temporarily _cur_t = _on_t
                _execute(ip_consume_eols)
                _pop_frame
                if (_consume(TokenType.SYMBOL_CLOSE_SQUARE))
                  _execute(ip_access_inner)
                  _pop_frame
                  return
                endIf
                _begin_list
                _execute(ip_context_block_command)
                _pop_frame
                _execute(ip_consume_eols)
                _pop_frame
                while (_consume(TokenType.SYMBOL_COMMA))
                  _execute(ip_context_block_command)
                  _pop_frame
                  _execute(ip_consume_eols)
                  _pop_frame
                endWhile
                if (not _consume(TokenType.SYMBOL_CLOSE_SQUARE)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_SQUARE )
                if (disable_output)     _discard_list
                else                    _push_list( CmdList(_list_t) )
                if (not disable_output) _push( ContextBlock(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
              endTemporarily
            endIf
            return
          case ip_context_block_command
            if (not disable_output) _push( ContextBlockContext(_cur_t), 0 )
            _execute(ip_identifier)
            _pop_frame
            _execute(ip_access_args)
            _pop_frame
            if (not disable_output) _push( ContextAccess(_cur_t,_node_arg(-3),_string_arg(-2),_node_arg(-1)), 3 )
            _execute(ip_access_inner)
            _pop_frame
            return
          case ip_term
            if (_next_t.type == TokenType.STRING)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralString(_cur_t,_cur_t.content), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.INTEGER)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralInteger(_cur_t,_cur_t.content,_string_to_Integer("10")), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.HEX_INTEGER)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralInteger(_cur_t,_cur_t.content,_string_to_Integer("16")), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.BINARY_INTEGER)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralInteger(_cur_t,_cur_t.content,_string_to_Integer("2")), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.OCTAL_INTEGER)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralInteger(_cur_t,_cur_t.content,_string_to_Integer("8")), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.REAL_NUMBER)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralReal(_cur_t,_string_to_Real(_cur_t.content)), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.CHARACTER)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralCharacter(_cur_t,_string_to_Character(_cur_t.content)), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.IDENTIFIER)
              temporarily _cur_t = _next_t
                _execute(ip_id_or_type)
                _pop_frame
                _execute(ip_access_args)
                _pop_frame
                if (not disable_output) _push( Access(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.PLACEHOLDER)
              temporarily _cur_t = _next_t
                _execute(ip_id_or_type)
                _pop_frame
                _execute(ip_access_args)
                _pop_frame
                if (not disable_output) _push( Access(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_TRUE)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralLogical(_cur_t,_string_to_Logical("true")), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_FALSE)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralLogical(_cur_t,_string_to_Logical("false")), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_NULL)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralNull(_cur_t), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_PI)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( LiteralPi(_cur_t), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_THIS)
              temporarily _cur_t = _on_t
                if (not disable_output) _push( This(_cur_t), 0 )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_WHICH)
              temporarily _cur_t = _next_t
                _execute(ip_inline_which)
                _pop_frame
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.SYMBOL_OPEN_PAREN)
              temporarily _cur_t = _on_t
                _execute(ip_expression)
                _pop_frame
                if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
                return
              endTemporarily
            endIf
            if (_next_t.type == TokenType.KEYWORD_NATIVE)
              temporarily _cur_t = _on_t
                _execute(ip_native_code)
                _pop_frame
                return
              endTemporarily
            endIf
            _throw_syntax_error
            return
          case ip_native_code
            if (_consume(TokenType.SYMBOL_OPEN_PAREN))
              _execute(ip_string)
              _pop_frame
              if (not _consume(TokenType.SYMBOL_CLOSE_PAREN)) _throw_syntax_error( &expected=TokenType.SYMBOL_CLOSE_PAREN )
            else
              _execute(ip_string)
              _pop_frame
            endIf
            if (_consume(TokenType.SYMBOL_ARROW))
              _execute(ip_type)
              _pop_frame
              if (not disable_output) _push( NativeExpression(_cur_t,_string_arg(-2),_node_arg(-1)), 2 )
              return
            else
              if (not disable_output) _push( NativeStatement(_cur_t,_string_arg(-1)), 1 )
              return
            endIf
          case ip_preprocess
            while ((_position < _limit))
              _execute(ip_process_another)
              _pop_frame
            endWhile
            if (not disable_output) _push( null, 0 )
            return
          case ip_process_another
            if (_next_t.type == TokenType.META_DEFINE)
              temporarily _cur_t = _on_t
                this.ip = ip
                mark_token
                ip = this.ip
                if (_next_t.type == TokenType.IDENTIFIER)
                  temporarily _cur_t = _on_t
                    buffer.clear.print ""
                    this.ip = ip
                    collect_token_string
                    ip = this.ip
                    while (((_position < _limit) and (not (_next_t.type == TokenType.EOL))))
                      this.ip = ip
                      collect_next_token
                      ip = this.ip
                    endWhile
                    this.ip = ip
                    create_definition
                    ip = this.ip
                  endTemporarily
                else
                  _throw_syntax_error("Identifier expected.")
                endIf
              endTemporarily
            elseIf (_next_t.type == TokenType.META_INCLUDE)
              temporarily _cur_t = _on_t
                _execute(ip_collect_meta_filepath)
                _pop_frame
                this.ip = ip
                include_filepath
                ip = this.ip
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.KEYWORD_USES)
              temporarily _cur_t = _on_t
                this.ip = ip
                rewrite_cur_token
                ip = this.ip
                _execute(ip_collect_meta_filepath)
                _pop_frame
                _save_position
                _execute(ip_uses_attributes)
                _pop_frame
                _restore_position
                this.ip = ip
                uses_filepath
                ip = this.ip
                return
              endTemporarily
            elseIf (_next_t.type == TokenType.IDENTIFIER)
              temporarily _cur_t = _on_t
                this.ip = ip
                insert_definition
                ip = this.ip
                return
              endTemporarily
            endIf
            this.ip = ip
            rewrite_token
            ip = this.ip
            return
          case ip_collect_meta_filepath
            this.ip = ip
            mark_token
            ip = this.ip
            buffer.clear.print ""
            if (_next_t.type == TokenType.STRING)
              temporarily _cur_t = _on_t
                this.ip = ip
                collect_token_string
                ip = this.ip
              endTemporarily
            else
              while ((((_position < _limit) and (not (_next_t.type == TokenType.SYMBOL_OPEN_SQUARE))) and (not (_next_t.type == TokenType.EOL))))
                if (_next_t.type == TokenType.IDENTIFIER)
                  temporarily _cur_t = _on_t
                    this.ip = ip
                    collect_token_string
                    ip = this.ip
                  endTemporarily
                elseIf (_next_t.type == TokenType.INTEGER)
                  temporarily _cur_t = _on_t
                    this.ip = ip
                    collect_token_string
                    ip = this.ip
                  endTemporarily
                elseIf (_next_t.type == TokenType.REAL_NUMBER)
                  temporarily _cur_t = _on_t
                    this.ip = ip
                    collect_token_string
                    ip = this.ip
                  endTemporarily
                elseIf (_next_t.type == TokenType.SYMBOL_TILDE)
                  temporarily _cur_t = _on_t
                    this.ip = ip
                    collect_token_string
                    ip = this.ip
                  endTemporarily
                elseIf (_next_t.type == TokenType.SYMBOL_SLASH)
                  temporarily _cur_t = _on_t
                    this.ip = ip
                    collect_token_string
                    ip = this.ip
                  endTemporarily
                elseIf (_next_t.type == TokenType.SYMBOL_COLON)
                  temporarily _cur_t = _on_t
                    this.ip = ip
                    collect_token_string
                    ip = this.ip
                  endTemporarily
                elseIf (_next_t.type == TokenType.SYMBOL_PERIOD)
                  temporarily _cur_t = _on_t
                    this.ip = ip
                    collect_token_string
                    ip = this.ip
                  endTemporarily
                elseIf (_next_t.type == TokenType.SYMBOL_BACKSLASH)
                  temporarily _cur_t = _on_t
                    this.ip = ip
                    collect_token_string
                    ip = this.ip
                  endTemporarily
                else
                  _throw_syntax_error("Unsupported filepath character. Put the filepath in quotes.")
                endIf
              endWhile
            endIf
            return
          case ip_additional_node_types
            if (not disable_output) _push( AddAndAssignLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
            if (not disable_output) _push( CallDynamicMethod(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
            if (not disable_output) _push( CallGlobalMethod(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( CallProcedure(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( CallRoutine(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( CallStaticMethod(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
            if (not disable_output) _push( CallThisDynamicMethod(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( CallThisStaticMethod(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( Compare(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
            if (not disable_output) _push( Conditional(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
            if (not disable_output) _push( ControlStructure(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
            if (not disable_output) _push( Convert(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( ConvertToByte(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( ConvertToCharacter(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( ConvertToInt32(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( ConvertToInt64(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( ConvertToLogical(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( ConvertToReal32(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( ConvertToReal64(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( CreateObject(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)->(as Local)), 2 )
            if (not disable_output) _push( CreateCompound(_cur_t), 0 )
            if (not disable_output) _push( DummyInitialValue(_cur_t), 0 )
            if (not disable_output) _push( ForEachControl(_cur_t,_string_arg(-3),_node_arg(-2)->(as ForEachAt),_node_arg(-1)->(as ForEachCollection)), 3 )
            if (not disable_output) _push( Iterator(_cur_t,_node_arg(-4),_node_arg(-3),_node_arg(-2),_node_arg(-1)), 4 )
            if (not disable_output) _push( GetLocal(_cur_t,_node_arg(-1)->(as Local)), 1 )
            if (not disable_output) _push( GetProperty(_cur_t,_node_arg(-2),_node_arg(-1)->(as Property)), 2 )
            if (not disable_output) _push( GetThisProperty(_cur_t,_node_arg(-1)->(as Property)), 1 )
            if (not disable_output) _push( GetSingleton(_cur_t,_node_arg(-1)->(as Type)), 1 )
            if (not disable_output) _push( Literal(_cur_t), 0 )
            if (not disable_output) _push( LiteralInt32(_cur_t,_integer_arg(-1)), 1 )
            if (not disable_output) _push( LiteralInt64(_cur_t,_integer_arg(-1)), 1 )
            if (not disable_output) _push( LocalScope(_cur_t), 0 )
            if (not disable_output) _push( NativeProperty(_cur_t,_string_arg(-1)), 1 )
            if (not disable_output) _push( OpAndAssign(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
            if (not disable_output) _push( Procedure(_cur_t,_string_arg(-5),_node_arg(-4)->(as Parameters),_node_arg(-3)->(as Type),_node_arg(-2)->(as Attributes),_node_arg(-1)->(as LocalScope)), 5 )
            if (not disable_output) _push( Range(_cur_t,_node_arg(-2),_node_arg(-1)), 2 )
            if (not disable_output) _push( ReturnOnException(_cur_t), 0 )
            if (not disable_output) _push( SetLocal(_cur_t,_node_arg(-2)->(as Local),_node_arg(-1)), 2 )
            if (not disable_output) _push( SetProperty(_cur_t,_node_arg(-3),_node_arg(-2)->(as Property),_node_arg(-1)), 3 )
            if (not disable_output) _push( SetThisProperty(_cur_t,_node_arg(-2)->(as Property),_node_arg(-1)), 2 )
            if (not disable_output) _push( Stepper(_cur_t,_node_arg(-1)), 1 )
            if (not disable_output) _push( TypeContext(_cur_t,_node_arg(-1)->(as Type)), 1 )
            if (not disable_output) _push( CreateObject(_cur_t,_node_arg(-2)->(as Type),_node_arg(-1)), 2 )
            return
          others
            return
        endWhich
      endLoop
endClass

class ParserPosition( position:Int32, cmd_stack_count:Int32, cur_t:Token ) [compound];
