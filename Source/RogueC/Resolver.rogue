module Rogue
uses Utility/WorkList

class Resolver : Visitor
  PROPERTIES
    this_module    : Module
    this_type      : Type
    this_procedure : Procedure

    visible_locals    = Local[]
    visible_locals_fp = Int32[]
    control_stack     = ControlStructure[]
    control_stack_fp  = Int32[]

    current_statements_rewriter : ListRewriter<<Cmd>>

    autoname_index = 0

  METHODS
    method init( this_module )

    method visit( this_type, this_procedure )
      if (this_procedure.is_resolved) return
      this_procedure.is_resolved = true
      autoname_index = 0
      visit( this_procedure )

    method autoname( base:String )->String
      local result = "_auto_$_$"(base,autoname_index)
      ++autoname_index
      return result

    method find_local( name:String )->Local
      forEach (v in visible_locals step -1)
        if (v.name == name) return v
      endForEach
      return null

    method on( cmd:Access )->Cmd
      cmd.args = visit( cmd.args )
      return resolve_access( cmd.t, null, cmd.name, cmd.args )

    method on( cmd:Assign )->Cmd
      local new_value = visit( cmd.new_value ).require_value
      return cmd.target.resolve_assignment( cmd.t, new_value, this )

    method on( cmd:Block )->Cmd
      return visit( ControlStructure(cmd.t, cmd.statements, ControlType.BLOCK) )

    method on_visit( cmd:Binary )
      visit_children( cmd )
      local left = cmd.left
      local right = cmd.right
      local left_type = left.require_type
      local right_type = right.require_type
      local result_type = Cmd.common_op_type( left_type, right_type )
      if (left_type is not result_type) cmd.left = validate( result_type.cmd_cast(left) )
      if (right_type is not result_type) cmd.right = validate( result_type.cmd_cast(right) )
      # on_validate() will be called after this method returns

    method on( cmd:ContextAccess )->Cmd
      visit( cmd.args )
      return resolve_access( cmd.t, cmd.context, cmd.name, cmd.args )

    method on( cmd:ControlStructure )->Cmd
      push_scope( cmd )
      visit_content( cmd )
      pop_scope
      return cmd

    method on( cmd:ForEach )->Cmd
      local iterator = Iterator( cmd.t, cmd.statements, ControlType.FOR_EACH )
      cmd.condition.resolve_foreach( this, cmd, iterator )
      return visit( iterator )

    method on( cmd:LocalDeclarations )->Cmd
      if (cmd.@type)
        # local a, b=x, c : Type
        #   ->
        # local a:Type, b=x:Type, c:Type
        local type = cmd.@type->Type
        cmd.type = type
        (forEach in cmd.declarations)->(as Local).type = type
      else
        # Infer any missing types.
        forEach (v in cmd.declarations)
          block v = v->(as Local)
            if (v.initial_value)
              v.initial_value = visit( v.initial_value ).require_value
              if (v.@type) v.initial_value = visit( v.initial_value.cmd_cast_to(v.@type) )
              else         v.type = v.initial_value.type
            elseIf (not v.@type)
              throw v.t.error( "Local variable declarations must have an initial value assignment or an assigned ': Type'." )
            endIf
          endBlock
        endForEach
      endIf

      forEach (decl in cmd.declarations)
        local v = decl->(as Local)
        this_procedure.locals.add( v )
        assert control_stack.count
        control_stack.last.locals.add( v )
        visible_locals.add( v )
      endForEach

      local result : Statements
      local is_multiple_declaration = (cmd.declarations.count > 1)
      if (is_multiple_declaration) result = Statements( cmd.t )
      forEach (decl in cmd.declarations)
        local v = decl->(as Local)
        if (v.initial_value)
          local cmd_assign = visit( Assign(v.t, Access(v.t,v.name), v.initial_value) )
          if (is_multiple_declaration) result.add( cmd_assign )
          else                         return cmd_assign
        endIf
      endForEach

      return null

    method on( cmd:NativeHeader )->Cmd
      this_module.native_headers.add( cmd.content )
      return null

    method on( cmd:NativeCode )->Cmd
      this_module.native_code.add( cmd.content )
      return null

    method on( cmd:AddAndAssign )->Cmd
      return validate( cmd.target.resolve_add_and_assign(visit(cmd.operand).require_value,this) )

    method on_visit( cmd:Procedure )
      visible_locals_fp.add( visible_locals.count )
      forEach (p in cmd.parameters)
        visible_locals.add( p->(as Local) )
      endForEach

      visit_children( cmd )

      visible_locals.discard_from( visible_locals_fp.remove_last )

    method pop_scope
      control_stack.discard_from( control_stack_fp.remove_last )
      visible_locals.discard_from( visible_locals_fp.remove_last )

    method push_scope( cmd:ControlStructure )
      visible_locals_fp.add( visible_locals.count )
      control_stack_fp.add( control_stack.count )
      control_stack.add( cmd )
      visible_locals.add( forEach in cmd.locals )

    method on( cmd:Print )->Cmd
      which (cmd.args.count)
        case 0: throw cmd.t.error( "One or more arguments expected." )
        case 1:
          local arg = visit( cmd.args.first )
          return visit( arg.require_type.cmd_print(arg) )
        others
          local result = Statements( cmd.t )
          result.add( Print(cmd.t,forEach in cmd.args) )
          return visit( result )
      endWhich

      #{
      forEach (arg in rewriter=cmd.args.list.rewriter)
        arg = validate( Description(arg.t,arg) ).require_value
        if (arg) rewriter.write( arg )
      endForEach

      if (cmd.args.count == 0) throw cmd.t.error( "One or more arguments expected." )
      }#

    method on( cmd:Println )->Cmd
      which (cmd.args.count)
        case 0
          return PrintNewline( cmd.t )
        others
          local result = Statements( cmd.t )
          result.add( Print(cmd.t,Args(cmd.t,forEach in cmd.args)) )
          result.add( PrintNewline(cmd.t) )
          return visit( result )
      endWhich

      #{
      forEach (arg in rewriter=cmd.args.list.rewriter)
        arg = validate( Description(arg.t,arg) ).require_value
        if (arg) rewriter.write( arg )
      endForEach
      }#

      #{
    method on( cmd:Return )->Cmd
      if (cmd.result) return visit( ReturnResult(cmd.t,cmd.result) )
      return cmd

    method on_visit( cmd:ReturnResult )
      visit_children( cmd )
      cmd.result.require_value

    method on_validate( cmd:RightShift )->Cmd
      return validate( cmd.left.type.cmd_right_shift(cmd.t, cmd.left, cmd.right) )

    method on_validate( cmd:RightShiftX )->Cmd
      return validate( cmd.left.type.cmd_right_shift_x(cmd.t, cmd.left, cmd.right) )
}#

    method on_visit( cmd:Statements )
      temporarily current_statements_rewriter = cmd.list.rewriter
        forEach (statement in current_statements_rewriter)
          statement = visit( statement )
          if (statement)
            if (statement.type) statement = DiscardResult( statement.t, statement )
            current_statements_rewriter.write( statement )
          endIf
        endForEach
      endTemporarily

#{
    method on_validate( cmd:Subtract )->Cmd
      return validate( cmd.left.type.cmd_subtract(cmd.t, cmd.left, cmd.right) )
      }#

    method on_visit( cmd:Unary )
      cmd.operand = visit( cmd.operand )
      local type = cmd.require_type
      if (type.is_primitive)
        local op_type = Cmd.common_op_type( type, Program.type_Int32 )
        if (type is not op_type) cmd.operand = validate( cmd.cmd_cast_to(op_type) )
      endIf

      #{
    method on_visit( cmd:While )
      visit_children( cmd )
      cmd.condition.require_value

    method resolve( v:Local )
      if (v.initial_value)
        v.initial_value = visit( v.initial_value ).require_value
        if (not v.type) v.type = v.initial_value.type
      endIf
}#

    method resolve_access( t:Token, context:Cmd, name:String, args:Cmd, &suppress_error )->Cmd
      local m = this_module
      if (name.contains("::"))
        local m_name = name.before_last("::")
        m = Program.modules[ m_name ]
        if (not m) throw t.error( "No such module '$'."(m_name) )
        name .= after_last("::")
      endIf

      temporarily this_module = m

        local type_context : Type
        local is_global = false

        if (context)
          context = visit( context )
          is_global = context.is_type_context
          type_context = context.require_type

          #if (not args)
          #  if (type_context is Program.type_Value)
          #    if (name == "x" or name == "y")
          #      context = validate( CastValueToXY(t,context) )
          #      type_context = Program.type_XY
          #    endIf
          #  endIf

          #  if (type_context is Program.type_XY)
          #    if (name == "x") return validate( XYGetX(t, context) )
          #    if (name == "y") return validate( XYGetY(t, context) )
          #  endIf
          #endIf

        else
          local type = this_module.find_type( name, &extended_search )
          if (type and not args)
            #{
            if (type.is_singleton)
              return GetSingleton(t,type)
            else
              if (type.name.ends_with(']'))
                return resolve_access( t, null, type.name, CmdList(t) )
              else
            }#
                return TypeContext(t,type)
            #{
              endIf
            endIf
            }#
          endIf

          type_context = this_type  # may be null
          if (args)
            # Call or constructor
            if (type)
              #{
              if (name == "XY")
                forEach (arg at i in args)
                  args[i] = validate( arg.cmd_cast_to(Program.type_Real64) )
                endForEach
                which (args.count)
                  case 0: return validate( CreateXY0(t) )
                  case 1: return validate( CreateXY1(t,args[0]) )
                  case 2: return validate( CreateXY2(t,args[0],args[1]) )
                  others: throw t.error( "0, 1, or 2 arguments expected for XY() constructor." )
                endWhich
              endIf
              }#
              return validate( cmd_create_object(t,type,args) )
            endIf
          else
            local v = find_local( name )
            if (v) return validate( GetLocal(t,v) )
          endIf
        endIf

        local match = find_procedure( t, type_context, context, name, args, &require_global=is_global, &suppress_error )

        if (match)
          if (not args and match.min_args == 0) args = CmdList(t)
          cast_args_to_parameter_types( args, match )
          return validate( match.cmd_call(context,args) )
        endIf

        #if (not is_global)
        #  # TODO: update to allow global properties
        #  if (not args and type_context)
        #    local p = type_context.find_property( name )
        #    if (p)
        #      if (context) return validate( GetProperty(t,context,p) )
        #      else         return validate( GetThisProperty(t,p) )
        #    endIf
        #  endIf
        #endIf

        if (suppress_error) return null->(as Cmd)

        find_procedure( t, type_context, context, name, args, &require_global=is_global )  # throw an error

      endTemporarily
      return null  # never reached


    method cmd_create_object( t:Token, type_context:Type, args:Cmd )->Cmd
      local m_init = find_procedure( t, type_context, null, "init", args, &suppress_error )->(as Method)
      if (m_init)
        if (not args and m_init.min_args == 0) args = CmdList(t)
        cast_args_to_parameter_types( args, m_init )
        return CreateObject( t, type_context, m_init, args )
      else
        local mesg : String
        use Candidates
          type_context.collect_methods( "create", Candidates.list )
          type_context.collect_methods( "init", Candidates.list )

          if (args.count == 0 and Candidates.count == 0)
            # No constructors available and no constructor required.
            return CreateObject( t, type_context, null, null )
          endIf

          mesg = "No exact match for object constructor $("(type_context)
          forEach (arg at i in args)
            if (i > 0) mesg += ','
            mesg += arg.require_type
          endForEach
          mesg += "). Candidates:\n\n"
          if (Candidates.count)
            forEach (m in Candidates)
              mesg += "  $$" (type_context,m.signature.from_first('('))
            endForEach
          else
            mesg += "  $()"(type_context)
          endIf
        endUse
        throw t.error( mesg )
      endIf

    method cast_args_to_parameter_types( args:Cmd, proc:Procedure )
      # And fill in default values
      proc.resolve

      if (not args) return

      while (args.count < proc.parameters.count)
        args.add( proc.parameters[args.count]->(as Local).initial_value.cloned )
      endWhile

      forEach (arg at i in args)
        args[i] = validate( arg.cmd_cast_to(proc.parameters[i].type) )
      endForEach

    method find_procedure( t:Token, type_context:Type, context:Cmd, name:String, args:Cmd,
        &require_global, &suppress_error )->Procedure
      # 'context' is only passed for error description purposes.
      visit( args )  # resolve args to determine types

      local error_message : String
      use Candidates
        if (type_context)
          type_context.collect_methods( name, Candidates.list, &=require_global )
        else
          this_module.collect_routines( name, Candidates.list )
        endIf
        local result = refine_candidates( type_context, args )
        if (result or suppress_error) return result

        # Throw an error
        local sig = name
        if (args)
          sig += '('
          forEach (arg at i in args)
            if (i > 0) sig += ','
            sig += arg.require_type
          endForEach
          sig += ')'
        endIf

        local mesg : String
        if (args)
          which (Candidates.count)
            case 0
              mesg = "No such "
              if (require_global) mesg += "global "
              if (context)        mesg += "method "
              elseIf (this_type)  mesg += "method or routine "
              else                mesg += "routine "

              if (context)        mesg += context.type + "."
              elseIf (this_type)  mesg += this_type + "."

              mesg += sig + '.'

            case 1
              mesg = "Call to "
              if (context)       mesg += context.type + "."
              elseIf (this_type) mesg += this_type + "."

              mesg += sig
              mesg += " has arguments that are incompatible with the best candidate:\n\n"
              mesg += "  " + Candidates[0].context_signature

            others
              mesg = "Ambiguous call to "
              if (require_global) mesg += "global "
              if (context)        mesg += context.type + "."
              elseIf (this_type)  mesg += this_type + "."

              mesg += sig
              mesg += ". Candidates:\n\n"
              forEach (m in Candidates)
                mesg += "  " + m.context_signature
              endForEach

          endWhich

        else
          local g = which{ require_global:"global " || "" }
          if (context)
            if (args) mesg = "No such $method '$' exists in type '$'." (g,sig,context.type)
            else      mesg = "No such $property or method '$' exists in type '$'." (g,sig,context.type)
          elseIf (this_type)
            if (args) mesg = "No such $method or routine '$'."(g,sig)
            else      mesg = "No such $variable, method, or routine '$'."(g,sig)
          else
            if (args) mesg = "No such $routine '$'."(g,sig)
            else      mesg = "No such $variable or routine '$'."(g,sig)
          endIf

        endIf

        error_message = mesg
      endUse

      throw t.error( error_message )

    method refine_candidates( type_context:Type, args:Cmd )->Procedure
      local arg_count = which{ args:args.count || 0 }

      # Filter out incorrect number of args
      forEach (m in Candidates)
        if (m.accepts_arg_count(arg_count)) Candidates.keep m
      endForEach
      if (Candidates.found_match) return Candidates.match
      if (not Candidates.refine) return null

      # Filter out candidates that don't have the same module context as the first candidate
      local priority_module_context = Candidates[0].module_context
      forEach (m in Candidates)
        if (m.module_context is priority_module_context) Candidates.keep m
      endForEach
      if (Candidates.found_match) return Candidates.match
      if (not Candidates.refine) return null

      return null
endClass

#{
augment Procedure
  PROPERTIES
    local_stack_slots : Int32  # in addition to args already on stack

  METHODS
    method find_local( name:String )->Local
      forEach (v in locals step -1)
        if (v.name == name) return v
      endForEach
      return null
endAugment

# Add
augment
  METHODS
    method Type.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be added."(name) )

    method TypeInt32.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddInt32( t, lhs, rhs )

    method TypeReal64.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddReal64( t, lhs, rhs )

    method TypeString.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddString( t, lhs, rhs )

    method TypeValue.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddValue( t, lhs, rhs )

endAugment
}#

# AddAndAssign
augment
  METHODS
    method Cmd.resolve_add_and_assign( operand:Cmd, resolver:Resolver )->Cmd
      throw t.error( "Illegal assignment target." )

    method Access.resolve_add_and_assign( operand:Cmd, resolver:Resolver )->Cmd
      if (args) prior.resolve_add_and_assign( operand, resolver )
      operand = resolver.visit( operand )
      local operand_type = operand.require_type

      local v = resolver.find_local( name )
      if (v)
        if (operand_type is not v.type) operand = resolver.validate(operand.cmd_cast_to(v.type))
        return resolver.validate( AddAndAssignLocal(t,v,operand) )
      endIf

      throw t.error( "[TODO] Unimplemented assignment target." )
endAugment

# Assignment
augment
  METHODS
    method Cmd.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      throw t.error( "Illegal target for assignment." )

    method Access.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      if (not args)
        local v = resolver.find_local( name )
        if (v) return resolver.validate( SetLocal(t,v,new_value) )

        #local p = resolver.this_type.find_property( name )
        #if (p) return resolver.validate( SetThisProperty(t,p,new_value) )
      endIf
      throw t.error( "Illegal target for assignment." )

    method IndexAccess.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      return resolver.visit( ContextAccess(t, context, "set", CmdList(t,index,new_value)) )
endAugment

# cmd_print()
augment
  METHODS
    method Cmd.cmd_print( operand:Cmd )->Cmd
      throw operand.t.error( "[INTERNAL] $.cmd_print() is undefined." (type_name) )

    method TypeLogical.cmd_print( operand:Cmd )->Cmd
      return PrintLogical( operand.t, operand )

    method TypeInt32.cmd_print( operand:Cmd )->Cmd
      return PrintInt32( operand.t, operand )

    method TypeReal64.cmd_print( operand:Cmd )->Cmd
      return PrintReal64( operand.t, operand )

    method TypeString.cmd_print( operand:Cmd )->Cmd
      return PrintString( operand.t, operand )
endAugment


#{
# BitwiseAnd
augment
  METHODS
    method Type.cmd_bitwise_and( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bitwise-AND'd."(name) )

    method TypeInt32.cmd_bitwise_and( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseAndInt32( t, lhs, rhs )

    method TypeValue.cmd_bitwise_and( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseAndValue( t, lhs, rhs )

endAugment

# BitwiseOr
augment
  METHODS
    method Type.cmd_bitwise_or( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bitwise-OR'd."(name) )

    method TypeInt32.cmd_bitwise_or( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseOrInt32( t, lhs, rhs )

    method TypeValue.cmd_bitwise_or( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseOrValue( t, lhs, rhs )

endAugment

# BitwiseOrAndAssign
augment
  METHODS
    method Cmd.resolve_bitwise_or_and_assign( t:Token, operand:Cmd, resolver:Resolver )->Cmd
      throw t.error( "Illegal target for '|='." )

    method Access.resolve_bitwise_or_and_assign( t:Token, operand:Cmd, resolver:Resolver )->Cmd
      if (not args)
        local v = resolver.find_local( name )
        if (v) return resolver.validate( BitwiseOrAndAssignLocal(t,v,operand) )

        local p = resolver.this_type.find_property( name )
        if (p) return resolver.validate( BitwiseOrAndAssignThisProperty(t,p,operand) )
      endIf
      throw t.error( "Illegal target for '|='." )

    method ContextAccess.resolve_bitwise_or_and_assign( t:Token, operand:Cmd, resolver:Resolver )->Cmd
      if (not args)
        context = resolver.visit( context )
        local p = context.require_type.find_property( name )
        if (p) return resolver.validate( BitwiseOrAndAssignProperty(t,context,p,operand) )
      endIf
      throw t.error( "Illegal target for '|='." )

endAugment

# BitwiseXor
augment
  METHODS
    method Type.cmd_bitwise_xor( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bitwise-XOR'd."(name) )

    method TypeInt32.cmd_bitwise_xor( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseXorInt32( t, lhs, rhs )

    method TypeValue.cmd_bitwise_xor( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseXorValue( t, lhs, rhs )

endAugment
}#

# Call
augment
  METHODS
    method Cmd.cmd_call( context:Cmd, args:Cmd )->Cmd
      throw t.error( "[INTERNAL] $.cmd_call() is undefined."(type_name) )

    method GlobalMethod.cmd_call( context:Cmd, args:Cmd )->Cmd
      return CallGlobalMethod( t, this, args )

      #{
    method Method.cmd_call( context:Cmd, args:Cmd )->Cmd
      if (context and not context.is_type_context)
        if (is_global) return CallGlobalMethodWithContext( t, context, this, args )
        else           return CallMethod( t, context, this, args )
      else
        if (is_global) return CallGlobalMethod( t, this, args )
        else           return CallThisMethod( t, this, args )
      endIf
      }#

    method Routine.cmd_call( context:Cmd, args:Cmd )->Cmd
      return CallRoutine( t, this, args )
endAugment

#{
# Divide
augment
  METHODS
    method Type.cmd_divide( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be divided."(name) )

    method TypeInt32.cmd_divide( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return DivideInt32( t, lhs, rhs )

    method TypeReal64.cmd_divide( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return DivideReal64( t, lhs, rhs )

    method TypeString.cmd_divide( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return DivideString( t, lhs, rhs )

    method TypeValue.cmd_divide( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return DivideValue( t, lhs, rhs )

endAugment

# Decrement
augment
  METHODS
    method Cmd.resolve_decrement( t:Token, resolver:Resolver )->Cmd
      throw t.error( "Illegal target for decrement." )

    method Access.resolve_decrement( t:Token, resolver:Resolver )->Cmd
      if (not args)
        local v = resolver.find_local( name )
        if (v) return resolver.validate( DecrementLocal(t,v) )

        local p = resolver.this_type.find_property( name )
        if (p) return resolver.validate( DecrementThisProperty(t,p) )
      endIf
      throw t.error( "Illegal target for decrement." )
endAugment
}#

# ForEach
augment
  METHODS
    method ForEachControl.resolve_foreach( resolver:Resolver, cmd_foreach:ForEach, cmd_iterator:Iterator )
      throw UnsupportedOperationError()

    method ForEachInControl.resolve_foreach( resolver:Resolver, cmd_foreach:ForEach, cmd_iterator:Iterator )
      collection.data.resolve_foreach( resolver, cmd_foreach, this, collection, cmd_iterator )

    method Cmd.resolve_foreach( resolver:Resolver, cmd_foreach:ForEach, cmd_control:ForEachInControl,
                                  cmd_collection:ForEachCollection, cmd_iterator:Iterator )
      throw UnsupportedOperationError()

    method Range.resolve_foreach( resolver:Resolver, cmd_foreach:ForEach, cmd_control:ForEachInControl,
                                  cmd_collection:ForEachCollection, cmd_iterator:Iterator )
      throw UnsupportedOperationError()

    method RangeUpTo.resolve_foreach( resolver:Resolver, cmd_foreach:ForEach, cmd_control:ForEachInControl,
                                      cmd_collection:ForEachCollection, cmd_iterator:Iterator )
      resolver.visit( cmd_control )
      resolver.visit( cmd_collection )

      local v_iterator_name = which{ cmd_control.name || resolver.autoname("i") }
      local v_iterator = Local( cmd_control.t, v_iterator_name, null, type )
      cmd_iterator.locals.add( v_iterator )
      resolver.this_procedure.locals.add( v_iterator )
      resolver.visible_locals.add( v_iterator )

      cmd_iterator.initialization.add( SetLocal(t,v_iterator,left) )
      cmd_iterator.condition = CompareLE( t, Access(t,v_iterator_name), right )

      if (cmd_collection.step_size)
        cmd_iterator.upkeep.add( AddAndAssign(t, Access(t,v_iterator_name), cmd_collection.step_size) )
      else
        cmd_iterator.upkeep.add( Preincrement(t, Access(t,v_iterator_name)) )
      endIf

endAugment

#{
# Increment
augment
  METHODS
    method Cmd.resolve_increment( t:Token, resolver:Resolver )->Cmd
      throw t.error( "Illegal target for increment." )

    method Access.resolve_increment( t:Token, resolver:Resolver )->Cmd
      if (not args)
        local v = resolver.find_local( name )
        if (v) return resolver.validate( IncrementLocal(t,v) )

        local p = resolver.this_type.find_property( name )
        if (p) return resolver.validate( IncrementThisProperty(t,p) )
      endIf
      throw t.error( "Illegal target for increment." )

      #method Access.resolve_increment( t:Token, resolver:Resolver )->Cmd
      #return CallRoutine( t, this, args )
endAugment

# LeftShift
augment
  METHODS
    method Type.cmd_left_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bit-shifted."(name) )

    method TypeInt32.cmd_left_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return LeftShiftInt32( t, lhs, rhs )

    method TypeValue.cmd_left_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return LeftShiftValue( t, lhs, rhs )

endAugment

# Mod
augment
  METHODS
    method Type.cmd_mod( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be mod'd."(name) )

    method TypeInt32.cmd_mod( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return ModInt32( t, lhs, rhs )

    method TypeReal64.cmd_mod( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return ModReal64( t, lhs, rhs )

    method TypeValue.cmd_mod( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return ModValue( t, lhs, rhs )

endAugment

# Multiply
augment
  METHODS
    method Type.cmd_multiply( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be multiplied."(name) )

    method TypeInt32.cmd_multiply( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return MultiplyInt32( t, lhs, rhs )

    method TypeReal64.cmd_multiply( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return MultiplyReal64( t, lhs, rhs )

    method TypeString.cmd_multiply( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return MultiplyString( t, lhs, rhs )

    method TypeValue.cmd_multiply( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return MultiplyValue( t, lhs, rhs )

endAugment

# Negate
augment
  METHODS
    method Type.cmd_negate( t:Token, operand:Cmd )->Cmd
      throw t.error( "Values of type $ cannot be negated."(name) )

    method TypeInt32.cmd_negate( t:Token, operand:Cmd )->Cmd
      return NegateInt32( t, operand )

    method TypeReal64.cmd_negate( t:Token, operand:Cmd )->Cmd
      return NegateReal64( t, operand )

    method TypeValue.cmd_negate( t:Token, operand:Cmd )->Cmd
      return NegateValue( t, operand )

endAugment
}#

# Print
augment
  METHODS
    method Cmd.cmd_print( t:Token, operand:Cmd )->Cmd
      throw t.error( "Values of type $ cannot be printed"(type_name) )
endAugment

#{
# RightShift
augment
  METHODS
    method Type.cmd_right_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bit-shifted."(name) )

    method TypeInt32.cmd_right_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return RightShiftInt32( t, lhs, rhs )

    method TypeValue.cmd_right_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return RightShiftValue( t, lhs, rhs )

endAugment

# RightShiftX
augment
  METHODS
    method Type.cmd_right_shift_x( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bit-shifted."(name) )

    method TypeInt32.cmd_right_shift_x( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return RightShiftXInt32( t, lhs, rhs )

    method TypeValue.cmd_right_shift_x( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return RightShiftXValue( t, lhs, rhs )

endAugment

# Subtract
augment
  METHODS
    method Type.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be subtracted."(name) )

    method TypeInt32.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractInt32( t, lhs, rhs )

    method TypeReal64.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractReal64( t, lhs, rhs )

    method TypeString.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractString( t, lhs, rhs )

endAugment
}#
