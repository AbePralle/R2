module Rogue
uses Utility/WorkList

class Resolver : Visitor
  PROPERTIES
    visible_locals    = Local[]
    visible_locals_fp = Int32[]
    control_stack     = ControlStructure[]

    current_statements : ListRewriter<<Cmd>>
    insert_in_init     = false

    autoname_index = 0

  METHODS
    method visit( m:Module, proc:Procedure )
      temporarily this_module=m, this_procedure=proc
        visit( proc )
      endTemporarily

    method visit_type( type:Type )
      type.organize
      if (type.is_aspect) return

      prior.visit_type( type )
      type.m_on_cleanup = type.methods["on_cleanup()"]
      if (type.m_on_cleanup)
        if (type.m_on_cleanup.return_type)
          throw type.m_on_cleanup.t.error( "on_cleanup() cannot return a value." )
        endIf
      endIf

    method add_local( v:Local )
      this_procedure.locals.add( v )
      assert control_stack.count
      control_stack.last.locals.add( v )
      visible_locals.add( v )

    method add_local( t:Token, base:String, type:Type, initial_value=null:Cmd )->Local
      local v = Local( t, autoname(base), initial_value, type )
      add_local( v )
      return v

    method auto_local( t:Token, base:String, type:Type )->Local
      return Local( t, autoname(base), null, type )

    method autoname( base:String )->String
      local result = "_auto_$_$"(base,autoname_index)
      ++autoname_index
      return result

    method find_local( name:String )->Local
      forEach (v in visible_locals step -1)
        if (v.name == name) return v
      endForEach
      return null

    method on( cmd:Access )->Cmd
      cmd.args = visit( cmd.args )
      return resolve_access( cmd.t, null, cmd.name, cmd.args )

    method on( cmd:AddAndAssign )->Cmd
      return validate( cmd.target.resolve_add_and_assign(visit(cmd.operand).require_value,this) )

    method on( cmd:Assign )->Cmd
      local new_value = visit( cmd.new_value ).require_value
      return cmd.target.resolve_assignment( cmd.t, new_value, this )

    method on( cmd:Block )->Cmd
      return visit( ControlStructure(cmd.t, cmd.statements, ControlType.BLOCK) )

    method on_visit( cmd:Binary )
      visit_children( cmd )
      local left = cmd.left
      local right = cmd.right
      local left_type = left.require_type
      local right_type = right.require_type
      local result_type = Cmd.common_op_type( cmd.t, left_type, right_type )
      if (left_type is not result_type) cmd.left = validate( result_type.cmd_cast(left) )
      if (right_type is not result_type) cmd.right = validate( result_type.cmd_cast(right) )
      # on_validate() will be called after this method returns

    method on_validate( cmd:CallProcedure )->Cmd
      if (cmd.info.throws)
        back_propagate_thrown_exception( cmd.info.throws )
      endIf
      return cmd

    method on( cmd:ContextAccess )->Cmd
      visit( cmd.args )
      return resolve_access( cmd.t, cmd.context, cmd.name, cmd.args )

    method on( cmd:ContextBlock )->Cmd
      local context = visit( cmd.context )
      local v = add_local( cmd.t, "context_block", context.require_type, DummyInitialValue )
      insert( SetLocal( v.t, v, context, &initial_assignment ) )
      forEach (context_cmd in cmd.commands)
        context_cmd = visit( ContextBlockPatcher.patch(v,context_cmd) )
        if (context_cmd) insert( context_cmd )
      endForEach
      return GetLocal( v.t, v )

    method on( cmd:ControlStructure )->Cmd
      push_scope( cmd )
      handle( cmd )
      pop_scope
      return cmd

    method on_visit( cmd:Convert )
      visit_children( cmd )

    method on( cmd:ConvertToType )->Cmd
      cmd.operand = visit( cmd.operand )
      local operand_type = cmd.operand.require_type

      local cmd_call = resolve_access( cmd.t, cmd.operand, "to_$"(cmd.to_type.name), Args(cmd.t), &suppress_error )
      if (cmd_call) return cmd_call

      if (operand_type.is_primitive and cmd.to_type.is_primitive)
        return cmd.operand.cmd_convert_to( cmd.to_type )
      endIf

      throw cmd.t.error( "No $->$ conversion is defined."(operand_type,cmd.to_type) )

    method on_validate( cmd:CreateObject )->Cmd
      if (cmd.m_init and cmd.m_init.throws)
        back_propagate_thrown_exception( cmd.m_init.throws )
      endIf
      return cmd

    method on( cmd:ForEach )->Cmd
      local iterator = Iterator( cmd.t, cmd.statements, ControlType.FOR_EACH )
      cmd.condition.resolve_foreach( this, cmd, iterator )
      return visit( iterator )

    method on_visit( cmd:GlobalMethod )
      temporarily this_type = cmd.type_context
        on_visit( cmd->(as Procedure) )
      endTemporarily

    method on( cmd:IndexedAccess )->Cmd
      local context = visit( cmd.context )
      local index   = visit( cmd.index )
      local context_type = context.require_type
      local index_type   = index.require_type

      local cmd_call = resolve_access( cmd.t, context, "at", Args(cmd.t,index), &suppress_error )
      if (cmd_call) return cmd_call

      cmd_call = resolve_access( cmd.t, context, "get", Args(cmd.t,index), &suppress_error )
      if (cmd_call) return cmd_call

      if (index_type is Program.type_Int32)
        throw cmd.t.error( "Type $ has no indexed access method at(Int32) or get(Int32)."(context_type) )
      else
        throw cmd.t.error( "Type $ has no indexed access method at($|Int32) or get($|Int32)."...
            (context_type,index_type,index_type) )
      endIf

    method on( cmd:If )->Cmd
      push_scope( cmd )
      temporarily insert_in_init = true
        cmd.condition = visit( cmd.condition )
      endTemporarily

      if (cmd.condition and cmd.condition.is_literal)
        pop_scope
        if (cmd.condition.is_truthy)
          # Keep the statements, discard any elseIfs/else
          return visit( cmd.statements )
        elseIf (cmd.cmd_else)
          # Discard this 'if' in favor of the elseIf or else that comes next
          if (cmd.cmd_else.condition)
            return visit( cmd.cmd_else )
          else
            return visit( cmd.cmd_else.statements )
          endIf
        else
          return null # this 'if' disappears entirely
        endIf
      endIf

      cmd.statements = visit( cmd.statements )
      if (cmd.cmd_else) cmd.cmd_else = visit( cmd.cmd_else )->(as If)
      pop_scope

      return cmd

    method on( cmd:InlineWhich )->Cmd
      if (cmd.cases.count == 1) return visit( cmd.cases.first )

      visit_children( cmd )

      local last_case = cmd.cases.last->(as InlineWhichCase)
      if (last_case.value)
        if (last_case.condition)
          throw cmd.t.error( "Last which{} case must be a value without a condition, e.g. 'which {a:x || b:y || z}'." )
        endIf
      else
        swapValues( last_case.value, last_case.condition )
      endIf

      local result_type : Type
      forEach (wcase in cmd.cases)
        local cur_type = which{ wcase.value || wcase.condition }.require_type
        result_type = which{ result_type:Cmd.common_type(cmd.t,result_type,cur_type) || cur_type }
      endForEach
      cmd.result_type = result_type

      forEach (wcase in cmd.cases)
        if (wcase.value) wcase.value .= cmd_convert_to( result_type )
      endForEach

      return cmd

    method on( cmd:Is )->Cmd
      cmd.left = visit( cmd.left )
      cmd.right = visit( cmd.right )
      local left_type = cmd.left.require_type
      local right_type = cmd.right.require_type
      if (left_type.is_primitive or right_type.is_primitive)
        return validate( CompareEQ(cmd.t,cmd.left,cmd.right) )
      else
        return cmd
      endIf

    method on( cmd:IsNot )->Cmd
      cmd.left = visit( cmd.left )
      cmd.right = visit( cmd.right )
      local left_type = cmd.left.require_type
      local right_type = cmd.right.require_type
      if (left_type.is_primitive or right_type.is_primitive)
        return validate( CompareNE(cmd.t,cmd.left,cmd.right) )
      else
        return cmd
      endIf

    method on( cmd:InstanceOf )->Cmd
      cmd.operand = visit( cmd.operand )
      local operand_type = cmd.operand.require_type
      if (cmd.operand.is_type_context)
        if (operand_type.attributes.is_singleton)
          return cmd  # leave as a runtime check - singleton ref could hold an extended class
        else
          return LiteralLogical( cmd.t, operand_type.instance_of(cmd.compare_type) )
        endIf
      elseIf (cmd.compare_type.instance_of(operand_type))
        # Leave it as a runtime check
        return cmd
      else
        return LiteralLogical( cmd.t, false )
      endIf

    method on( cmd:IsCompound )->Cmd
      local operand = visit( cmd.operand )
      return LiteralLogical( cmd.t, operand.require_type.is_compound )

    method on( cmd:IsPrimitive )->Cmd
      local operand = visit( cmd.operand )
      return LiteralLogical( cmd.t, operand.require_type.is_primitive )

    method on( cmd:IsReference )->Cmd
      local operand = visit( cmd.operand )
      return LiteralLogical( cmd.t, operand.require_type.is_reference )

    method on( cmd:IsType )->Cmd
      cmd.operand = visit( cmd.operand )
      local operand_type = cmd.operand.require_type
      if (cmd.operand.is_type_context)
        if (operand_type.attributes.is_singleton)
          return cmd  # leave as a runtime check - singleton ref could hold an extended class
        else
          return LiteralLogical( cmd.t, operand_type is cmd.compare_type )
        endIf
      elseIf (cmd.compare_type.instance_of(operand_type))
        # Leave it as a runtime check
        return cmd
      else
        return LiteralLogical( cmd.t, false )  # no way
      endIf

    method on_visit( cmd:Iterator )
      push_scope( cmd )
      temporarily insert_in_init = true
        cmd.condition = visit( cmd.condition )
      endTemporarily
      cmd.initialization = visit( cmd.initialization )
      cmd.statements = visit( cmd.statements )
      cmd.upkeep = visit( cmd.upkeep )
      cmd.control = visit( cmd.control )
      pop_scope

    method on( cmd:LocalDeclarations )->Cmd
      if (cmd.@type)
        # local a, b=x, c : Type
        #   ->
        # local a:Type, b=x:Type, c:Type
        local type = cmd.@type->Type
        cmd.type = type
        (forEach in cmd.declarations)->(as Local).type = type
      else
        # Infer any missing types.
        forEach (v in cmd.declarations)
          block v = v->(as Local)
            if (v.initial_value)
              v.initial_value = visit( v.initial_value ).require_value
              if (v.@type) v.initial_value = visit( v.initial_value.cmd_convert_to(v.@type) )
              else         v.type = v.initial_value.type
            elseIf (not v.@type)
              throw v.t.error( "Local variable declarations must have an initial value assignment or an assigned ': Type'." )
            endIf
          endBlock
        endForEach
      endIf

      forEach (decl in cmd.declarations)
        local v = decl->(as Local)
        add_local( v )
      endForEach

      local result : Statements
      local is_multiple_declaration = (cmd.declarations.count > 1)
      if (is_multiple_declaration) result = Statements( cmd.t )
      forEach (decl in cmd.declarations)
        local v = decl->(as Local)
        if (v.initial_value)
          #local cmd_assign = visit( Assign(v.t, Access(v.t,v.name), v.initial_value) )
          local cmd_assign = validate( SetLocal(v.t, v, v.initial_value, &initial_assignment) )
          if (is_multiple_declaration) result.add( cmd_assign )
          else                         return cmd_assign
        endIf
      endForEach

      return null

    method on( cmd:Loop )->Cmd
      local iterator = Iterator( cmd.t, cmd.statements, ControlType.LOOP )
      if (cmd.loop_count)
        local v = add_local( cmd.loop_count.t, "i", Program.type_Int32, DummyInitialValue )
        iterator.initialization.add(
          SetLocal( v.t, v,
            Add( v.t, cmd.loop_count.cmd_convert_to(Program.type_Int32), LiteralInt32(v.t,1) )
          )
        )
        iterator.condition = PreDecrement( v.t, GetLocal(v.t,v) )
      else
        iterator.control = LiteralLogical(cmd.t,true)
      endIf
      return visit( iterator )

    method on_visit( cmd:Method )
      temporarily this_type = cmd.type_context
        on_visit( cmd->(as Procedure) )
      endTemporarily

    method on( cmd:NativeHeader )->Cmd
      this_module.native_headers.add( cmd.content )
      return null

    method on( cmd:NativeCode )->Cmd
      this_module.native_code.add( cmd.content )
      return null

    method on_visit( cmd:Procedure )
      autoname_index = 0

      visible_locals_fp.add( visible_locals.count )
      forEach (p in cmd.parameters)
        block p = p->(as Local)
          p.attributes.is_anchored = true  # assumption
          visible_locals.add( p )
        endBlock
      endForEach

      visit_children( cmd )

      visible_locals.discard_from( visible_locals_fp.remove_last )

    method pop_scope
      control_stack.remove_last
      visible_locals.discard_from( visible_locals_fp.remove_last )

    method push_scope( cmd:ControlStructure )
      visible_locals_fp.add( visible_locals.count )
      control_stack.add( cmd )
      visible_locals.add( forEach in cmd.locals )

    method on( cmd:Print )->Cmd
      which (cmd.args.count)
        case 0
          throw cmd.t.error( "One or more arguments expected." )
        case 1
          return resolve_access( cmd.t, GetSingleton(cmd.t,Program.type_Global), "print", cmd.args )
        others
          local result = Statements( cmd.t )
          forEach (arg in cmd.args)
            result.add( resolve_access(cmd.t, GetSingleton(cmd.t,Program.type_Global), "print", Args(arg.t,arg)) )
          endForEach
          return result
      endWhich

    method on( cmd:Println )->Cmd
      which (cmd.args.count)
        case 0
          return resolve_access( cmd.t, GetSingleton(cmd.t,Program.type_Global), "println", null )
        case 1
          return resolve_access( cmd.t, GetSingleton(cmd.t,Program.type_Global), "println", cmd.args )
        others
          local result = Statements( cmd.t )
          forEach (arg in cmd.args)
            result.add( resolve_access(cmd.t, GetSingleton(cmd.t,Program.type_Global), "print", Args(arg.t,arg)) )
          endForEach
          result.add( resolve_access(cmd.t, GetSingleton(cmd.t,Program.type_Global), "println", null) )
          return result
      endWhich

    method on( cmd:Return )->Cmd
      this_procedure.attributes.has_return = true

      if (cmd.result)
        if (not this_procedure.return_type)
          throw cmd.t.error( "Unexpected return value - $ does not declare a return type."(this_procedure) )
        endIf
        cmd.result = visit( cmd.result ).require_value
      else
        if (this_procedure.return_type)
          throw cmd.t.error( "$ return value expected."(this_procedure.return_type) )
        endIf
      endIf
      return cmd

    method on( cmd:ShiftRight )->Cmd
      return resolve_access( cmd.t, TypeContext(cmd.t,Program.type_Math), "shift_right",
                             Args(cmd.t,cmd.left,cmd.right) )

    method on_visit( cmd:Statements )
      temporarily current_statements = cmd.list.rewriter
        forEach (statement in current_statements)
          statement = visit( statement )
          if (statement)
            #if (statement.type) statement = DiscardResult( statement.t, statement )
            if (statement.type) statement = statement.discarding_result
            if (statement) current_statements.write( statement )
          endIf
        endForEach
      endTemporarily

#{
    method on_validate( cmd:Subtract )->Cmd
      return validate( cmd.left.type.cmd_subtract(cmd.t, cmd.left, cmd.right) )
      }#

    method on( cmd:Throw )->Cmd
      cmd.exception = visit( cmd.exception )
      local exception_type = cmd.exception.require_type
      if (not exception_type.instance_of(Program.type_Exception) or exception_type is Program.type_null)
        throw cmd.exception.t.error( "Thrown value must be instanceOf type Exception." )
      endIf
      back_propagate_thrown_exception( exception_type )
      return cmd

    method on_visit( cmd:Unary )
      cmd.operand = visit( cmd.operand )
      local type = cmd.require_type
      if (type.is_primitive)
        local op_type = Cmd.common_op_type( cmd.t, type, Program.type_Int32 )
        if (type is not op_type) cmd.operand = validate( cmd.cmd_convert_to(op_type) )
      endIf

      #{
    method on_visit( cmd:While )
      visit_children( cmd )
      cmd.condition.require_value

    method resolve( v:Local )
      if (v.initial_value)
        v.initial_value = visit( v.initial_value ).require_value
        if (not v.type) v.type = v.initial_value.type
      endIf
}#

    method back_propagate_thrown_exception( type:Type )
      forEach (control_structure in control_stack step -1)
        control_structure.throws_exception = true
        if (control_structure.catches_exception(type)) return
      endForEach
      this_procedure.throws = type

    method insert( cmd:Cmd )
      if (insert_in_init)
        control_stack.last.initialization.add( cmd )
      else
        current_statements.write( cmd )
      endIf

    method resolve_access( t:Token, context:Cmd, name:String, args:Cmd, &suppress_error )->Cmd
      local m = this_module
      if (name.contains("::"))
        local m_name = name.before_last("::")
        m = Program.modules[ m_name ]
        if (not m) throw t.error( "No such module '$'."(m_name) )
        name .= after_last("::")
      endIf

      temporarily this_module = m

        local type_context : Type
        local is_global = false

        if (context)
          context = visit( context )
          is_global = context.is_type_context
          type_context = context.require_type

          #if (not args)
          #  if (type_context is Program.type_Value)
          #    if (name == "x" or name == "y")
          #      context = validate( CastValueToXY(t,context) )
          #      type_context = Program.type_XY
          #    endIf
          #  endIf

          #  if (type_context is Program.type_XY)
          #    if (name == "x") return validate( XYGetX(t, context) )
          #    if (name == "y") return validate( XYGetY(t, context) )
          #  endIf
          #endIf

        else
          local type = this_module.find_type( name, &extended_search )
          if (type and not args)
            if (type.attributes.is_singleton)
              return GetSingleton(t,type)
            else
              if (type.name.ends_with(']'))
                return resolve_access( t, null, type.name, Args(t) )
              else
                return TypeContext(t,type)
              endIf
            endIf
          endIf

          type_context = this_type  # may be null

          if (args)
            # Call or constructor
            if (type)
              #{
              if (name == "XY")
                forEach (arg at i in args)
                  args[i] = validate( arg.cmd_convert_to(Program.type_Real64) )
                endForEach
                which (args.count)
                  case 0: return validate( CreateXY0(t) )
                  case 1: return validate( CreateXY1(t,args[0]) )
                  case 2: return validate( CreateXY2(t,args[0],args[1]) )
                  others: throw t.error( "0, 1, or 2 arguments expected for XY() constructor." )
                endWhich
              endIf
              }#
              return validate( cmd_create_object(t,type,args) )
            endIf
          else
            local v = find_local( name )
            if (v) return validate( GetLocal(t,v) )
          endIf
        endIf

        if (type_context)
          type_context.organize
          local def = type_context.definitions[ name ]
          if (def) return visit( def.cloned )
        endIf

        local match = find_procedure( t, type_context, context, name, args, &require_global=is_global, &suppress_error )

        if (match)
          if (not args) args = CmdList(t)
          cast_args_to_parameter_types( args, match )
          return validate( match.cmd_call(context,args) )
        endIf

        if (not type_context)
          match = find_procedure( t, Program.type_Global, context, name, args, &suppress_error )
          if (match)
            if (not args) args = CmdList(t)
            cast_args_to_parameter_types( args, match )
            return validate( match.cmd_call(GetSingleton(t,Program.type_Global),args) )
          endIf
        endIf

        if (not is_global)
          # TODO: update to allow global properties
          if (type_context and not args)
            local p = type_context.properties[ name ]
            if (p)
              if (context) return validate( GetProperty(t,context,p) )
              else         return validate( GetThisProperty(t,p) )
            endIf
          endIf
        endIf

        if (suppress_error) return null->(as Cmd)

        find_procedure( t, type_context, context, name, args, &require_global=is_global )  # throw an error

      endTemporarily
      return null  # never reached


    method cmd_create_object( t:Token, type_context:Type, args:Cmd )->Cmd
      local m_create = find_procedure( t, type_context, null, "create", args, &require_global, &suppress_error )->(as GlobalMethod)
      if (m_create)
        if (not args) args = CmdList(t)
        cast_args_to_parameter_types( args, m_create )
        return CallGlobalMethod( t, m_create, args )
      endIf

      local m_init = find_procedure( t, type_context, null, "init", args, &suppress_error )->(as Method)
      if (m_init)
        if (not args) args = CmdList(t)
        cast_args_to_parameter_types( args, m_init )
        return CreateObject( t, type_context, m_init, args )
      endIf

      local mesg : String
      use Candidates
        type_context.collect_methods( "create", Candidates.list )
        type_context.collect_methods( "init", Candidates.list )

        if (args.count == 0 and Candidates.count == 0)
          # No constructors available and no constructor required.
          return CreateObject( t, type_context, null, args )
        endIf

        mesg = "No exact match for object constructor $("(type_context)
        forEach (arg at i in args)
          if (i > 0) mesg += ','
          mesg += arg.require_type
        endForEach
        mesg += "). Candidates:\n\n"
        if (Candidates.count)
          forEach (m in Candidates)
            mesg += "  $$" (type_context,m.signature.from_first('('))
          endForEach
        else
          mesg += "  $()"(type_context)
        endIf
      endUse
      throw t.error( mesg )

    method cast_args_to_parameter_types( args:Cmd, proc:Procedure )
      # And fill in default values
      proc.resolve

      proc.arrange_args( args )

      forEach (arg at i in args)
        if (arg instanceOf NamedArg)
          local named_arg = arg->(as NamedArg)
          if (named_arg.is_zero)
            if (named_arg.value) throw named_arg.value.t.error( "Unexpected value." )
            arg = LiteralLogical(named_arg.t,false)
          elseIf (named_arg.is_forward)
            arg = visit( Access(named_arg.t,named_arg.name,null) )
          elseIf (named_arg.value)
            arg = named_arg.value
          else
            arg = LiteralLogical(named_arg.t,true)
          endIf
        elseIf (arg instanceOf DefaultArg)
          arg = visit( arg->(as DefaultArg).operand.cloned )
        endIf
        args[i] = validate( arg.cmd_convert_to(proc.parameters[i].type) )
      endForEach

    method find_procedure( t:Token, type_context:Type, context:Cmd, name:String, args:Cmd,
        &require_global, &suppress_error )->Procedure
      # 'context' is only passed for error description purposes.
      visit( args )  # resolve args to determine types

      local error_message : String
      use Candidates
        if (type_context)
          type_context.collect_methods( name, Candidates.list, &=require_global )
        else
          this_module.collect_routines( name, Candidates.list )
        endIf
        local result = refine_candidates( type_context, args )
        if (result)         return result.[resolve]
        if (suppress_error) return null

        # Throw an error
        local sig = name
        if (args)
          sig += '('
          forEach (arg at i in args)
            if (i > 0) sig += ','
            sig += arg.require_type
          endForEach
          sig += ')'
        endIf

        local mesg : String
        if (args)
          which (Candidates.count)
            case 0
              mesg = "No such "
              if (require_global) mesg += "global "
              if (context)        mesg += "method "
              elseIf (this_type)  mesg += "method or routine "
              else                mesg += "routine "

              if (context)        mesg += context.type + "."
              elseIf (this_type)  mesg += this_type + "."

              mesg += sig + '.'

            case 1
              mesg = "Call to "
              if (context)       mesg += context.type + "."
              elseIf (this_type) mesg += this_type + "."

              mesg += sig
              mesg += " has arguments that are incompatible with the best candidate:\n\n"
              mesg += "  " + Candidates[0].dev_signature

            others
              mesg = "Ambiguous call to "
              if (require_global) mesg += "global "
              if (context)        mesg += context.type + "."
              elseIf (this_type)  mesg += this_type + "."

              mesg += sig
              mesg += ". Candidates:\n\n"
              forEach (m in Candidates)
                mesg += "  $\n" (m.dev_signature)
              endForEach

          endWhich

        else
          local g = which{ require_global:"global " || "" }
          if (context)
            if (args) mesg = "No such $method '$' exists in type '$'." (g,sig,context.type)
            else      mesg = "No such $property or method '$' exists in type '$'." (g,sig,context.type)
          elseIf (this_type)
            if (args) mesg = "No such $method or routine '$'."(g,sig)
            else      mesg = "No such $variable, method, or routine '$'."(g,sig)
          else
            if (args) mesg = "No such $routine '$'."(g,sig)
            else      mesg = "No such $variable or routine '$'."(g,sig)
          endIf

        endIf

        error_message = mesg
      endUse

      throw t.error( error_message )

    method refine_candidates( type_context:Type, args:Cmd )->Procedure
      local arg_count = which{ args:args.count || 0 }

      local has_named_arg = false
      if (args)
        # Remove any DefaultArgs and check for named args with duplicate names.
        use arg_names = WorkList<<String>>
          forEach (arg in rewriter=args->(as CmdList).list.rewriter)
            if (arg instanceOf NamedArg)
              local named_arg = arg->(as NamedArg)
              rewriter.write( arg )
              has_named_arg = true
              if (arg_names.contains(named_arg.name))
                throw arg.t.error( "Named argument '$' is used multiple times."(named_arg.name) )
              endIf
              arg_names.add( named_arg.name )
            elseIf (arg not instanceOf DefaultArg)
              rewriter.write( arg )
            endIf
          endForEach
        endUse
      endIf

      # Filter out incorrect number of args
      forEach (m in Candidates)
        if (m.accepts_arg_count(arg_count)) Candidates.keep m
      endForEach
      if (not Candidates.refine) return null

      # Filter by candidates that contain all named args in a compatible arrangement.
      # Example: if 'method m(a:Int32,b=0:Int32)' called with 'm(&b=5)', that method
      # is not compatible with those arguments.
      if (has_named_arg)
        forEach (m in Candidates)
          contingent
            forEach (arg in args)
              if (arg instanceOf NamedArg)
                local arg_name = arg->(as NamedArg).name
                necessary (m.has_parameter_named(arg_name))
              endIf
            endForEach
            Candidates.keep m
          endContingent
        endForEach
        if (not Candidates.refine) return null

        forEach (m in Candidates)
          contingent
            if (m.arrange_args(args)) Candidates.keep m
          endContingent
        endForEach
        if (Candidates.found_match) return Candidates.match
        if (not Candidates.refine) return null

      else
        if (Candidates.found_match) return Candidates.match

      endIf

      # Filter out candidates that don't have the same module context as the first candidate
      local priority_module_context = Candidates[0].module_context
      forEach (m in Candidates)
        if (m.module_context is priority_module_context) Candidates.keep m
      endForEach
      if (Candidates.found_match) return Candidates.match
      Candidates.refine

      # Filter by exact arg types
      if (arg_count)
        forEach (m in Candidates)
          if (has_named_arg) m.arrange_args( args )
          forEach (arg at i in args)
            if (arg.type is m.parameters[i].type)
              Candidates.keep m
              escapeForEach
            endIf
          endForEach
        endForEach
        if (Candidates.found_match) return Candidates.match
        Candidates.refine
      endIf

      # Filter by fewest parameters (omitting calls with excess default args)
      if (arg_count)
        local min_params = Candidates[0].parameters.count
        min_params .= or_smaller( (forEach in Candidates from 1).parameters.count )
        forEach (m in Candidates)
          if (m.parameters.count == min_params) Candidates.keep m
        endForEach
        if (Candidates.found_match) return Candidates.match
        Candidates.refine
      endIf

      # Filter by arg categories (reference/primitive/compound)
      if (arg_count)
        forEach (m in Candidates)
          if (has_named_arg) m.arrange_args( args )
          contingent
            forEach (arg at i in args)
              local arg_type = arg.type
              local param_type = m.parameters[i].type
              if (arg_type.is_reference) necessary (param_type.is_reference)
              if (arg_type.is_primitive) necessary (param_type.is_primitive)
              if (arg_type.is_compound)  necessary (param_type.is_compound)
            endForEach
            Candidates.keep m
          endContingent
        endForEach
        if (Candidates.found_match) return Candidates.match
        Candidates.refine
      endIf

      # Prefer methods with higher-precision args
      if (arg_count)
        forEach (m in Candidates)
          if (has_named_arg) m.arrange_args( args )
          contingent
            forEach (arg at i in args)
              local arg_type = arg.type
              local param_type = m.parameters[i].type
              if (arg_type.is_primitive and param_type.is_primitive)
                necessary (param_type.precision_index >= arg_type.precision_index)
              endIf
            endForEach
            Candidates.keep m
          endContingent
        endForEach
        if (Candidates.found_match) return Candidates.match
        Candidates.refine
      endIf

      return null
endClass

#{
augment Procedure
  PROPERTIES
    local_stack_slots : Int32  # in addition to args already on stack

  METHODS
    method find_local( name:String )->Local
      forEach (v in locals step -1)
        if (v.name == name) return v
      endForEach
      return null
endAugment

# Add
augment
  METHODS
    method Type.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be added."(name) )

    method TypeInt32.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddInt32( t, lhs, rhs )

    method TypeReal64.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddReal64( t, lhs, rhs )

    method TypeString.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddString( t, lhs, rhs )

    method TypeValue.cmd_add( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return AddValue( t, lhs, rhs )

endAugment
}#

# AddAndAssign
augment
  METHODS
    method Cmd.resolve_add_and_assign( operand:Cmd, resolver:Resolver )->Cmd
      throw t.error( "Illegal assignment target." )

    method Access.resolve_add_and_assign( operand:Cmd, resolver:Resolver )->Cmd
      if (args) prior.resolve_add_and_assign( operand, resolver )
      operand = resolver.visit( operand )
      local operand_type = operand.require_type

      local v = resolver.find_local( name )
      if (v)
        if (operand_type is not v.type) operand = resolver.validate(operand.cmd_convert_to(v.type))
        return resolver.validate( AddAndAssignLocal(t,v,operand) )
      endIf

      local p = resolver.this_type.properties[ name ]
      if (p)
        if (operand_type is not p.type) operand = resolver.validate(operand.cmd_convert_to(p.type))
        return resolver.validate( AddAndAssignThisProperty(t,p,operand) )
      endIf

      throw t.error( "[TODO] Unimplemented assignment target (global property, Global.propery)." )
endAugment

# Assignment
augment
  METHODS
    method Cmd.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      throw t.error( "Illegal target for assignment." )

    method Access.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      if (not args)
        local v = resolver.find_local( name )
        if (v) return resolver.validate( SetLocal(t,v,new_value) )

        if (resolver.this_type)
          local p = resolver.this_type.properties[ name ]
          if (p) return resolver.validate( SetThisProperty(t,p,new_value) )
        endIf

        if (resolver.this_type)
          throw t.error( "No such local or property '$' or setter set_$() in current context."(name,name) )
        else
          throw t.error( "No such local '$' in current context."(name) )
        endIf
      endIf
      throw t.error( "Illegal target for assignment." )

    method ContextAccess.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      if (not args)
        context = resolver.visit( context )
        local context_type = context.require_type

        local p = context_type.properties[ name ]
        if (p) return resolver.validate( SetProperty(t,context,p,new_value) )

        throw t.error( "No such property '$' or setter set_$() in type $."(name,name,context_type.name) )
      endIf
      throw t.error( "Illegal target for assignment." )

    method IndexedAccess.resolve_assignment( t:Token, new_value:Cmd, resolver:Resolver )->Cmd
      return resolver.visit( ContextAccess(t, context, "set", Args(t,index,new_value)) )
endAugment

#{
# BitwiseAnd
augment
  METHODS
    method Type.cmd_bitwise_and( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bitwise-AND'd."(name) )

    method TypeInt32.cmd_bitwise_and( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseAndInt32( t, lhs, rhs )

    method TypeValue.cmd_bitwise_and( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseAndValue( t, lhs, rhs )

endAugment

# BitwiseOr
augment
  METHODS
    method Type.cmd_bitwise_or( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bitwise-OR'd."(name) )

    method TypeInt32.cmd_bitwise_or( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseOrInt32( t, lhs, rhs )

    method TypeValue.cmd_bitwise_or( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseOrValue( t, lhs, rhs )

endAugment

# BitwiseOrAndAssign
augment
  METHODS
    method Cmd.resolve_bitwise_or_and_assign( t:Token, operand:Cmd, resolver:Resolver )->Cmd
      throw t.error( "Illegal target for '|='." )

    method Access.resolve_bitwise_or_and_assign( t:Token, operand:Cmd, resolver:Resolver )->Cmd
      if (not args)
        local v = resolver.find_local( name )
        if (v) return resolver.validate( BitwiseOrAndAssignLocal(t,v,operand) )

        local p = resolver.this_type.find_property( name )
        if (p) return resolver.validate( BitwiseOrAndAssignThisProperty(t,p,operand) )
      endIf
      throw t.error( "Illegal target for '|='." )

    method ContextAccess.resolve_bitwise_or_and_assign( t:Token, operand:Cmd, resolver:Resolver )->Cmd
      if (not args)
        context = resolver.visit( context )
        local p = context.require_type.find_property( name )
        if (p) return resolver.validate( BitwiseOrAndAssignProperty(t,context,p,operand) )
      endIf
      throw t.error( "Illegal target for '|='." )

endAugment

# BitwiseXor
augment
  METHODS
    method Type.cmd_bitwise_xor( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bitwise-XOR'd."(name) )

    method TypeInt32.cmd_bitwise_xor( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseXorInt32( t, lhs, rhs )

    method TypeValue.cmd_bitwise_xor( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return BitwiseXorValue( t, lhs, rhs )

endAugment
}#

# Call
augment
  METHODS
    method Cmd.cmd_call( context:Cmd, args:Cmd )->Cmd
      throw t.error( "[INTERNAL] $.cmd_call() is undefined."(type_name) )

    method GlobalMethod.cmd_call( context:Cmd, args:Cmd )->Cmd
      return CallGlobalMethod( t, this, args )

    method Method.cmd_call( context:Cmd, args:Cmd )->Cmd
      if (context)
        return CallDynamicMethod( t, context, this, args )
      else
        return CallThisDynamicMethod( t, this, args )
      endIf

    method Routine.cmd_call( context:Cmd, args:Cmd )->Cmd
      return CallRoutine( t, this, args )
endAugment

#{
# Divide
augment
  METHODS
    method Type.cmd_divide( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be divided."(name) )

    method TypeInt32.cmd_divide( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return DivideInt32( t, lhs, rhs )

    method TypeReal64.cmd_divide( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return DivideReal64( t, lhs, rhs )

    method TypeString.cmd_divide( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return DivideString( t, lhs, rhs )

    method TypeValue.cmd_divide( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return DivideValue( t, lhs, rhs )

endAugment

# Decrement
augment
  METHODS
    method Cmd.resolve_decrement( t:Token, resolver:Resolver )->Cmd
      throw t.error( "Illegal target for decrement." )

    method Access.resolve_decrement( t:Token, resolver:Resolver )->Cmd
      if (not args)
        local v = resolver.find_local( name )
        if (v) return resolver.validate( DecrementLocal(t,v) )

        local p = resolver.this_type.find_property( name )
        if (p) return resolver.validate( DecrementThisProperty(t,p) )
      endIf
      throw t.error( "Illegal target for decrement." )
endAugment
}#

# ForEach
augment
  METHODS
    method ForEachControl.resolve_foreach( resolver:Resolver, cmd_foreach:ForEach, cmd_iterator:Iterator )
      throw UnsupportedOperationError()

    method ForEachInControl.resolve_foreach( resolver:Resolver, cmd_foreach:ForEach, cmd_iterator:Iterator )
      collection.data.resolve_foreach( resolver, cmd_foreach, this, collection, cmd_iterator )

    method Cmd.resolve_foreach( resolver:Resolver, cmd_foreach:ForEach, cmd_control:ForEachInControl,
                                  cmd_collection:ForEachCollection, cmd_iterator:Iterator )
      throw UnsupportedOperationError()

    method Range.resolve_foreach( resolver:Resolver, cmd_foreach:ForEach, cmd_control:ForEachInControl,
                                  cmd_collection:ForEachCollection, cmd_iterator:Iterator )
      throw UnsupportedOperationError()

    method RangeUpTo.resolve_foreach( resolver:Resolver, cmd_foreach:ForEach, cmd_control:ForEachInControl,
                                      cmd_collection:ForEachCollection, cmd_iterator:Iterator )
      resolver.push_scope( cmd_iterator )
      temporarily resolver.insert_in_init = true
        resolver.visit( cmd_control )
        resolver.visit( cmd_collection )
      endTemporarily

      local v_iterator_name = which{ cmd_control.name || resolver.autoname("i") }
      local v_iterator = Local( cmd_control.t, v_iterator_name, null, type )
      cmd_iterator.locals.add( v_iterator )
      resolver.this_procedure.locals.add( v_iterator )
      resolver.visible_locals.add( v_iterator )

      cmd_iterator.initialization.add( SetLocal(t,v_iterator,left) )
      cmd_iterator.condition = CompareLE( t, Access(t,v_iterator_name), right )

      if (cmd_collection.step_size)
        cmd_iterator.upkeep.add( AddAndAssign(t, Access(t,v_iterator_name), cmd_collection.step_size) )
      else
        cmd_iterator.upkeep.add( PreIncrement(t, Access(t,v_iterator_name)) )
      endIf

      resolver.pop_scope

endAugment

#{
# Increment
augment
  METHODS
    method Cmd.resolve_increment( t:Token, resolver:Resolver )->Cmd
      throw t.error( "Illegal target for increment." )

    method Access.resolve_increment( t:Token, resolver:Resolver )->Cmd
      if (not args)
        local v = resolver.find_local( name )
        if (v) return resolver.validate( IncrementLocal(t,v) )

        local p = resolver.this_type.find_property( name )
        if (p) return resolver.validate( IncrementThisProperty(t,p) )
      endIf
      throw t.error( "Illegal target for increment." )

      #method Access.resolve_increment( t:Token, resolver:Resolver )->Cmd
      #return CallRoutine( t, this, args )
endAugment

# ShiftLeft
augment
  METHODS
    method Type.cmd_left_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bit-shifted."(name) )

    method TypeInt32.cmd_left_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return LeftShiftInt32( t, lhs, rhs )

    method TypeValue.cmd_left_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return LeftShiftValue( t, lhs, rhs )

endAugment

# Mod
augment
  METHODS
    method Type.cmd_mod( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be mod'd."(name) )

    method TypeInt32.cmd_mod( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return ModInt32( t, lhs, rhs )

    method TypeReal64.cmd_mod( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return ModReal64( t, lhs, rhs )

    method TypeValue.cmd_mod( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return ModValue( t, lhs, rhs )

endAugment

# Multiply
augment
  METHODS
    method Type.cmd_multiply( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be multiplied."(name) )

    method TypeInt32.cmd_multiply( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return MultiplyInt32( t, lhs, rhs )

    method TypeReal64.cmd_multiply( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return MultiplyReal64( t, lhs, rhs )

    method TypeString.cmd_multiply( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return MultiplyString( t, lhs, rhs )

    method TypeValue.cmd_multiply( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return MultiplyValue( t, lhs, rhs )

endAugment

# Negate
augment
  METHODS
    method Type.cmd_negate( t:Token, operand:Cmd )->Cmd
      throw t.error( "Values of type $ cannot be negated."(name) )

    method TypeInt32.cmd_negate( t:Token, operand:Cmd )->Cmd
      return NegateInt32( t, operand )

    method TypeReal64.cmd_negate( t:Token, operand:Cmd )->Cmd
      return NegateReal64( t, operand )

    method TypeValue.cmd_negate( t:Token, operand:Cmd )->Cmd
      return NegateValue( t, operand )

endAugment
}#

#{
# ShiftRight
augment
  METHODS
    method Type.cmd_right_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bit-shifted."(name) )

    method TypeInt32.cmd_right_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return RightShiftInt32( t, lhs, rhs )

    method TypeValue.cmd_right_shift( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return RightShiftValue( t, lhs, rhs )

endAugment

# ShiftRightX
augment
  METHODS
    method Type.cmd_right_shift_x( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be bit-shifted."(name) )

    method TypeInt32.cmd_right_shift_x( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return RightShiftXInt32( t, lhs, rhs )

    method TypeValue.cmd_right_shift_x( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return RightShiftXValue( t, lhs, rhs )

endAugment

# Subtract
augment
  METHODS
    method Type.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      throw t.error( "Values of type $ cannot be subtracted."(name) )

    method TypeInt32.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractInt32( t, lhs, rhs )

    method TypeReal64.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractReal64( t, lhs, rhs )

    method TypeString.cmd_subtract( t:Token, lhs:Cmd, rhs:Cmd)->Cmd
      return SubtractString( t, lhs, rhs )

endAugment
}#

