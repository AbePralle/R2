module Rogue

augment Cmd
  GLOBAL METHODS
    method common_type( t:Token, a:Type, b:Type )->Type
      if (a is b) return a
      if (not a or not b) return null
      if (a.is_primitive and b.is_primitive)
        local type = Program.type_String
        if (a is type or b is type) return type
        type = Program.type_Real64
        if (a is type or b is type) return type
        type = Program.type_Real
        if (a is type or b is type) return type
        type = Program.type_Real32
        if (a is type or b is type) return type
        type = Program.type_Int64
        if (a is type or b is type) return type
        return Program.type_Int32  # any mismatched pair Logical/Byte/Character/Int32 -> Int32
      elseIf (a is Program.type_String or b is Program.type_String)
        return Program.type_String
      elseIf (a.is_reference)
        if (not b.is_reference) return a
        if (a.instance_of(b)) return b
        if (b.instance_of(a)) return a
      elseIf (b.is_reference)
        return b
      elseIf (a.is_compound)
        if (not b.is_compound) return a
      elseIf (b.is_compound)
        if (not a.is_compound) return b
      endIf
      throw t.error( "Incompatible types $ and $."(a,b) )

    method common_op_type( t:Token, a:Type, b:Type )->Type
      local type = common_type( t, a, b )
      if (not type.is_primitive) return type

      if (type is Program.type_Real64 or type is Program.type_Real32)
        return Program.type_Real
      elseIf (type is Program.type_Int64)
        return Program.type_Int64
      else
        return Program.type_Int32
      endIf

  METHODS
    method require_type->Type
      local result = type
      if (result) return result
      println StackTrace()
      throw t.error( "Value expected ($)."(this) )  # FIXME

    method require_value->Cmd
      require_type
      return this

endAugment

# resolve_conversion_to
augment
  METHODS
    method Cmd.resolve_conversion_to( target_type:Type, resolver:Resolver, &suppress_error )->Cmd
      local this_type = require_type
      if (this_type is target_type) return this

      if (this_type.is_primitive and target_type.is_primitive)
        if (target_type is Program.type_Byte)      return resolver.validate( ConvertToByte( t, this ) )
        if (target_type is Program.type_Character) return resolver.validate( ConvertToCharacter( t, this ) )
        if (target_type is Program.type_Int32)     return resolver.validate( ConvertToInt32( t, this ) )
        if (target_type is Program.type_Int64)     return resolver.validate( ConvertToInt64( t, this ) )
        if (target_type is Program.type_Logical)   return resolver.validate( ConvertToLogical( t, this ) )
        if (target_type is Program.type_Real32)    return resolver.validate( ConvertToReal32( t, this ) )
        if (target_type is Program.type_Real64)    return resolver.validate( ConvertToReal64( t, this ) )
        throw t.error( "[INTERNAL] Unhandled primitive conversion." )
      endIf

      if (this_type.instance_of(target_type)) return WideningCast( t, this, target_type )

      # See if this_type has a to->TargetType method.
      local result = resolver.resolve_call( t, this_type, this, "to_$"(target_type), null, &suppress_error )
      if (result) return result

      # Look for a TargetType(this) constructor.
      result = resolver.resolve_type_access( t, target_type, Args(t,this), &suppress_error )
      if (result) return result

      if (this_type.instance_of(target_type))
        return resolver.validate( WideningCast(t,this,target_type) )
      endIf

      if (suppress_error) return null

      throw t.error( "No $.to->$ conversion or $($) constructor exists."(this_type,target_type,target_type,this_type) )

    method GenericFunctionDefinition.resolve_conversion_to( target_type:Type, resolver:Resolver, &suppress_error )->Cmd [override]
      local fn_type = target_type->(as FunctionType)
      if (not fn_type)
        if (suppress_error) return null
        throw t.error( "Generic function is incompatible with type $."(target_type) )
      endIf

      local params = Parameters(t)
      forEach (param_name at i in parameters)
        params.add( Local(t,param_name,fn_type.param_types[i]) )
      endForEach

      if (fn_type.return_type)
        if (statements.count)
          local statement = statements.remove_last
          if (statement.type)
            # Turn the last value into a return
            statements.add( Return(statement.t,statement) )
          else
            # After the last statement is resolved it may have a type. Have to wait and see.
            statements.add( FunctionReturnValue(statement.t,statement) )
          endIf
        else
          statements.add( fn_type.return_type.cmd_default_value(t) )
        endIf
      endIf

      local fn_def = resolver.visit( FunctionDefinition(t,params,fn_type.return_type,with_values,statements) )
      return fn_def.resolve_conversion_to( target_type, resolver, &=suppress_error )

    method LiteralNull.resolve_conversion_to( target_type:Type, resolver:Resolver, &suppress_error )->Cmd [override]
      if (target_type.attributes.is_optional)
        of_type = target_type.properties//value.type
        return resolver.visit( TypeAccess( t, target_type, Args(t,this,LiteralLogical(t,false)) ) )
      else
        of_type = target_type
        return this
      endIf
endAugment

# cmd_default_value()
augment
  METHODS
    method Type.cmd_default_value( cmd_t:Token )->Cmd
      if (is_compound) return EmptyCompound( cmd_t, this )
      return LiteralNull( cmd_t, this )

    method TypeCharacter.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralCharacter( cmd_t, 0 )

    method TypeInt32.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralInt32( cmd_t, 0 )

    method TypeLogical.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralLogical( cmd_t, false )

    method TypeReal64.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralReal( cmd_t, 0 )

endAugment

# discarding_result
augment
  METHODS
    method Cmd.discarding_result->Cmd
      return this  # no change

    method GetLocal.discarding_result->Cmd
      return null

    method Literal.discarding_result->Cmd
      return null
endAugment

# is_anchored
augment
  METHODS
    method Cmd.is_anchored->Logical
      return false

    method GetLocal.is_anchored->Logical
      return info.is_anchored

    method LiteralString.is_anchored->Logical
      return true

    method Local.is_anchored->Logical
      return attributes.is_anchored

    method GetSingleton.is_anchored->Logical
      return @type.attributes.is_anchored

    method This.is_anchored->Logical
      return true
endAugment

# is_literal
augment
  METHODS
    method Cmd.is_literal->Logical
      return false

    method Literal.is_literal->Logical
      return true

endAugment

# is_simple
augment
  METHODS
    method Cmd.is_simple->Logical
      return false

    method Access.is_simple->Logical
      return args is null or args.count == 0

    method GetLocal.is_simple->Logical
      return true

    method GetGlobal.is_simple->Logical
      return true

    method GetSingleton.is_simple->Logical
      return true

    method GetThisProperty.is_simple->Logical
      return true

    method Literal.is_simple->Logical
      return true

endAugment

# is_truthy
augment
  METHODS
    method Cmd.is_truthy->Logical
      return true

    method LiteralCharacter.is_truthy->Logical
      return value?

    method LiteralInt32.is_truthy->Logical
      return value?

    method LiteralInt64.is_truthy->Logical
      return value?

    method LiteralLogical.is_truthy->Logical
      return value

    method LiteralNull.is_truthy->Logical
      return false

    method LiteralReal32.is_truthy->Logical
      return value? and not value.is_NaN

    method LiteralReal64.is_truthy->Logical
      return value? and not value.is_NaN

endAugment

# is_operator
augment
  METHODS
    method Cmd.is_operator->Logical
      return false

    method Binary.is_operator->Logical
      return true

    method Unary.is_operator->Logical
      return true
endAugment

# is_type_context
augment
  METHODS
    method Cmd.is_type_context->Logical
      return false

    method TypeContext.is_type_context->Logical
      return true
endAugment

# logicalized()
augment
  METHODS
    method Cmd.logicalized( resolver:Resolver )->Cmd
      local cmd = resolver.visit( this )
      local type = cmd.require_type

      if (cmd instanceOf LiteralLogical or type is Program.type_Logical) return cmd

      if (type.is_primitive) return Logicalized(cmd.t,cmd)
      if (type.attributes.is_optional) return resolver.visit( ContextAccess(cmd.t,cmd,"exists",null) )

      local suppress_error = type.is_reference

      local logicalized = Logicalized( cmd.t, cmd )
      local result = type.resolve_unary_op( logicalized, resolver, &=suppress_error )
      if (result) return result

      result = cmd.resolve_conversion_to( Program.type_Logical, resolver, &=suppress_error )
      if (result) return result

      return logicalized   # a reference with no to->Logical available

endAugment

# symbol()
augment
  METHODS
    method Binary.symbol->String:                return null
    method Stepper.symbol->String:               return null
    method Unary.symbol->String:                 return null
    method Add.symbol->String:                   return "+"
    method Subtract.symbol->String:              return "-"
    method Multiply.symbol->String:              return "*"
    method Divide.symbol->String:                return "/"
    method Logicalize.symbol->String:            return "?"
    method Logicalized.symbol->String:           return "?"
    method Mod.symbol->String:                   return "%"
    method Negate.symbol->String:                return "-"
    method Power.symbol->String:                 return "^"
    method Increment.symbol->String:             return "++"
    method Decrement.symbol->String:             return "--"
    method BitwiseAnd.symbol->String:            return "&"
    method BitwiseOr.symbol->String:             return "|"
    method BitwiseXor.symbol->String:            return "~"
    method BitwiseNot.symbol->String:            return "!"
    method BitShiftLeft.symbol->String:          return ":<<:"
    method BitShiftRight.symbol->String:         return ":>>:"
    method BitShiftRightX.symbol->String:        return ":>>>:"
    method OpAndAssign.symbol->String:           return null
    method AddAndAssign.symbol->String:          return "+="
    method SubtractAndAssign.symbol->String:     return "-="
    method MultiplyAndAssign.symbol->String:     return "*="
    method DivideAndAssign.symbol->String:       return "/="
    method ModAndAssign.symbol->String:          return "%="
    method PowerAndAssign.symbol->String:        return "^="
    method BitwiseAndAndAssign.symbol->String:   return "&="
    method BitwiseOrAndAssign.symbol->String:    return "|="
    method BitwiseXorAndAssign.symbol->String:   return "~="
    method ShiftLeftAndAssign.symbol->String:    return ":<<:="
    method ShiftRightAndAssign.symbol->String:   return ":>>:="
    method ShiftRightXAndAssign.symbol->String:  return ":>>>:="
endAugment

# type()
augment
  METHODS
    method Cmd.type->Type
      return null

    #method Access.type->Type
      #return Program.find_type(name)

    method AddAndAssign.type->Type
      return target.type

    method AddAndAssignLocal.type->Type
      return info.type

    method Binary.type->Type
      return common_type( t, left.type, right.type )

    method CallProcedure.type->Type
      return info.return_type

      #{
    method CastReal64ToInt32.type->Type
      return Program.type_Int32
      }#

    method ConvertToByte.type->Type
      return Program.type_Byte

    method ConvertToCharacter.type->Type
      return Program.type_Character

    method ConvertToInt32.type->Type
      return Program.type_Int32

    method ConvertToInt64.type->Type
      return Program.type_Int64

    method ConvertToLogical.type->Type
      return Program.type_Logical

    #method ConvertToObject.type->Type
    #  return Program.type_Object

    method ConvertToReal32.type->Type
      return Program.type_Real32

    method ConvertToReal64.type->Type
      return Program.type_Real64

      #{
    method ConvertToString.type->Type
      return Program.type_String

    method ConvertToValue.type->Type
      return Program.type_Value

    method CastValueToXY.type->Type
      return Program.type_XY
      }#

    method Compare.type->Type
      return Program.type_Logical

    method CompareOp.type->Type
      return Program.type_Int32

    method ConvertToType.type->Type
      return to_type

    method CreateCompound.type->Type
      return of_type

    method CreateObject.type->Type
      return of_type

    method CreateObjectAndSetLocal.type->Type
      return of_type

      #{
    method CreateXY0.type->Type
      return Program.type_XY

    method CreateXY1.type->Type
      return Program.type_XY

    method CreateXY2.type->Type
      return Program.type_XY

    method Description.type->Type
      return Program.type_String
    }#

    method EmptyCompound.type->Type
      return of_type

    #{
    method EmptyList.type->Type
      return Program.type_Value
      }#

    method GenericFunctionDefinition.type->Type
      return Program.type_GenericFn

    method GetGlobalProperty.type->Type
      return info.@type

    method GetLocal.type->Type
      return info.@type

    method GetProperty.type->Type
      return info.@type

    method GetSingleton.type->Type
      return @type

    method GetThisProperty.type->Type
      return info.@type

    method GlobalPropertyDeclarations.type->Type
      return @type


      #{
    method ImportModule.type->Type
      return Program.type_Value

    method IndexedAccess.type->Type
      return context.type
}#
    method Is.type->Type
      return Program.type_Logical

    method IsNot.type->Type
      return Program.type_Logical

    method InstanceOf.type->Type
      return Program.type_Logical

    method IsCompound.type->Type
      return Program.type_Logical

    method IsPrimitive.type->Type
      return Program.type_Logical

    method IsReference.type->Type
      return Program.type_Logical

    method IsType.type->Type
      return Program.type_Logical

    method LiteralCharacter.type->Type
      return Program.type_Character

    method LiteralInt32.type->Type
      return Program.type_Int32

    method LiteralInt64.type->Type
      return Program.type_Int64

    method LiteralLogical.type->Type
      return Program.type_Logical

    method LiteralPi.type->Type
      return Program.type_Real

    method LiteralReal.type->Type
      return Program.type_Real

    method LiteralString.type->Type
      return Program.type_String

      #{
    method LiteralValueList.type->Type
      return Program.type_Value

    method LiteralValueUndefined.type->Type
      return Program.type_Value
      }#

    method Local.type->Type
      return @type

    method LocalDeclarations.type->Type
      return @type

    method LogicalAnd.type->Type
      return Program.type_Logical

    method LogicalNot.type->Type
      return Program.type_Logical

    method LogicalOr.type->Type
      return Program.type_Logical

    method LogicalXor.type->Type
      return Program.type_Logical

    method Logicalize.type->Type
      return Program.type_Logical

    method Logicalized.type->Type
      return Program.type_Logical

    method NamedArg.type->Type
      if (not value) return Program.type_Logical
      return value.type

    method NativeExpression.type->Type
      return result_type->(as Type)

    method Negate.type->Type
      return operand.type

    method LiteralNull.type->Type
      if (of_type) return of_type
      return Program.type_null

    method PreDecrementLocal.type->Type
      return info.type

    method PrintValue.type->Type
      return null

    method Property.type->Type
      return @type

    method PropertyDeclarations.type->Type
      return @type

    method This.type->Type
      return this_type

    method TypeAccess.type->Type
      return of_type

    method TypeContext.type->Type
      return @type

    method Unary.type->Type
      return operand.type

    method WideningCast.type->Type
      return to_type

endAugment
