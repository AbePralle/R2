module Rogue

augment Cmd
  GLOBAL METHODS
    method common_type( t:Token, a:Type, b:Type )->Type
      if (a is b) return a
      if (not a or not b) return null
      if (a.is_primitive and b.is_primitive)
        local type = Program.type_String
        if (a is type or b is type) return type
        type = Program.type_Real64
        if (a is type or b is type) return type
        type = Program.type_Real
        if (a is type or b is type) return type
        type = Program.type_Real32
        if (a is type or b is type) return type
        type = Program.type_Int64
        if (a is type or b is type) return type
        return Program.type_Int32  # any mismatched pair Logical/Byte/Character/Int32 -> Int32
      elseIf (a is Program.type_String or b is Program.type_String)
        return Program.type_String
      elseIf (a.is_reference)
        if (not b.is_reference) return a
        if (a.instance_of(b)) return b
        if (b.instance_of(a)) return a
      elseIf (b.is_reference)
        return b
      elseIf (a.is_compound)
        if (not b.is_compound) return a
      elseIf (b.is_compound)
        if (not a.is_compound) return b
      endIf
      throw t.error( "Incompatible types $ and $."(a,b) )

    method common_op_type( t:Token, a:Type, b:Type )->Type
      local type = common_type( t, a, b )
      if (not type.is_primitive) return type

      if (type is Program.type_Real64 or type is Program.type_Real32)
        return Program.type_Real
      elseIf (type is Program.type_Int64)
        return Program.type_Int64
      else
        return Program.type_Int32
      endIf

  METHODS
    method cmd_convert_to( target_type:Type )->Cmd
      local cur_type = require_type
      if (cur_type is target_type) return this
      return target_type.cmd_cast( this )

    method require_type->Type
      local result = type
      if (result) return result
      throw t.error( "Value expected ($)."(this) )  # FIXME

    method require_value->Cmd
      require_type
      return this

endAugment

# cmd_cast()
augment
  METHODS
    method Type.cmd_cast( cmd:Cmd )->Cmd
      throw UnsupportedOperationError()

    method TypeByte.cmd_cast( cmd:Cmd )->Cmd
      return ConvertToByte(cmd.t,cmd)

    method TypeCharacter.cmd_cast( cmd:Cmd )->Cmd
      return ConvertToCharacter(cmd.t,cmd)

    method TypeInt32.cmd_cast( cmd:Cmd )->Cmd
      return ConvertToInt32(cmd.t,cmd)

    method TypeInt64.cmd_cast( cmd:Cmd )->Cmd
      return ConvertToInt64(cmd.t,cmd)

    method TypeLogical.cmd_cast( cmd:Cmd )->Cmd
      return ConvertToLogical(cmd.t,cmd)

    method TypeReal32.cmd_cast( cmd:Cmd )->Cmd
      return ConvertToReal32(cmd.t,cmd)

    method TypeReal64.cmd_cast( cmd:Cmd )->Cmd
      return ConvertToReal64(cmd.t,cmd)

endAugment

# cmd_convert_to
augment
  METHODS
    method LiteralNull.cmd_convert_to( target_type:Type )->Cmd
      of_type = target_type
      return this
endAugment

#{
# cmd_default_value()
augment
  METHODS
    method Type.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralNull( cmd_t, this )

    method TypeCharacter.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralCharacter( cmd_t, 0 )

    method TypeInt32.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralInt32( cmd_t, 0 )

    method TypeLogical.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralLogical( cmd_t, false )

    method TypeReal64.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralReal( cmd_t, 0 )

    method TypeString.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralString( cmd_t, null )

    method TypeValue.cmd_default_value( cmd_t:Token )->Cmd
      return LiteralValueUndefined( cmd_t )
endAugment
}#

# discarding_result
augment
  METHODS
    method Cmd.discarding_result->Cmd
      return this  # no change

    method GetLocal.discarding_result->Cmd
      return null

    method Literal.discarding_result->Cmd
      return null
endAugment

# is_anchored
augment
  METHODS
    method Cmd.is_anchored->Logical
      return false

    method GetLocal.is_anchored->Logical
      return info.is_anchored

    method LiteralString.is_anchored->Logical
      return true

    method Local.is_anchored->Logical
      return attributes.is_anchored

    method This.is_anchored->Logical
      return true
endAugment

# is_literal
augment
  METHODS
    method Cmd.is_literal->Logical
      return false

    method Literal.is_literal->Logical
      return true

endAugment

# is_truthy
augment
  METHODS
    method Cmd.is_truthy->Logical
      return true

    method LiteralCharacter.is_truthy->Logical
      return value?

    method LiteralInt32.is_truthy->Logical
      return value?

    method LiteralInt64.is_truthy->Logical
      return value?

    method LiteralLogical.is_truthy->Logical
      return value

    method LiteralNull.is_truthy->Logical
      return false

    method LiteralReal32.is_truthy->Logical
      return value? and not value.is_NaN

    method LiteralReal64.is_truthy->Logical
      return value? and not value.is_NaN

endAugment

# is_operator
augment
  METHODS
    method Cmd.is_operator->Logical
      return false

    method Binary.is_operator->Logical
      return true

    method Unary.is_operator->Logical
      return true
endAugment

# is_type_context
augment
  METHODS
    method Cmd.is_type_context->Logical
      return false

    method TypeContext.is_type_context->Logical
      return true
endAugment

# type()
augment
  METHODS
    method Cmd.type->Type
      return null

      #{
    method Access.type->Type
      return Program.find_type(name)
      }#

    method AddAndAssign.type->Type
      return target.type

    method AddAndAssignLocal.type->Type
      return info.type

    method Binary.type->Type
      return common_type( t, left.type, right.type )

    method CallProcedure.type->Type
      return info.return_type

      #{
    method CastReal64ToInt32.type->Type
      return Program.type_Int32
      }#

    method ConvertToByte.type->Type
      return Program.type_Byte

    method ConvertToCharacter.type->Type
      return Program.type_Character

    method ConvertToInt32.type->Type
      return Program.type_Int32

    method ConvertToInt64.type->Type
      return Program.type_Int64

    method ConvertToLogical.type->Type
      return Program.type_Logical

    #method ConvertToObject.type->Type
    #  return Program.type_Object

    method ConvertToReal32.type->Type
      return Program.type_Real32

    method ConvertToReal64.type->Type
      return Program.type_Real64

      #{
    method ConvertToString.type->Type
      return Program.type_String

    method ConvertToValue.type->Type
      return Program.type_Value

    method CastValueToXY.type->Type
      return Program.type_XY
      }#

    method Compare.type->Type
      return Program.type_Logical

    method ConvertToType.type->Type
      return to_type

    method CreateObject.type->Type
      return of_type

    method CreateObjectAndSetLocal.type->Type
      return of_type

      #{
    method CreateXY0.type->Type
      return Program.type_XY

    method CreateXY1.type->Type
      return Program.type_XY

    method CreateXY2.type->Type
      return Program.type_XY

    method Description.type->Type
      return Program.type_String
    }#

    #{
    method EmptyList.type->Type
      return Program.type_Value
      }#

    method GetLocal.type->Type
      return info.@type

    method GetProperty.type->Type
      return info.@type

    method GetSingleton.type->Type
      return @type

    method GetThisProperty.type->Type
      return info.@type

      #{
    method ImportModule.type->Type
      return Program.type_Value

    method IndexedAccess.type->Type
      return context.type
}#
    method Is.type->Type
      return Program.type_Logical

    method IsNot.type->Type
      return Program.type_Logical

    method InstanceOf.type->Type
      return Program.type_Logical

    method IsCompound.type->Type
      return Program.type_Logical

    method IsPrimitive.type->Type
      return Program.type_Logical

    method IsReference.type->Type
      return Program.type_Logical

    method IsType.type->Type
      return Program.type_Logical

    method LiteralCharacter.type->Type
      return Program.type_Character

    method LiteralInt32.type->Type
      return Program.type_Int32

    method LiteralInt64.type->Type
      return Program.type_Int64

    method LiteralLogical.type->Type
      return Program.type_Logical

    #method LiteralNull.type->Type
      #return @type

    method LiteralPi.type->Type
      return Program.type_Real

    method LiteralReal.type->Type
      return Program.type_Real

    method LiteralString.type->Type
      return Program.type_String

      #{
    method LiteralValueList.type->Type
      return Program.type_Value

    method LiteralValueUndefined.type->Type
      return Program.type_Value
      }#

    method Local.type->Type
      return @type

    method LocalDeclarations.type->Type
      return @type

    method NativeExpression.type->Type
      return result_type->(as Type)

    method Negate.type->Type
      return operand.type

    method LiteralNull.type->Type
      if (of_type) return of_type
      return Program.type_null

    method PrintValue.type->Type
      return null

    method Property.type->Type
      return @type

    method PropertyDeclarations.type->Type
      return @type

    method This.type->Type
      return this_type

    method TypeContext.type->Type
      return @type

      #{
    method TypeRef.to->Type
      return Type( t, name )
    }#

    method Unary.type->Type
      return operand.type

    #{
    method XYGetX.type->Type
      return Program.type_Real

    method XYGetY.type->Type
      return Program.type_Real
      }#
endAugment
