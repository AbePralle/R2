module RogueC

class ResolveUsedElements : InspectionVisitor
  PROPERTIES
    is_modified : Logical

  METHODS
    method apply
      is_modified = true
      while (is_modified)
        is_modified = false
        Program.apply( this )

        forEach (type in (forEach in Program.modules).types)
          type.attributes.is_visiting = false
          (forEach in type.global_methods).attributes.is_visiting = false
          (forEach in type.methods).attributes.is_visiting = false
        endForEach
      endWhile

    method on_visit( mod:Module ) [override]
      assert( mod.m_on_launch )

      forEach (type in mod.types)
        if (type.attributes.is_essential)
          visit_type( type )
        endIf
      endForEach

    method on_visit_type( type:Type ) [override]
      if (type.attributes.is_visiting) return
      type.attributes.is_visiting = true

      if (not type.attributes.is_used)
        type.attributes.is_used = true
        is_modified = true
      endIf

      visit_type( (forEach in type.global_properties).type )

      temporarily this_type = type
        forEach (m in type.global_methods)
          if ((m.attributes.is_essential or m.attributes.is_api))
            temporarily this_module=m.module_context, this_procedure=m
              visit( m )
            endTemporarily
          endIf
        endForEach
      endTemporarily

      if (type.attributes.is_aspect) return

      if (type.base_class) visit_type( type.base_class )
      if (type.aspects)
        visit_type( forEach in type.aspects )
      endIf

      local m_init_object = type.methods["init_object()"]
      if (m_init_object and m_init_object.statements.count)
        temporarily this_procedure = m_init_object
          visit( m_init_object )
        endTemporarily
      endIf

      if (type.attributes.is_singleton)
        local m_init = type.methods["init()"]
        if (m_init and m_init.statements.count)
          temporarily this_procedure = m_init
            visit( m_init )
          endTemporarily
        endIf
      endIf

      visit_type( (forEach in type.properties).type )

      temporarily this_type = type
        forEach (m in type.methods)
          if (m.type_context is type)
            if ((m.attributes.is_essential or m.attributes.is_api))
              temporarily this_module=m.module_context, this_procedure=m
                visit( m )
              endTemporarily
            endIf
          endIf
        endForEach
      endTemporarily

    method on_visit( cmd:CallProcedure )
      visit( cmd.info )

    method on_visit( cmd:CallDynamicMethod )
      visit_dynamic_call( cmd.info )

    method on_visit( cmd:CallThisDynamicMethod )
      visit_dynamic_call( cmd.info )

    method visit_dynamic_call( info:Procedure )
      # As other types become used, additional methods may be visited here, which is
      # why we have to keep revisiting types and methods that are already used until
      # there are not further changes.
      forEach (m in Program.dynamic_methods[info.dynamic_signature])
        contingent
          sufficient (m.attributes.is_used)  # already marked used; revisit
          necessary  (not m.type_context.is_aspect)
          necessary  (not m.attributes.is_abstract)
          necessary  (m.type_context.attributes.is_used)
          necessary  (m.type_context.instance_of(info.type_context))
        satisfied
          visit( m )
        endContingent
      endForEach

    method on_visit( cmd:CreateObject )
      visit( cmd.m_init )

    method on_visit( cmd:CreateObjectAndSetLocal )
      visit( cmd.of_type )

    method on_visit( cmd:GetGlobalProperty )
      visit( cmd.info.type_context )
      visit( cmd.info )

    method on( m:Procedure )->Logical
      if (m.attributes.is_visiting or m.attributes.is_abstract) return false
      m.attributes.is_visiting = true

      if (not m.attributes.is_used)
        m.attributes.is_used = true
        is_modified = true
      endIf

      visit_type( m.type_context )

      m.resolve

      visit( (forEach in m.locals).type )

      visit_children( m )
      return false

    method on_visit( cmd:Type )
      visit_type( cmd )

endClass
