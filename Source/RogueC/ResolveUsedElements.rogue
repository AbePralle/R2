module RogueC

class ResolveUsedElements : InspectionVisitor
  PROPERTIES
    is_modified : Logical
    all_methods : Procedure[]
    m_call_global         : Procedure
    m_call_object         : Procedure
    cmd_call_global_cases : WhichCases
    cmd_call_object_cases : WhichCases

  METHODS
    method apply
      all_methods = Program.all_methods
      m_call_global         = Program.m_call_global
      m_call_object         = Program.m_call_object
      cmd_call_global_cases = Program.cmd_call_global_cases
      cmd_call_object_cases = Program.cmd_call_object_cases

      is_modified = true
      while (is_modified)
        is_modified = false
        Program.apply( this )

        forEach (type in (forEach in Program.modules).types)
          type.attributes.is_visiting = false
          (forEach in type.global_methods).attributes.is_visiting = false
          (forEach in type.methods).attributes.is_visiting = false
        endForEach

        # Add introspection call handlers if needed
        if (not is_modified)
          if (not Program.using_method_introspection)
            local type_MethodInfo = Program.default_module.types//MethodInfo
            if (type_MethodInfo)
              type_MethodInfo.resolve

              m_call_global = type_MethodInfo.global_methods["call_global_method(Rogue::Int32,Rogue::Value)"]
              assert m_call_global
              m_call_global.resolve
              local t = m_call_global.t
              cmd_call_global_cases = WhichCases(t)
              local cmd_which = Which( t, GetLocal(t,m_call_global.parameters[0]), cmd_call_global_cases,
                Statements(t,Return(t,LiteralUndefined(t))) ) : Cmd
              use resolver = ObjectPool<<Resolver>>
                resolver.this_module    = m_call_global.module_context
                resolver.this_type      = m_call_global.type_context
                resolver.this_procedure = m_call_global
                cmd_which = resolver.visit( cmd_which )
                visit( cmd_which )
                m_call_global.body.statements.insert( cmd_which )
              endUse

              cmd_call_object_cases = WhichCases(Program.t)
              m_call_object = type_MethodInfo.global_methods["call_object_method(Rogue::Value,Rogue::Int32,Rogue::Value)"]
              assert m_call_object
              m_call_object.resolve
              t = m_call_object.t
              cmd_call_object_cases = WhichCases(t)
              cmd_which = Which( t, GetLocal(t,m_call_object.parameters[1]), cmd_call_object_cases,
                  Statements(t,Return(t,LiteralUndefined(t))) )
              use resolver = ObjectPool<<Resolver>>
                resolver.this_module    = m_call_object.module_context
                resolver.this_type      = m_call_object.type_context
                resolver.this_procedure = m_call_object
                cmd_which = resolver.visit( cmd_which )
                visit( cmd_which )
                m_call_object.body.statements.insert( cmd_which )
              endUse

              local i = 0
              while (i < all_methods.count) add_introspection_call( all_methods[i] ); ++i

              Program.using_method_introspection = true
              Program.m_call_global         = m_call_global
              Program.m_call_object         = m_call_object
              Program.cmd_call_global_cases = cmd_call_global_cases
              Program.cmd_call_object_cases = cmd_call_object_cases

              is_modified = true
            endIf
          endIf
        endIf
      endWhile

    method on_visit( mod:Module ) [override]
      assert( mod.m_on_launch )

      forEach (type in mod.types)
        if (type.attributes.is_essential)
          visit_type( type )
        endIf
      endForEach

    method on_visit_type( type:Type ) [override]
      if (type.attributes.is_visiting) return
      type.attributes.is_visiting = true

      if (not type.attributes.is_used)
        type.attributes.is_used = true
        is_modified = true
      endIf

      visit_type( (forEach in type.global_properties).type )

      temporarily this_type = type
        forEach (m in type.global_methods)
          if ((m.attributes.is_essential or m.attributes.is_api))
            temporarily this_module=m.module_context, this_procedure=m
              visit( m )
            endTemporarily
          endIf
        endForEach
      endTemporarily

      if (type.attributes.is_aspect) return

      if (type.base_class) visit_type( type.base_class )
      if (type.aspects)
        visit_type( forEach in type.aspects )
      endIf

      local m_init_object = type.methods["init_object()"]
      if (m_init_object and m_init_object.statements.count)
        temporarily this_procedure = m_init_object
          visit( m_init_object )
        endTemporarily
      endIf

      if (type.attributes.is_singleton)
        local m_init = type.methods["init()"]
        if (m_init and m_init.statements.count)
          temporarily this_procedure = m_init
            visit( m_init )
          endTemporarily
        endIf
      endIf

      visit_type( (forEach in type.properties).type )

      temporarily this_type = type
        forEach (m in type.methods)
          if (m.type_context is type)
            if ((m.attributes.is_essential or m.attributes.is_api))
              temporarily this_module=m.module_context, this_procedure=m
                visit( m )
              endTemporarily
            endIf
          endIf
        endForEach
      endTemporarily

    method on_visit( cmd:CallProcedure )
      visit( cmd.info )

    method on_visit( cmd:CallDynamicMethod )
      visit_dynamic_call( cmd.info )

    method on_visit( cmd:CallThisDynamicMethod )
      visit_dynamic_call( cmd.info )

    method visit_dynamic_call( info:Procedure )
      # As other types become used, additional methods may be visited here, which is
      # why we have to keep revisiting types and methods that are already used until
      # there are not further changes.
      forEach (m in Program.dynamic_methods[info.dynamic_signature])
        contingent
          sufficient (m.attributes.is_used)  # already marked used; revisit
          necessary  (not m.type_context.is_aspect)
          necessary  (not m.attributes.is_abstract)
          necessary  (m.type_context.attributes.is_used)
          necessary  (m.type_context.instance_of(info.type_context))
        satisfied
          visit( m )
        endContingent
      endForEach

    method on_visit( cmd:CreateObject )
      visit( cmd.m_init )

    method on_visit( cmd:CreateObjectAndSetLocal )
      visit( cmd.of_type )

    method on_visit( cmd:GetGlobalProperty )
      visit( cmd.info.type_context )
      visit( cmd.info )

    method on( m:Procedure )->Logical
      if (m.attributes.is_visiting or m.attributes.is_abstract) return false
      m.attributes.is_visiting = true

      if (not m.attributes.is_used)
        m.attributes.is_used = true
        is_modified = true

        assert (not all_methods.contains(m))
        m.index = all_methods.count
        all_methods.add( m )

        if (Program.using_method_introspection) add_introspection_call( m )
      endIf

      visit_type( m.type_context )

      m.resolve

      visit( (forEach in m.locals).type )

      visit_children( m )
      return false

    method add_introspection_call( m:Procedure )
      local t = m.t

      local cmd_call : Cmd

      if (not m.type_context.is_compound or not m.attributes.is_mutating)
        # m(a,b) -> m( args[0].to<<TypeA>>, args[1].to<<TypeB>> )
        local args = Args(t)
        local dispatch_params = which{ m.is_global:m_call_global.parameters || m_call_object.parameters }
        local value_args_info = which{ m.is_global:dispatch_params[1] || dispatch_params[2] }
        forEach (p at i in m.parameters)
          local cmd = IndexedAccess( t, GetLocal(t,value_args_info), LiteralInt32(t,i) ) : Cmd # args[i]
          cmd = TemplatedMethodContextAccess( t, cmd, "to", p.type, Args(t) )  # args[i].to<<ArgType>>
          args.add( cmd )
        endForEach

        if (m.is_global)
          cmd_call = CallGlobalMethod( t, m, args )
        else
          cmd_call = CallStaticMethod( t,
            TemplatedMethodContextAccess(t,GetLocal(t,dispatch_params[0]),"to",m.type_context,Args(t)),
            m, args )
        endIf

        if (m.return_type)
          cmd_call = Return( t, TypeAccess(t, Program.type_Value,Args(t,cmd_call)) )
        endIf

        cmd_call = Statements( t, cmd_call )
      else
        cmd_call = Statements(t)
      endIf

      local cmd_case = WhichCase( t, Args(t,LiteralInt32(t,m.index)), cmd_call ) : Cmd
      use resolver = ObjectPool<<Resolver>>
        resolver.this_module    = m_call_object.module_context
        resolver.this_type      = m_call_object.type_context
        resolver.this_procedure = which{ m.is_global:m_call_global || m_call_object }
        cmd_case = resolver.visit( cmd_case )
        visit( cmd_case )
      endUse
      if (m.is_global) cmd_call_global_cases.add( cmd_case )
      else             cmd_call_object_cases.add( cmd_case )

    method on_visit( cmd:Type )
      visit_type( cmd )

endClass
