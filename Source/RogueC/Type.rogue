module Rogue

uses Utility/WorkList

class Type : Cmd
  PROPERTIES
    module_context    : Module
    name              : String
    base_class        : Type
    aspects           : Type[]
    extended_types    = Type[]
    attributes        : Attributes
    definitions       = StringTable<<Cmd>>()
    global_properties = StringTable<<Property>>()
    properties        = StringTable<<Property>>()
    native_properties = String[]
    global_methods    = StringTable<<GlobalMethod>>()
    methods           = StringTable<<Method>>()
    native_header     = NativeHeader[]
    native_code       = NativeCode[]
    type_args         : TemplateArgs
    _template         : Template
    class_def         : Cmd

    categories        : Category[]

    method_templates          = StringTable<<MethodTemplate>>()
    method_template_instances = StringTable<<Procedure>>()

    id                : Int32
    m_on_cleanup      : Method

    base_type_lookup_index  : Int32
    base_type_ids           = Int32[]

    is_type_organized    : Logical
    properties_organized : Logical
    methods_organizing   : Logical
    methods_organized    : Logical
    definitions_resolved : Logical
    is_resolved          : Logical

  GLOBAL METHODS
    method create( t:Token, name:String, type_args=null:TemplateArgs )->Type
      if (type_args)
        if (type_args.count)
          name = type_args->String(name)
        else
          type_args = null
        endIf
      endIf
      local type = Program.current_module.find_type( name, &extended_search )
      if (type) return type
      type = Type( t, name, 0, type_args )
      type.ensure_definition
      return type

    method create( t:Token, element_type:Type )->Type
      # Creates an ElementType[] / List<<ElementType>>
      local name = element_type.name + "[]"
      local type = Program.current_module.find_type( name, &extended_search )
      if (type) return type
      type = Type( t, name, 0, null )
      type.ensure_definition
      return type

    method create( t:Token, core_type:Type, optional:Logical )->Type
      # CoreType -> CoreType? -> Optional<<CoreType>>
      local name = core_type.name + "?"
      local type = Program.current_module.find_type( name, &extended_search )
      if (type) return type
      type = Type( t, name, 0, null )
      type.ensure_definition
      type.attributes.is_optional = true
      return type

  METHODS
    method init( t, name, attributes:Int64, type_args=null:TemplateArgs, &unlisted )
      init( t, Program.current_module, name, attributes, type_args, &=unlisted )

    method init( t, module_context, name, attributes:Int64, type_args=null, &unlisted )
      if (not unlisted) module_context.types[ name ] = this
      this.attributes = Attributes( t, attributes )

    method init( existing:Type )
      prior.init( existing )
      name   = existing.name
      c_name = existing.@c_name
      attributes = existing.attributes
      module_context = existing.module_context
      if (existing.categories) categories = existing.categories.cloned

    method add( m:GlobalMethod )
      local existing = global_methods[m.signature]
      if (existing and existing.type_context is m.type_context)
        throw m.t.error( "Global method $ is already defined."(m.dev_signature) )
      endIf
      global_methods[ m.signature ] = m

    method add( m:Method )
      local existing = methods[m.signature]
      if (existing and existing.type_context is m.type_context)
        throw m.t.error( "Method $ is already defined."(m.dev_signature) )
      endIf
      methods[ m.signature ] = m

    method add_property( p:Property )
      p.type_context = this

      if (not p.type)
        if (p.initial_value)
          p.type = p.initial_value.type
          if (not p.type)
            throw p.t.error(
              ''Cannot implicitly determine type of property "$" from initial value. ''(p.name) +
              ''Add an explicit ': Type' at the end of the line.''
            )
          endIf
        else
          throw p.t.error( ''Property "$" must have an initial assignment or a declared ': Type'.''(p.name) )
        endIf
      endIf

      p.type.organize_properties

      if (this.is_compound and p.type.is_compound)
        if (p.type.contains_embedded_compound(this))
          throw p.t.error(
              "Circular compound definition - $ directly or indirectly contains an embedded $, so $ cannot contain a $."...
              (p.type,this,this,p.type)
          )
        endIf
      endIf

      if (p.type.is_reference or (p.type.is_compound and p.type.contains_embedded_reference))
        this.attributes.contains_reference = true
      endIf

      local existing_p = this.properties[p.name]
      if (existing_p and existing_p.type_context is this)
        throw p.t.error( ''Type $ already defines a property called "$".''(this,p.name) )
      endIf
      this.properties[ p.name ] = p

    method add_extended_property( p:Property )
      local base_p = properties[p.name]
      if (base_p)
        if (not p.type.instance_of(base_p.type))
          throw p.t.error( "Redeclared property '$' has type $ which is not instanceOf inherited type $."...
            (p.name,p.type,base_p.type) )
        endIf
      endIf
      properties[p.name] = p

    method cloned->this
      return this

    method collect_compounds_and_primitives( type_list:Type[] )
      if (attributes.is_visiting or attributes.is_collected) return
      attributes.is_visiting = true
      (forEach in global_properties).type.collect_compounds_and_primitives( type_list )
      (forEach in properties).type.collect_compounds_and_primitives( type_list )
      if (this.is_compound or this.is_primitive)
        type_list.add( this )
        attributes.is_collected = true
      endIf
      attributes.is_visiting = false

    method collect_object_types( type_list:Type[] )
      if (attributes.is_visiting or attributes.is_collected) return
      attributes.is_visiting = true  # use as 'is_collected' flag; will be reset externally
      (forEach in global_properties).type.collect_object_types( type_list )
      (forEach in properties).type.collect_object_types( type_list )
      if (this.is_object)
        type_list.add( this )
        attributes.is_collected = true
      endIf
      attributes.is_visiting = false

    method collect_methods( m_name:String, list:Procedure[], &require_global )
      organize_methods

      forEach (m in global_methods)
        if (m.base_name == m_name) list.add( m )
      endForEach

      if (not require_global)
        forEach (m in methods)
          if (m.base_name == m_name) list.add( m )
        endForEach
      endIf

    method contains_embedded_compound( type:Type )->Logical
      forEach (p in properties)
        if (p.type is type) return true
        if (p.type.is_compound and p.type.contains_embedded_compound(type)) return true
      endForEach
      return false

    method contains_embedded_reference->Logical
      forEach (p in properties)
        if (p.type.is_reference) return true
        if (p.type.is_compound and p.type.contains_embedded_reference) return true
      endForEach
      return false

    method contains_reference->Logical
      return attributes.contains_reference

    method ensure_definition
      if (attributes.is_defined) return

      local template_name : String
      if (name.ends_with(']'))
        template_name = "List<<1>>"
        local tokens = Token[]
        tokens.add( forEach in Scanner(t.filepath,name.leftmost(-2),t.line,t.column).tokenize )
        tokens.remove_last  # EOL
        type_args = TemplateArgs(t).[ add(TokenList(t,tokens)) ]
      elseIf (name.ends_with('?'))
        template_name = "Optional<<1>>"
        local tokens = Token[]
        tokens.add( forEach in Scanner(t.filepath,name.leftmost(-1),t.line,t.column).tokenize )
        tokens.remove_last  # EOL
        type_args = TemplateArgs(t).[ add(TokenList(t,tokens)) ]
      else
        local type_arg_count = which{ type_args:type_args.count || 0 }
        template_name = "$<<$>>"(name.before_first('<'),type_arg_count)
      endIf

      local template = module_context.templates[template_name]
      if (template)
        template.generate( this )
      else
        throw t.error( "Reference to undefined class '$::$'."(module_context,name) )
      endIf

    method description->String
      return "$" (%name)

    method has_method_named( name:String )->Logical
      forEach (m in methods)
        if (m.name == name) return true
      endForEach
      return false

    method incorporate_global( aspect_m:GlobalMethod, &is_augment )
      aspect_m .= cloned
      AspectMethodPatcher.patch( this, aspect_m )

      local existing_m = global_methods[ aspect_m.signature ]
      if (existing_m)
        if (existing_m.return_type? xor aspect_m.return_type?)
          if (existing_m.return_type?)
            throw aspect_m.t.error( "Return type mismatch - existing global method $ does not return a value."...
                (existing_m.context_signature) )
          else
            throw aspect_m.t.error( "Return type mismatch - existing global method $ returns a value."...
                (existing_m.context_signature) )
          endIf
        endIf
        if (existing_m.return_type and existing_m.return_type is not aspect_m.return_type)
          throw aspect_m.t.error( "Return type mismatch - aspect method return type $ does not match existing return type $."...
          (aspect_m.return_type,existing_m.return_type) )
        endIf

        forEach (aspect_p at i in aspect_m.parameters)
          local existing_p = existing_m.parameters[i]
          if (aspect_p.name != existing_p.name)
            throw aspect_m.t.error(
              "Parameter name mismatch - aspect parameter '$' must be named '$' as in the existing method."...
              (aspect_p.name,existing_p.name)
            )
          endIf
        endForEach

      endIf

      if (existing_m)
        if (aspect_m.attributes.is_insert)
          aspect_m.statements.add( forEach in existing_m.statements )
          existing_m.body = aspect_m.body
          existing_m.statements = aspect_m.statements
        elseIf (aspect_m.attributes.is_append)
          existing_m.statements.add( forEach in aspect_m.statements )
        elseIf (existing_m.type_context is not this or is_augment)
          global_methods[ aspect_m.signature ] = aspect_m
        endIf
      else
        global_methods[ aspect_m.signature ] = aspect_m
      endIf

    method incorporate( aspect_m:Method, &is_augment )
      aspect_m .= cloned
      AspectMethodPatcher.patch( this, aspect_m )

      local existing_m = methods[ aspect_m.signature ]
      if (existing_m)
        if (existing_m.return_type? xor aspect_m.return_type?)
          if (existing_m.return_type?)
            throw aspect_m.t.error( "Return type mismatch - existing method $ does not return a value."...
                (existing_m.context_signature) )
          else
            throw aspect_m.t.error( "Return type mismatch - existing method $ returns a value."...
                (existing_m.context_signature) )
          endIf
        endIf
        if (existing_m.return_type and existing_m.return_type is not aspect_m.return_type)
          throw aspect_m.t.error( "Return type mismatch - aspect method return type $ does not match existing return type $."...
          (aspect_m.return_type,existing_m.return_type) )
        endIf

        forEach (aspect_p at i in aspect_m.parameters)
          local existing_p = existing_m.parameters[i]
          if (aspect_p.name != existing_p.name)
            throw aspect_m.t.error(
              "Parameter name mismatch - aspect parameter '$' must be named '$' as in the existing method."...
              (aspect_p.name,existing_p.name)
            )
          endIf
        endForEach

      endIf

      if (existing_m)
        if (aspect_m.attributes.is_insert)
          aspect_m.statements.add( forEach in existing_m.statements )
          existing_m.body = aspect_m.body
          existing_m.statements = aspect_m.statements
        elseIf (aspect_m.attributes.is_append)
          existing_m.statements.add( forEach in aspect_m.statements )
        elseIf (existing_m.type_context is not this or is_augment)
          methods[ aspect_m.signature ] = aspect_m
        endIf
      else
        methods[ aspect_m.signature ] = aspect_m
      endIf

    method instance_of( ancestor_type:Type )->Logical
      if (ancestor_type is Program.type_Object and this.is_reference) return true

      if (ancestor_type.is_aspect)
        local type = this
        while (type)
          if (type.aspects)
            if ((forEach in type.aspects) is ancestor_type) return true
          endIf
          type .= base_class
        endWhile
        return false
      else
        local type = this
        while (type)
          if (type is ancestor_type) return true

          type .= base_class
        endWhile
        return false
      endIf

    method is_aspect->Logical
      return attributes.is_aspect

    method is_compound->Logical
      return attributes.is_compound

    method is_enum->Logical
      return attributes.is_enum

    method is_object->Logical
      return attributes.is_object

    method is_primitive->Logical
      return attributes.is_primitive

    method is_reference->Logical
      return attributes.is_reference

    method is_value_type->Logical
      return attributes.is_primitive or attributes.is_compound

    method organize
      organize_type
      organize_properties
      organize_methods

    method organize_type
      if (is_type_organized) return
      is_type_organized = true

      ensure_definition

      TypeOrganizer( module_context ).visit( this, class_def )

      if (is_enum)
        if (base_class or aspects)
          throw t.error( "Rogue does not currently support enums with base types." )
        endIf
      endIf

      # Categorize base types
      if (base_class)
        base_class.organize_type
        if (base_class.contains_reference) attributes.contains_reference = true
        base_class.extended_types.add( this )
      elseIf (this.is_object and this is not Program.type_Object)
        base_class = Program.type_Object
        base_class.organize_type
        base_class.extended_types.add( this )
      endIf

      if (aspects)
        (forEach in aspects).organize_type

        # Build flat list of incorporated aspects. Each aspect will already have
        # a flat list of its own base aspects.
        use aspect_list = WorkList<<Type>>
          forEach (incorporated_aspect in aspects)
            if (incorporated_aspect.aspects)
              aspect_list.add( incorporated_aspect.aspects )
            endIf
            aspect_list.add( incorporated_aspect )
          endForEach
          aspects.clear
          aspects.add( aspect_list )
        endUse

        (forEach in aspects).extended_types.add( this )
      endIf

      # Check attributes
      if (attributes.is_singleton)
        if (is_aspect)    throw t.error( "Aspects cannot have singletons." )
        if (is_compound)  throw t.error( "Compounds cannot have singletons." )
        if (is_primitive) throw t.error( "Primitives cannot have singletons." )
        attributes.is_anchored = true # any SetSingleton command will disprove this
      endIf

    method organize_properties
      if (properties_organized) return
      properties_organized = true

      organize_type

      PropertyOrganizer( module_context ).visit( this, class_def )

      # Inherit properties
      if (base_class or aspects)
        use my_properties = WorkList<<Property>>
          my_properties.add( forEach in properties )
          properties.clear

          if (base_class)
            base_class.organize_properties
            if (base_class.contains_reference) attributes.contains_reference = true

            forEach (p in base_class.properties)
              properties[p.name] = p
            endForEach

            forEach (p in base_class.native_properties step -1)
              native_properties.insert( p )
            endForEach
          endIf

          if (aspects)
            forEach (incorporated_aspect in aspects)
              incorporated_aspect.organize_properties

              forEach (p in incorporated_aspect.native_properties step -1)
                native_properties.insert( p )
              endForEach

              forEach (p in incorporated_aspect.properties)
                add_extended_property( p.cloned.[type_context=this] )
              endForEach
            endForEach
          endIf

          forEach (p in my_properties)
            add_extended_property( p )
          endForEach

        endUse
      endIf

      if (this.instance_of(Program.type_ListType))
        local p_element_type = properties["element_type"]
        assert p_element_type
        if (p_element_type.type.is_reference)
          attributes.is_reference_list = true
          attributes.contains_reference = true
        endIf
      endIf

    method organize_methods
      if (methods_organizing) return
      methods_organizing = true
      organize_properties

      MethodOrganizer( module_context ).visit( this, class_def )

      # Organize base types
      if (base_class) base_class.organize_methods
      if (aspects)
        (forEach in aspects).organize_methods
      endIf

      # Add init_class() for global property initialization
      if (not is_aspect)
        local m = global_methods["init_class()"]
        if (not m)
          m = GlobalMethod( t, this, "init_class" )
          m.organize
          global_methods[ m.signature ] = m
        endIf

        use my_properties = WorkList<<Property>>
          my_properties.add( forEach in global_properties )

          forEach (p in my_properties step -1)
            if (not p.initial_value) p.initial_value = p.type.cmd_default_value( p.t )
            m.statements.insert( SetGlobalProperty(p.t,p,p.initial_value) )
          endForEach
        endUse

      endIf

      # Add init_object() methods for new initial property assignments
      if (is_object)
        local m = methods["init_object()"]
        if (not m)
          m = Method( t, this, "init_object" )
          m.organize
          methods[ m.signature ] = m
        endIf

        use my_properties = WorkList<<Property>>
          forEach (p in properties)
            if (p.type_context is this) my_properties.add( p )
          endForEach

          forEach (p in my_properties step -1)
            if (p.initial_value)
              local initial_value = p.initial_value.cloned
              AspectMethodPatcher.patch( this, initial_value )  # fix 'this' type
              m.statements.insert( SetThisProperty(p.t,p,initial_value) )
            endIf
          endForEach
          if (base_class)
            local prior_m = base_class.methods[ "init_object()" ]
            assert prior_m
            m.statements.insert( CallThisStaticMethod(m.t,prior_m,Args(m.t)) )
          endIf
        endUse
      endIf

      inherit_methods

      # Compounds get to->String and description->String. description() calls to->String by default.
      if (is_compound)
        block m = methods["description()"]
          if (not m)
            m = Method( t, this, "description" )
            m.return_type = Program.type_String
            m.statements.add( Return(t,Access(t,"to_String")) )
            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        if (not is_enum)
          block m = methods["to_String()"]
            if (not m)
              m = Method( t, this, "to_String" )
              m.return_type = Program.type_String
              m.statements.add( Return(t,LiteralString(t,name)) )
              m.organize
              methods[ m.signature ] = m
            endIf
          endBlock
        endIf
      endIf

      # Enums
      if (is_enum)
        # create(Int32) constructor
        block
          local m = GlobalMethod( t, this, "create" )
          m.parameters.add( Local(t,"value",Program.type_Int32) )
          m.return_type = this
          m.statements.add( Return(t, CreateCompound(t,this)) )
          m.organize
          global_methods[ m.signature ] = m
        endBlock

        # create(String) constructor
        block
          local m = GlobalMethod( t, this, "create" )
          m.parameters.add( Local(t,"name",Program.type_String) )
          m.return_type = this
          m.statements.add(
            ForEach( t,
              ForEachInControl( t, "category", null,
                ForEachCollection(t,null,Access(t,"categories"),null,null) ),
              Statements( t,
                If( t, CompareEQ(t,Access(t,"name"),Access(t,"category")),
                  Statements( t, Return(t,Access(t,"category")) ), null
                )
              )
            )
          )
          m.statements.add( Return(t,TypeAccess(t,this,Args(t,LiteralInt32(t,0)))) )
          m.organize
          global_methods[ m.signature ] = m
        endBlock

        # name()->String
        block
          local m = Method( t, this, "name" )
          m.return_type = Program.type_String

          local cmd_cases = WhichCases(t)
          local cmd_which = Which( t, Access(t,"value"), cmd_cases, Statements(t) )
          forEach (category in categories)
            local t = category.t
            local args = Args(t)
            args.add( EnumValue(t,this,category.name) )
            cmd_cases.add( WhichCase(t,args,Statements(t,Return(t,LiteralString(t,category.name)))) )
          endForEach
          cmd_which.statements.add( Return(t,FormattedString(t,name+"($)",Args(t,Access(t,"value")))) )
          m.statements.add( cmd_which )

          m.organize
          methods[ m.signature ] = m
        endBlock

        # operator==(EnumType)->Logical
        block
          local m = methods[ "operator==" ]
          if (not m)
            m = Method( t, this, "operator==" )
            m.parameters.add( Local(t,"other",this) )
            m.return_type = Program.type_Logical
            m.statements.add( Return(t,CompareEQ(t,Access(t,"value"),ContextAccess(t,Access(t,"other"),"value"))) )
            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        # to->Int32
        block
          local m = methods[ "to_Int32()" ]
          if (not m or m.type_context is not this)
            m = Method( t, this, "to_Int32" )
            m.return_type = Program.type_Int32
            m.statements.add( Return(t,Access(t,"value")) )
            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        # to->String
        block
          local m = methods[ "to_String()" ]
          if (not m or m.type_context is not this)
            m = Method( t, this, "to_String" )
            m.return_type = Program.type_String

            local cmd_cases = WhichCases(t)
            local cmd_which = Which( t, Access(t,"value"), cmd_cases, Statements(t) )
            forEach (category in categories)
              local t = category.t
              local args = Args(t)
              args.add( EnumValue(t,this,category.name) )
              cmd_cases.add( WhichCase(t,args,Statements(t,Return(t,LiteralString(t,category.name)))) )
            endForEach
            cmd_which.statements.add( Return(t,FormattedString(t,name+"($)",Args(t,Access(t,"value")))) )
            m.statements.add( cmd_which )

            m.organize
            methods[ m.signature ] = m
          endIf
        endBlock

        # Create a getter method with hard-coded results for each property of each category
        block
          forEach (p at i in class_def->(as Class).constructor_properties)
            if (not p.type) throw p.t.error( "Enum property '$' must specify a ':Type'."(p.name) )
            local m = Method( t, this, p.name )
            m.return_type = p.type

            local cmd_cases = WhichCases(t)
            local cmd_which = Which( t, Access(t,"value"), cmd_cases, Statements(t) )
            forEach (category in categories)
              if (category.args[i])
                local args = Args(category.t)
                args.add( EnumValue(category.t,this,category.name) )
                cmd_cases.add( WhichCase(category.t,args,Statements(category.t,Return(category.t,category.args[i]))) )
              endIf
            endForEach
            if (p.initial_value)
              cmd_which.statements.add( Return(p.t,p.initial_value) )
            else
              cmd_which.statements.add( Return(p.t,p.type.cmd_default_value(p.t)) )
            endIf
            m.statements.add( cmd_which )

            m.organize
            methods[ m.signature ] = m
          endForEach
        endBlock

      endIf

      Transformer().visit_type( this )

      methods_organized = true

    method inherit_methods( &missing_only )
      # Inherit base class methods
      if (base_class)
        local has_init = false
        forEach (m in methods)
          if (m.name == "init")
            has_init = true
            escapeForEach
          endIf
        endForEach

        forEach (base_m in base_class.methods)
          if (has_init and base_m.name == "init") nextIteration
          local m = methods[ base_m.signature ]
          if (m)
            if (m.return_type? xor base_m.return_type?)
              if (m.return_type?)
                throw m.t.error( "Return type mismatch - overridden method $ does not return a value."(base_m.context_signature) )
              else
                throw m.t.error( "Return type mismatch - overridden method $ returns a value."(base_m.context_signature) )
              endIf
            endIf
            if (m.return_type and not m.return_type.instance_of(base_m.return_type))
              throw m.t.error( "Return type mismatch - override return type $ is not instanceOf overridden return type $."...
                (m.return_type,base_m.return_type) )
            endIf
          else
            add( base_m )
          endIf
        endForEach
      endIf

      local this_is_abstract = this.attributes.is_abstract

      # Incorporate augment global methods
      if (aspects)
        # Incorporate non-insert, non-append methods first
        forEach (incorporated_aspect in aspects)
          if (incorporated_aspect.attributes.is_augment)
            forEach (aspect_m in incorporated_aspect.global_methods)
              if (not (aspect_m.attributes.is_insert or aspect_m.attributes.is_append))
                if (not missing_only or not global_methods.contains(aspect_m.signature))
                  if (this_is_abstract or not aspect_m.attributes.is_abstract)
                    incorporate_global( aspect_m, &is_augment )
                  endIf
                endIf
              endIf
            endForEach
          endIf
        endForEach

        # Incorporate [insert] and [append] methods
        forEach (incorporated_aspect in aspects)
          if (incorporated_aspect.attributes.is_augment)
            forEach (aspect_m in incorporated_aspect.global_methods)
              if (aspect_m.attributes.is_insert or aspect_m.attributes.is_append)
                if (not missing_only or not global_methods.contains(aspect_m.signature))
                  if (this_is_abstract or not aspect_m.attributes.is_abstract)
                    incorporate_global( aspect_m )
                  endIf
                endIf
              endIf
            endForEach
          endIf
        endForEach

        # Create an error if no implementation of an abstract aspect method has been supplied.
        if (not this_is_abstract)
          forEach (incorporated_aspect in aspects)
            forEach (aspect_m in incorporated_aspect.global_methods)
              if (aspect_m.attributes.is_abstract and not global_methods.contains(aspect_m.signature))
                throw aspect_m.t.error(
                "Illegal abstract global method $ in class $." (aspect_m,this) )
              endIf
            endForEach
          endForEach
        endIf
      endIf

      # Incorporate aspect/augment object methods
      if (aspects)
        # Incorporate non-insert, non-append methods first
        forEach (incorporated_aspect in aspects)
          forEach (aspect_m in incorporated_aspect.methods)
            if (not (aspect_m.attributes.is_insert or aspect_m.attributes.is_append))
              if (not missing_only or not methods.contains(aspect_m.signature))
                if (this_is_abstract or not aspect_m.attributes.is_abstract)
                  incorporate( aspect_m, &is_augment=incorporated_aspect.attributes.is_augment )
                endIf
              endIf
            endIf
          endForEach
        endForEach

        # Incorporate [insert] and [append] methods
        forEach (incorporated_aspect in aspects)
          forEach (aspect_m in incorporated_aspect.methods)
            if (aspect_m.attributes.is_insert or aspect_m.attributes.is_append)
              if (not missing_only or not methods.contains(aspect_m.signature))
                if (this_is_abstract or not aspect_m.attributes.is_abstract)
                  incorporate( aspect_m )
                endIf
              endIf
            endIf
          endForEach
        endForEach

        # Create an error if no implementation of an abstract aspect method has been supplied.
        if (not this_is_abstract)
          forEach (incorporated_aspect in aspects)
            forEach (aspect_m in incorporated_aspect.methods)
              if (aspect_m.attributes.is_abstract and not methods.contains(aspect_m.signature))
                throw aspect_m.t.error(
                  "Class $ must either be declared [abstract] or else supply a definition for abstract aspect method $." ...
                  (this,aspect_m) )
              endIf
            endForEach
          endForEach
        endIf

      endIf

      # Any [abstract] methods require an [abstract] class.
      if (not this.attributes.is_abstract)
        forEach (m in methods)
          if (m.attributes.is_abstract)
            if (m.type_context is this)
              throw m.t.error( "Method $ can only be declared [abstract] in an [abstract] class."(m) )
            else
              throw m.t.error( "Inherited abstract method $.$ be overridden or class $ must be declared [abstract]."...
                               (m.type_context,m,this) )
            endIf
          endIf
        endForEach

        forEach (m in global_methods)
          if (m.attributes.is_abstract)
            throw m.t.error( "Global methods cannot be [abstract]." )
          endIf
        endForEach
      endIf


    method precision_index->Int32
      return 10 # Objects etc.

    method resolve( resolver=null:Resolver )
      if (is_resolved) return

      ensure resolver
      temporarily resolver.this_module=module_context, resolver.this_procedure=null
        resolver.visit_type( this )
      endTemporarily

    method to->Character
      return Cmd.to_character(name)


    method to->Int32:  return name
    method to->Logical: return name?

    method to->String: return name

endClass

class BuiltInType : Type;

class TypeLogical : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Logical", Attribute.PRIMITIVE )

    method precision_index->Int32
      return 0
endClass

class TypeByte : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Byte", Attribute.PRIMITIVE )

    method precision_index->Int32
      return 1
endClass

class TypeCharacter : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Character", Attribute.PRIMITIVE )

    method precision_index->Int32
      return 2
endClass

class TypeInt32 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Int32", Attribute.PRIMITIVE )

    method precision_index->Int32
      return 3
endClass

class TypeInt64 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Int64", Attribute.PRIMITIVE )

    method precision_index->Int32
      return 4
endClass

class TypeReal32 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Real32", Attribute.PRIMITIVE )

    method precision_index->Int32
      return 5
endClass

class TypeReal64 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Real64", Attribute.PRIMITIVE )

    method precision_index->Int32
      return 6
endClass

class TypeString : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "String", Attribute.OBJECT )
endClass
