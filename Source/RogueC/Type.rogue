module Rogue

uses Utility/WorkList

class Type : Cmd
  PROPERTIES
    module_context    : Module
    name              : String
    base_class        : Type
    aspects           : Type[]
    attributes        : Attributes
    definitions       = StringTable<<Cmd>>()
    global_properties = StringTable<<Property>>()
    properties        = StringTable<<Property>>()
    global_methods    = StringTable<<GlobalMethod>>()
    methods           = StringTable<<Method>>()
    native_properties = String[]
    native_header     = NativeHeader[]
    native_code       = NativeCode[]
    type_args         : TemplateArgs
    id                : Int32

  GLOBAL METHODS
    method create( t:Token, name:String, type_args=null:TemplateArgs )->Type
      if (type_args)
        if (type_args.count)
          use builder = StringBuilder.pool
            builder.print name
            builder.print "<<"
            forEach (type at i in type_args)
              if (i) builder.print ','
              builder.print type->String
            endForEach
            builder.print ">>"
            name = builder->String
          endUse
        else
          type_args = null
        endIf
      endIf
      local type = Program.current_module.find_type( name, &extended_search )
      if (type) return type
      type = Type( t, name, 0, type_args )
      type.ensure_definition
      return type

  METHODS
    method init( t, name, attributes:Int32, type_args=null:TemplateArgs, &unlisted )
      init( t, Program.current_module, name, attributes, type_args, &=unlisted )

    method init( t, module_context, name, attributes:Int32, type_args=null, &unlisted )
      if (not unlisted) module_context.types[ name ] = this
      this.attributes = Attributes( t, attributes )

    method init( existing:Type )
      prior.init( existing )
      name   = existing.name
      c_name = existing.@c_name
      attributes = existing.attributes
      module_context = existing.module_context

    method add( m:GlobalMethod )
      global_methods[ m.signature ] = m
      # TODO: check for existing methods

    method add( m:Method )
      methods[ m.signature ] = m
      # TODO: check for existing methods

    method add_extended_property( p:Property )
      local base_p = properties[p.name]
      if (base_p)
        if (not p.type.instance_of(base_p.type))
          throw p.t.error( "Redeclared property '$' has type $ which is not instanceOf inherited type $."...
            (p.name,p.type,base_p.type) )
        endIf
      endIf
      properties[p.name] = p

    method cloned->this
      return this

    method collect_methods( m_name:String, list:Procedure[], &require_global )
      organize

      forEach (m in global_methods)
        if (m.name == m_name) list.add( m )
      endForEach

      if (not require_global)
        forEach (m in methods)
          if (m.name == m_name) list.add( m )
        endForEach
      endIf

    method ensure_definition
      if (attributes.is_defined) return

      local type_arg_count = which{ type_args:type_args.count || 0 }
      local template_name = "$<<$>>"(name.before_first('<'),type_arg_count)
      local template = module_context.templates[template_name]
      if (template)
        template.generate( type_args, this )
      else
        throw t.error( "Reference to undefined class '$::$'."(module_context,name) )
      endIf

    method description->String
      return "$" (%name)

    method incorporate( aspect_m:Method )
      local existing_m = methods[ aspect_m.signature ]

      if (existing_m)
        if (existing_m.return_type? xor aspect_m.return_type?)
          if (existing_m.return_type?)
            throw aspect_m.t.error( "Return type mismatch - existing method $ does not return a value."...
                (existing_m.context_signature) )
          else
            throw aspect_m.t.error( "Return type mismatch - existing method $ returns a value."...
                (existing_m.context_signature) )
          endIf
        endIf
        if (existing_m.return_type and existing_m.return_type is not aspect_m.return_type)
          throw existing_m.t.error( "Return type mismatch - aspect method return type $ does not match existing return type $."...
          (aspect_m.return_type,existing_m.return_type) )
        endIf
      endIf

      aspect_m .= cloned
      AspectMethodPatcher.patch( this, aspect_m )

      if (existing_m)
        if (aspect_m.attributes.is_insert)
          aspect_m.statements.add( forEach in existing_m.statements )
          methods[ aspect_m.signature ] = aspect_m
        elseIf (aspect_m.attributes.is_append)
          existing_m.statements.add( forEach in aspect_m.statements )
        else
          methods[ aspect_m.signature ] = aspect_m
        endIf
      else
        methods[ aspect_m.signature ] = aspect_m
      endIf

    method instance_of( ancestor_type:Type )->Logical
      if (ancestor_type is Program.type_Object and this.is_reference) return true

      if (ancestor_type.is_aspect)
        local type = this
        while (type)
          if (type.aspects)
            if ((forEach in type.aspects) is ancestor_type) return true
          endIf
          type .= base_class
        endWhile
        return false
      else
        local type = this
        while (type)
          if (type is ancestor_type) return true

          type .= base_class
        endWhile
        return false
      endIf

    method is_aspect->Logical
      return attributes.is_aspect

    method is_compound->Logical
      return attributes.is_compound

    method is_object->Logical
      return attributes.is_object

    method is_primitive->Logical
      return attributes.is_primitive

    method is_reference->Logical
      return attributes.is_reference

    method is_value_type->Logical
      return attributes.is_primitive or attributes.is_compound

    method organize
      if (attributes.is_organized) return
      attributes.is_organized = true
      ensure_definition

      # Organize base types
      if (base_class)
        base_class.organize
      elseIf (this.is_object and this is not Program.type_Object)
        base_class = Program.type_Object
        base_class.organize
      endIf

      if (aspects)
        (forEach in aspects).organize

        # Build flat list of incorporated aspects. Each aspect will already have
        # a flat list of its own base aspects.
        use aspect_list = WorkList<<Type>>
          forEach (incorporated_aspect in aspects)
            if (incorporated_aspect.aspects)
              aspect_list.add( incorporated_aspect.aspects )
            endIf
            aspect_list.add( incorporated_aspect )
          endForEach
          aspects.clear
          aspects.add( aspect_list )
        endUse
      endIf

      # Check attributes
      if (is_aspect)
        if (attributes.is_singleton) throw t.error( "Aspects cannot have singletons." )
      endIf

      # Inherit properties
      if (base_class or aspects)
        use my_properties = WorkList<<Property>>
          my_properties.add( forEach in properties )
          properties.clear

          if (base_class)
            forEach (p in base_class.properties)
              properties[p.name] = p
            endForEach

            forEach (p in base_class.native_properties step -1)
              native_properties.insert( p )
            endForEach
          endIf

          if (aspects)
            forEach (incorporated_aspect in aspects)
              forEach (p in incorporated_aspect.native_properties step -1)
                native_properties.insert( p )
              endForEach

              forEach (p in incorporated_aspect.properties)
                add_extended_property( p )
              endForEach
            endForEach
          endIf

          forEach (p in my_properties)
            add_extended_property( p )
          endForEach

        endUse
      endIf

      # Inherit base class methods
      if (base_class)
        local has_init = false
        forEach (m in methods)
          if (m.name == "init")
            has_init = true
            escapeForEach
          endIf
        endForEach

        forEach (base_m in base_class.methods)
          if (has_init and base_m.name == "init") nextIteration
          local m = methods[ base_m.signature ]
          if (m)
            if (m.return_type? xor base_m.return_type?)
              if (m.return_type?)
                throw m.t.error( "Return type mismatch - overridden method $ does not return a value."(base_m.context_signature) )
              else
                throw m.t.error( "Return type mismatch - overridden method $ returns a value."(base_m.context_signature) )
              endIf
            endIf
            if (m.return_type and not m.return_type.instance_of(base_m.return_type))
              throw m.t.error( "Return type mismatch - override return type $ is not instanceOf overridden return type $."...
                (m.return_type,base_m.return_type) )
            endIf
          else
            add( base_m )
          endIf
        endForEach
      endIf

      # Incorporate aspect methods
      if (aspects)
        # Incorporate non-insert, non-append methods first
        forEach (incorporated_aspect in aspects)
          forEach (aspect_m in incorporated_aspect.methods)
            if (not (aspect_m.attributes.is_insert or aspect_m.attributes.is_append))
              incorporate( aspect_m )
            endIf
          endForEach
        endForEach

        # Incorporate [insert] and [append] methods
        forEach (incorporated_aspect in aspects)
          forEach (aspect_m in incorporated_aspect.methods)
            if (aspect_m.attributes.is_insert or aspect_m.attributes.is_append)
              incorporate( aspect_m )
            endIf
          endForEach
        endForEach

      endIf

      #{
    method resolve
      if (attributes.is_resolved) return
      attributes.is_resolved = true
      organize
      }#

    method to->Character
      return Cmd.to_character(name)


    method to->Int32:  return name
    method to->Logical: return name?

    method to->String: return name

endClass

class BuiltInType : Type;

class TypeLogical : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Logical", Attribute.PRIMITIVE )
endClass

class TypeByte : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Byte", Attribute.PRIMITIVE )
endClass

class TypeCharacter : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Character", Attribute.PRIMITIVE )
endClass

class TypeInt32 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Int32", Attribute.PRIMITIVE )
endClass

class TypeInt64 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Int64", Attribute.PRIMITIVE )
endClass

class TypeReal32 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Real32", Attribute.PRIMITIVE )
endClass

class TypeReal64 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Real64", Attribute.PRIMITIVE )
endClass

class TypeString : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "String", Attribute.OBJECT )
endClass

