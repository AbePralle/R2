module Rogue

class Type : Cmd
  DEFINITIONS
    PRIMITIVE = 1
    OBJECT    = (1:<<:1)
    DEFINED   = (1:<<:2)
    ORGANIZED = (1:<<:3)
    RESOLVED  = (1:<<:4)

    ROGUE_ATTRIBUTE( is_primitive, Type.PRIMITIVE )
    ROGUE_ATTRIBUTE( is_object,    Type.OBJECT )
    ROGUE_ATTRIBUTE( is_defined,   Type.DEFINED )
    ROGUE_ATTRIBUTE( is_organized, Type.ORGANIZED )
    ROGUE_ATTRIBUTE( is_resolved,  Type.RESOLVED )

  PROPERTIES
    module_context    : Module
    name              : String
    attributes        : Int32
    global_properties = StringTable<<Property>>()
    properties        = StringTable<<Property>>()
    global_methods    = StringTable<<GlobalMethod>>()
    methods           = StringTable<<Method>>()
    native_properties = String[]
    native_header     = NativeHeader[]
    native_code       = NativeCode[]

  GLOBAL METHODS
    method create( t:Token, name:String )->Type
      local type = Program.current_module.find_type( name, &extended_search )
      if (type) return type
      type = Type( t, name, 0 )
      type.ensure_definition
      return type

  METHODS
    method init( t, name, attributes, &unlisted )
      init( t, Program.current_module, name, attributes, &=unlisted )

    method init( t, module_context, name, attributes, &unlisted )
      if (not unlisted) module_context.types[ name ] = this

    method init( existing:Type )
      prior.init( existing )
      name   = existing.name
      c_name = existing.@c_name
      attributes = existing.attributes
      module_context = existing.module_context

    method add( m:GlobalMethod )
      global_methods[ m.signature ] = m
      # TODO: check for existing methods

    method add( m:Method )
      methods[ m.signature ] = m
      # TODO: check for existing methods

    method cloned->this
      return this

    method collect_methods( m_name:String, list:Procedure[], &require_global )
      forEach (m in global_methods)
        if (m.name == m_name) list.add( m )
      endForEach

      if (not require_global)
        forEach (m in methods)
          if (m.name == m_name) list.add( m )
        endForEach
      endIf

    method ensure_definition
      if (is_defined) return

      if (is_primitive)
        is_defined = true # KLUDGE
        return
      endIf

      local template = module_context.templates[ "$<<0>>"(name) ]
      if (template)
        template.generate( null, this )
      else
        throw t.error( "Reference to undefined class '$::$'."(module_context,name) )
      endIf

    method description->String
      return "$" (%name)

    method is_reference->Logical
      return (attributes & OBJECT)?

    method to->Character
      return Cmd.to_character(name)

    method organize
      if (is_organized) return
      is_organized = true
      ensure_definition

      # TODO: organize base types, validate hierarchy
      # TODO: inherit base class methods

    method resolve
      if (is_resolved) return
      is_resolved = true
      organize

    method to->Int32:  return name
    method to->Logical: return name?
    method to->String: return name

endClass

class BuiltInType : Type;

class TypeLogical : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Logical", Type.PRIMITIVE )
endClass

class TypeByte : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Byte", Type.PRIMITIVE )
endClass

class TypeCharacter : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Character", Type.PRIMITIVE )
endClass

class TypeInt32 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Int32", Type.PRIMITIVE )
endClass

class TypeInt64 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Int64", Type.PRIMITIVE )
endClass

class TypeReal32 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Real32", Type.PRIMITIVE )
endClass

class TypeReal64 : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "Real64", Type.PRIMITIVE )
endClass

class TypeString : BuiltInType
  METHODS
    method init( t:Token )
      prior.init( t, "String", Type.OBJECT )
endClass

