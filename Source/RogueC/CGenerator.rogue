module Rogue

uses Utility/WorkList

class CGenerator : Visitor
  PROPERTIES
    writer         : CWriter
    autoname_index = 0

    visible_locals    = Local[]
    visible_locals_fp = Int32[]
    control_stack     = ControlStructure[]

  METHODS
    method init( writer )

    method autoname( base:String )->String
      local result = "_auto_$_$"(base,autoname_index)
      ++autoname_index
      return result

    method escape_label->String
      forEach (scope in control_stack step -1)
        if (scope.has_cleanup_code or scope.control_escapes)
          scope.control_escapes = true
          return scope.c_escape_label_name(this)
        endIf
      endForEach
      return null

    method escape_needs_jump( statement:Cmd )->Logical
      local current_scope = control_stack.last
      if (current_scope.has_cleanup_code and current_scope.statements.last is statement)
        return false
      endIf

      forEach (scope in control_stack step -1)
        if (scope.has_cleanup_code or scope.control_escapes)
          return true
        endIf
      endForEach

      return false

    method find_local( name:String )->Local
      forEach (v in visible_locals step -1)
        if (v.name == name) return v
      endForEach
      return null

    method print_with_cast( cmd:Cmd, to_type:Type )
      if (cmd.type is to_type)
        visit( cmd )
      else
        writer.print "(("
        writer.print to_type.c_ref_name
        writer.print ")"
        visit( cmd )
        writer.print ")"
      endIf

    method print_with_cast( cmd:String, from_type:Type, to_type:Type )
      writer.print_with_cast( cmd, from_type, to_type )

    method on_visit( cmd:Cmd )
      throw UnsupportedOperationError("CGenerator.on_visit($) [$]"(cmd.type_name,cmd))

    method on_visit( cmd:Access )
      #println StackTrace()
      throw cmd.t.error("[INTERNAL] CGenerator: unresolved Access '$'."(cmd.name))

    method on_visit( cmd:Add )
      writer.print '('
      print_parenthesized( cmd.left )
      writer.print " + "
      print_parenthesized( cmd.right )
      writer.print ')'

    method on_visit( cmd:AddAndAssignLocal )
      writer.print '('
      writer.print cmd.info.c_name
      writer.print " += "
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:AddAndAssignGlobalProperty )
      writer.print( cmd.info.c_name )
      writer.print( " += " )
      visit( cmd.operand )

    method on_visit( cmd:AddAndAssignProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " += "
      visit( cmd.operand )

    method on_visit( cmd:AddAndAssignThisProperty )
      writer.print "THIS"
      if (this_type.is_reference) writer.print "->"
      else                        writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " += "
      visit( cmd.operand )

    method on_visit( cmd:SubtractAndAssignLocal )
      writer.print '('
      writer.print cmd.info.c_name
      writer.print " -= "
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:SubtractAndAssignGlobalProperty )
      writer.print( cmd.info.c_name )
      writer.print( " -= " )
      visit( cmd.operand )

    method on_visit( cmd:SubtractAndAssignProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " -= "
      visit( cmd.operand )

    method on_visit( cmd:SubtractAndAssignThisProperty )
      writer.print "THIS"
      if (this_type.is_reference) writer.print "->"
      else                        writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " -= "
      visit( cmd.operand )

    method on_visit( cmd:MultiplyAndAssignLocal )
      writer.print '('
      writer.print cmd.info.c_name
      writer.print " *= "
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:MultiplyAndAssignGlobalProperty )
      writer.print( cmd.info.c_name )
      writer.print( " *= " )
      visit( cmd.operand )

    method on_visit( cmd:MultiplyAndAssignProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " *= "
      visit( cmd.operand )

    method on_visit( cmd:MultiplyAndAssignThisProperty )
      writer.print "THIS"
      if (this_type.is_reference) writer.print "->"
      else                        writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " *= "
      visit( cmd.operand )

    method on_visit( cmd:DivideAndAssignLocal )
      writer.print '('
      writer.print cmd.info.c_name
      writer.print " /= "
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:DivideAndAssignGlobalProperty )
      writer.print( cmd.info.c_name )
      writer.print( " /= " )
      visit( cmd.operand )

    method on_visit( cmd:DivideAndAssignProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " /= "
      visit( cmd.operand )

    method on_visit( cmd:DivideAndAssignThisProperty )
      writer.print "THIS"
      if (this_type.is_reference) writer.print "->"
      else                        writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " /= "
      visit( cmd.operand )

    method on_visit( cmd:BitwiseAndAndAssignLocal )
      writer.print '('
      writer.print cmd.info.c_name
      writer.print " &= "
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:BitwiseAndAndAssignGlobalProperty )
      writer.print( cmd.info.c_name )
      writer.print( " &= " )
      visit( cmd.operand )

    method on_visit( cmd:BitwiseAndAndAssignProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " &= "
      visit( cmd.operand )

    method on_visit( cmd:BitwiseAndAndAssignThisProperty )
      writer.print "THIS"
      if (this_type.is_reference) writer.print "->"
      else                        writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " &= "
      visit( cmd.operand )

    method on_visit( cmd:BitwiseOrAndAssignLocal )
      writer.print '('
      writer.print cmd.info.c_name
      writer.print " |= "
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:BitwiseOrAndAssignGlobalProperty )
      writer.print( cmd.info.c_name )
      writer.print( " |= " )
      visit( cmd.operand )

    method on_visit( cmd:BitwiseOrAndAssignProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " |= "
      visit( cmd.operand )

    method on_visit( cmd:BitwiseOrAndAssignThisProperty )
      writer.print "THIS"
      if (this_type.is_reference) writer.print "->"
      else                        writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " |= "
      visit( cmd.operand )

    method on_visit( cmd:BitwiseXorAndAssignLocal )
      writer.print '('
      writer.print cmd.info.c_name
      writer.print " ^= "
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:BitwiseXorAndAssignGlobalProperty )
      writer.print( cmd.info.c_name )
      writer.print( " ^= " )
      visit( cmd.operand )

    method on_visit( cmd:BitwiseXorAndAssignProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " ^= "
      visit( cmd.operand )

    method on_visit( cmd:BitwiseXorAndAssignThisProperty )
      writer.print "THIS"
      if (this_type.is_reference) writer.print "->"
      else                        writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " ^= "
      visit( cmd.operand )

    method on_visit( cmd:BitShiftLeftAndAssignLocal )
      writer.print '('
      writer.print cmd.info.c_name
      writer.print " <<= "
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:BitShiftLeftAndAssignGlobalProperty )
      writer.print( cmd.info.c_name )
      writer.print( " <<= " )
      visit( cmd.operand )

    method on_visit( cmd:BitShiftLeftAndAssignProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " <<= "
      visit( cmd.operand )

    method on_visit( cmd:BitShiftLeftAndAssignThisProperty )
      writer.print "THIS"
      if (this_type.is_reference) writer.print "->"
      else                        writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " <<= "
      visit( cmd.operand )

    method on_visit( cmd:BitShiftRightXAndAssignLocal )
      writer.print '('
      writer.print cmd.info.c_name
      writer.print " >>= "
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:BitShiftRightXAndAssignGlobalProperty )
      writer.print( cmd.info.c_name )
      writer.print( " >>= " )
      visit( cmd.operand )

    method on_visit( cmd:BitShiftRightXAndAssignProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " >>= "
      visit( cmd.operand )

    method on_visit( cmd:BitShiftRightXAndAssignThisProperty )
      writer.print "THIS"
      if (this_type.is_reference) writer.print "->"
      else                        writer.print "."
      writer.print( cmd.info.c_name )
      writer.print " >>= "
      visit( cmd.operand )

    method on_visit( cmd:CmdList )
      visit_children( cmd )

    method print_parenthesized( cmd:Cmd )
      if (cmd.is_operator)
        writer.print "("
        visit( cmd )
        writer.print ")"
      else
        visit( cmd )
      endIf

    method on_visit( cmd:CompareOp )
      print_parenthesized( cmd.left )
      writer.print " - "
      print_parenthesized( cmd.right )

    method on_visit( cmd:BitwiseAnd )
      print_parenthesized( cmd.left )
      writer.print " & "
      print_parenthesized( cmd.right )

    method on_visit( cmd:BitwiseNot )
      writer.print "~"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:BitwiseOr )
      print_parenthesized( cmd.left )
      writer.print " | "
      print_parenthesized( cmd.right )

    method on_visit( cmd:BitwiseXor )
      print_parenthesized( cmd.left )
      writer.print " ^ "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CallGlobalMethod )
      writer.print( cmd.info.c_name )
      if (cmd.args.count)
        writer.print "( "
        forEach (arg at i in cmd.args)
          if (i) writer.print ", "
          local p = cmd.info.parameters[i]
          print_with_cast( arg, p.type )
        endForEach
        writer.print " )"
      else
        writer.print "()"
      endIf

    method on_visit( cmd:CallDynamicMethod )
      if (cmd.context.type.is_aspect)
        local group = Program.dynamic_methods[cmd.info.signature]
        if (group.count == 1)
          writer.print( group.first.c_name )
        else
          writer.print "Rogue_dispatch_"
          writer.print( cmd.info.c_signature )
        endIf
      else
        if (cmd.info.attributes.dynamic_dispatch and cmd.info.attributes.is_overridden)
          writer.print "Rogue_dispatch_"
          writer.print( cmd.info.c_signature )
        else
          writer.print( cmd.info.c_name )
        endIf
      endIf

      if (cmd.args.count == 0)
        writer.print '('
        print_with_cast( cmd.context, cmd.info.type_context )
        writer.print ')'
      else
        writer.print "( "
        print_with_cast( cmd.context, cmd.info.type_context )

        forEach (arg at i in cmd.args)
          writer.print ", "
          local p = cmd.info.parameters[i]
          print_with_cast( arg, p.type )
        endForEach
        writer.print " )"
      endIf

    method on_visit( cmd:CallThisDynamicMethod )
      if (this_type.is_aspect)
        local group = Program.dynamic_methods[cmd.info.signature]
        if (group.count == 1)
          writer.print( group.first.c_name )
        else
          writer.print "Rogue_dispatch_"
          writer.print( cmd.info.c_signature )
        endIf
      else
        if (cmd.info.attributes.dynamic_dispatch and cmd.info.attributes.is_overridden)
          writer.print "Rogue_dispatch_"
          writer.print( cmd.info.c_signature )
        else
          writer.print( cmd.info.c_name )
        endIf
      endIf

      if (cmd.args.count == 0)
        writer.print '('
        print_with_cast( "THIS", this_type, cmd.info.type_context )
        writer.print ')'
      else
        writer.print "( "
        print_with_cast( "THIS", this_type, cmd.info.type_context )
        if (cmd.args.count)
          forEach (arg at i in cmd.args)
            writer.print ", "
            local p = cmd.info.parameters[i]
            print_with_cast( arg, p.type )
          endForEach
        endIf
        writer.print " )"
      endIf

    method on_visit( cmd:CallThisStaticMethod )
      writer.print( cmd.info.c_name )
      if (cmd.args.count == 0)
        writer.print '('
        print_with_cast( "THIS", this_type, cmd.info.type_context )
        writer.print ')'
      else
        writer.print "( "
        print_with_cast( "THIS", this_type, cmd.info.type_context )
        if (cmd.args.count)
          forEach (arg at i in cmd.args)
            writer.print ", "
            local p = cmd.info.parameters[i]
            print_with_cast( arg, p.type )
          endForEach
        endIf
        writer.print " )"
      endIf

    method on_visit( cmd:CallRoutine )
      writer.print( cmd.info.c_name )
      if (cmd.args.count)
        writer.print "( "
        forEach (arg at i in cmd.args)
          if (i) writer.print ", "
          local p = cmd.info.parameters[i]
          print_with_cast( arg, p.type )
        endForEach
        writer.print " )"
      else
        writer.print "()"
      endIf

    method on_visit( cmd:ConvertToByte )
      writer.print "((RogueByte)"
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:ConvertToCharacter )
      writer.print "((RogueCharacter)"
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:ConvertToInt32 )
      writer.print "((RogueInt32)"
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:ConvertToInt64 )
      writer.print "((RogueInt64)"
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:ConvertToLogical )
      writer.print "((RogueLogical)"
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:ConvertToReal32 )
      writer.print "((RogueReal32)"
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:ConvertToReal64 )
      writer.print "((RogueReal64)"
      print_parenthesized( cmd.operand )
      writer.print ')'

    method on_visit( cmd:CompareEQ )
      print_parenthesized( cmd.left )
      writer.print " == "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CompareNE )
      print_parenthesized( cmd.left )
      writer.print " != "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CompareLT )
      print_parenthesized( cmd.left )
      writer.print " < "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CompareGT )
      print_parenthesized( cmd.left )
      writer.print " > "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CompareLE )
      print_parenthesized( cmd.left )
      writer.print " <= "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CompareGE )
      print_parenthesized( cmd.left )
      writer.print " >= "
      print_parenthesized( cmd.right )

    method on_visit( cmd:Divide )
      writer.print '('
      print_parenthesized( cmd.left )
      writer.print " / "
      print_parenthesized( cmd.right )
      writer.print ')'

    method on_enter( cmd:ControlStructure, &is_procedure, &optional )
      push_scope( cmd )

      if (cmd.locals.count or is_procedure or not optional)
        writer.println( "{" )
        writer.indent += 2

        if (is_procedure)
          if (this_procedure.return_type and this_procedure.attributes.has_return and
              this_procedure.attributes.requires_cleanup)
            writer.print this_procedure.return_type.c_name
            if (this_procedure.return_type.is_reference) writer.print '*'
            writer.print   ' '
            writer.print   this_procedure.c_result_name
            writer.print " = "
            if (this_procedure.return_type.is_compound) writer.println "{};"
            else                                        writer.println "0;"
          endIf

          # Declare all local parameters.
          if (this_procedure.locals.count)
            forEach (v in this_procedure.locals)
              writer.print( v.type.c_ref_name ).print( ' ' )
              writer.print( v.c_name )
              writer.print( " = " )
              if (v.type.is_compound) writer.print "{}"
              else                    writer.print "0"
              writer.println( ';' )
            endForEach
            writer.println
          endIf

          if (this_procedure.has_cleanup_code and Program.gc_auto)
            forEach (p in this_procedure.parameters)
              if (not p.is_anchored)
                if (p.type.is_reference)
                  writer.print   "RogueType_local_pointer_stack_add( &TypeRogueObject, &"
                  writer.print   p.c_name
                  writer.println " );"
                elseIf (p.type.contains_reference)
                  writer.print   "RogueType_local_pointer_stack_add( &Type"
                  writer.print   p.type.c_name
                  writer.print   ", &"
                  writer.print   p.c_name
                  writer.println " );"
                endIf
              endIf
            endForEach

            forEach (v in this_procedure.locals)
              if (v.type.is_reference)
                writer.print   "RogueType_local_pointer_stack_add( &TypeRogueObject, &"
                writer.print   v.c_name
                writer.println " );"
              elseIf (v.type.contains_reference)
                writer.print   "RogueType_local_pointer_stack_add( &Type"
                writer.print   v.type.c_name
                writer.print   ", &"
                writer.print   v.c_name
                writer.println " );"
              endIf
            endForEach
            writer.println
          endIf
        endIf

      endIf

      visit( cmd.initialization )

    method on_leave( cmd:ControlStructure, &is_procedure, &optional )
      if (cmd.control_escapes)
        writer.print cmd.c_escape_label_name(this)
        writer.println ":;"
      endIf

      visit( cmd.@cleanup )

      pop_scope

      if (cmd.locals.count or is_procedure or not optional or cmd.has_cleanup_code)
        if (is_procedure)
          if (this_procedure.has_cleanup_code)
            if (Program.gc_auto)
              writer.println

              local pop_count = 0
              forEach (p in this_procedure.parameters)
                if (not p.is_anchored)
                  if (p.type.is_reference) ++pop_count
                endIf
              endForEach
              forEach (v in this_procedure.locals)
                if (v.type.is_reference) ++pop_count
              endForEach
              if (pop_count)
                writer.print   "TypeRogueObject.local_pointer_count -= "
                writer.print   pop_count
                writer.println ';'
              endIf

              use unique_compound_types = WorkList<<Type>>
                forEach (p in this_procedure.parameters)
                  if (not p.is_anchored)
                    if (p.type.is_compound and p.type.contains_reference)
                      if (not unique_compound_types.contains(p.type)) unique_compound_types.add( p.type )
                    endIf
                  endIf
                endForEach
                forEach (v in this_procedure.locals)
                  if (v.type.is_compound and v.type.contains_reference)
                    if (not unique_compound_types.contains(v.type)) unique_compound_types.add( v.type )
                  endIf
                endForEach

                forEach (type in unique_compound_types)
                  pop_count = 0
                  forEach (p in this_procedure.parameters)
                    if (not p.is_anchored)
                      if (p.type is type) ++pop_count
                    endIf
                  endForEach
                  forEach (p in this_procedure.locals)
                    if (p.type is type) ++pop_count
                  endForEach
                  if (pop_count)
                    writer.print   "Type"
                    writer.print   type.c_name
                    writer.print   ".local_pointer_count -= "
                    writer.print   pop_count
                    writer.println ';'
                  endIf
                endForEach
              endUse

              writer.println
            endIf
          endIf

          if (this_procedure.return_type and this_procedure.attributes.has_return and
              this_procedure.attributes.requires_cleanup)
            if (this_procedure.throws)
              writer.println "if (Rogue_execution_status == ROGUE_EXE_RETURN) Rogue_execution_status = ROGUE_EXE_CONTINUE;"
            elseIf (cmd.control_escapes)
              writer.println "Rogue_execution_status = ROGUE_EXE_CONTINUE;"
            endIf
            writer.print "return "
            writer.print this_procedure.c_result_name
            writer.println ';'
          endIf

        elseIf (cmd.control_escapes)
          localize escape_label
          if (escape_label)
            writer.print "if (Rogue_execution_status) goto "
            writer.print escape_label
            writer.println ";"
          endIf

        elseIf (cmd.has_cleanup_code)
          writer.println "if (Rogue_execution_status) return;"

        endIf

        writer.indent -= 2
        writer.println( "}" )
      endIf

    method on_visit( cmd:ControlStructure )
      on_enter( cmd )
      visit( cmd.statements )
      on_leave( cmd )

    method on_visit( cmd:CreateCompound )
      # This command only exists in the compound's primary create() global method.
      writer.print( "(" ).print( this_type.c_name ).print( ") " )
      writer.print '{'
      forEach (param at i in this_procedure.parameters)
        if (i > 0) writer.print ','
        writer.print(' ').print(param.c_name)
      endForEach
      writer.print " }"

    method on_visit( cmd:CreateObjectAndSetLocal )
      writer.print cmd.info.c_name
      writer.print " = "
      writer.print "ROGUE_CREATE_OBJECT( "
      writer.print cmd.of_type.c_name
      writer.print " )"

    method on_visit( cmd:GetLocal )
      writer.print( cmd.info.c_name )

    method on_visit( cmd:GetGlobalProperty )
      writer.print( cmd.info.c_name )

    method on_visit( cmd:GetProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )

    method on_visit( cmd:GetSingleton )
      writer.print "ROGUE_SINGLETON("
      writer.print cmd.type.c_name
      writer.print ")"

    method on_visit( cmd:GetThisProperty )
      writer.print "THIS"
      assert this_type
      if (this_type.is_reference) writer.print "->"
      else                        writer.print "."
      writer.print( cmd.info.c_name )

    method on_visit( cmd:GlobalMethod )
      if (cmd.type_context is not this_type) return

      this_type.write_c_global_method_header( cmd, writer )
      writer.println

      on_enter( cmd.body, &is_procedure )
      visit( cmd.statements )
      on_leave( cmd.body, &is_procedure )

      writer.println

    method on_visit( cmd:If )
      on_enter( cmd, &optional )
      if (cmd.condition)
        writer.print   "if ("
        visit( cmd.condition )
        writer.println ")"
      endIf

      visit( cmd.statements )

      if (cmd.cmd_else)
        writer.println "else "
        visit( cmd.cmd_else )
      endIf
      on_leave( cmd, &optional )

    method on_visit( cmd:InlineWhich )
      # a:x || b:y || c
      # ->
      # (a) ? (x) : ((b) ? (y) : (c))
      local first_case = cmd.cases[0]
      print_parenthesized( first_case.condition )
      writer.print " ? "
      print_parenthesized( first_case.value )
      writer.print " : "
      write_case( cmd, 1 )

    method write_case( cmd:InlineWhich, i:Int32 )
      local cur_case = cmd.cases[i]
      if (i+1 < cmd.cases.count)
        writer.print '('
        print_parenthesized( cur_case.condition )
        writer.print " ? "
        print_parenthesized( cur_case.value )
        writer.print " : "
        write_case( cmd, i+1 )
        writer.print ')'
      else
        print_parenthesized( cur_case.value )
      endIf

    method on_visit( cmd:InstanceOf )
      writer.print "Rogue_instance_of("
      visit( cmd.operand )
      writer.print ", &"
      writer.print( cmd.compare_type.c_name ).print( ')' )

    method on_visit( cmd:Is )
      print_parenthesized( cmd.left )
      writer.print " == "
      print_parenthesized( cmd.right )

    method on_visit( cmd:IsNot )
      print_parenthesized( cmd.left )
      writer.print " != "
      print_parenthesized( cmd.right )

    method on_visit( cmd:IsType )
      writer.print "Rogue_is_type("
      visit( cmd.operand )
      writer.print ", &"
      writer.print( cmd.compare_type.c_name ).print( ')' )

    method on_visit( cmd:Iterator )
      on_enter( cmd )
      local control_label = autoname("loop_condition")
      writer.print   "goto "
      writer.print   control_label
      writer.println ";"
      writer.println "do"
      writer.println "{"
      writer.indent += 2
      visit( cmd.statements )
      visit( cmd.upkeep )
      writer.print   control_label
      writer.println ":;"
      visit( cmd.control )
      writer.indent -= 2
      writer.println "}"
      writer.print   "while ("
      visit( cmd.condition )
      writer.println ");"
      on_leave( cmd )

    method on_visit( cmd:LiteralCharacter )
      if (cmd.value >= 32)
        writer.print '\''
        which (cmd.value)
          case '\\': writer.print '\\'
          case '\'': writer.print '\\'
        endWhich
        writer.print( cmd.value )
        writer.print '\''
      else
        writer.print "((RogueCharacter)"
        writer.print cmd.value->Int32
        writer.print ")"
      endIf

    method on_visit( cmd:LiteralInt32 )
      writer.print( cmd.value )

    method on_visit( cmd:LiteralInt64 )
      writer.print cmd.value
      writer.print "LL"

    method on_visit( cmd:LiteralLogical )
      writer.print which{ cmd.value:1 || 0 }

    method on_visit( cmd:LiteralNull )
      writer.print 0

    method on_visit( cmd:LiteralPi )
      writer.print pi

    method on_visit( cmd:LiteralReal )
      writer.print cmd.value

    method on_visit( cmd:LiteralString )
      local c_id = Program.unique_strings[cmd.value]
      if (not c_id) trace cmd.value
      assert c_id
      writer.print( c_id )

    method on_visit( cmd:LogicalAnd )
      print_parenthesized( cmd.left )
      writer.print " && "
      print_parenthesized( cmd.right )

    method on_visit( cmd:LogicalNot )
      writer.print "!"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:LogicalOr )
      print_parenthesized( cmd.left )
      writer.print " || "
      print_parenthesized( cmd.right )

    method on_visit( cmd:Logicalized )
      writer.print "!!"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:Method )
      if (cmd.type_context is not this_type) return

      this_type.write_c_method_header( cmd, writer )
      writer.println

      on_enter( cmd.body, &is_procedure )
      visit( cmd.statements )
      on_leave( cmd.body, &is_procedure )

      writer.println

    method on_visit( cmd:Mod )
      if (cmd.type is Program.type_Real64)     writer.print "Rogue_mod_Real64"
      elseIf (cmd.type is Program.type_Real32) writer.print "Rogue_mod_Real32"
      elseIf (cmd.type is Program.type_Int64)  writer.print "Rogue_mod_Int64"
      else                                     writer.print "Rogue_mod_Int32"
      writer.print '('
      visit( cmd.left )
      writer.print ','
      visit( cmd.right )
      writer.print ')'

    method on_visit( cmd:Multiply )
      print_parenthesized( cmd.left )
      writer.print " * "
      print_parenthesized( cmd.right )

    method on_visit( cmd:NativeExpression )
      print_native_code( cmd.t, cmd.content )

    method on_visit( cmd:NativeStatement )
      print_native_code( cmd.t, cmd.content )
      writer.println

    method on_visit( cmd:Negate )
      writer.print '-'
      print_parenthesized( cmd.operand )

    method on_visit( cmd:Power )
      writer.print '('
      writer.print cmd.left.type.c_name
      writer.print ")pow("
      visit( cmd.left )
      writer.print ","
      visit( cmd.right )
      writer.print ')'

    method on_visit( cmd:PreDecrement )
      writer.print "--"
      visit( cmd.operand )

    method on_visit( cmd:PreIncrement )
      writer.print "++"
      visit( cmd.operand )

    method on_visit( cmd:PostDecrement )
      visit( cmd.operand )
      writer.print "--"

    method on_visit( cmd:PostIncrement )
      visit( cmd.operand )
      writer.print "++"

    method on( cmd:Procedure )->Cmd
      this_procedure = cmd
      autoname_index = 0

      visible_locals_fp.add( visible_locals.count )
      forEach (p in cmd.parameters)
        visible_locals.add( p->(as Local) )
      endForEach

      handle( cmd )

      visible_locals.discard_from( visible_locals_fp.remove_last )
      return cmd

    method on_visit( cmd:Return )
      if (not this_procedure.attributes.requires_cleanup)
        writer.print "return"
        if (cmd.result)
          writer.print ' '
          visit( cmd.result )
        endIf
        writer.println ";"
        return
      endIf

      if (cmd.result)
        writer.print this_procedure.c_result_name
        writer.print " = "
        visit( cmd.result )
        writer.println ";"
      endIf

      if (escape_needs_jump(cmd))
        writer.println "Rogue_execution_status = ROGUE_EXE_RETURN;"
        writer.print   "goto "
        writer.print   escape_label
        writer.println ';'

      elseIf (control_stack.last.has_cleanup_code)
        writer.println "Rogue_execution_status = ROGUE_EXE_RETURN;"

      elseIf (control_stack.count > 1)
        writer.print "return"
        if (this_procedure.return_type)
          writer.print ' '
          writer.print this_procedure.c_result_name
        endIf
        writer.println ';'
      endIf

    method on_visit( cmd:ReturnOnException )
      if (escape_needs_jump(cmd))
        writer.print "if (Rogue_execution_status) goto "
        writer.print escape_label
      else
        writer.print "if (Rogue_execution_status) return"
        if (this_procedure.return_type) writer.print " 0"
      endIf
      writer.println ';'

    method on_visit( cmd:Routine )
      this_module.write_c_routine_header( cmd, writer )
      writer.println

      on_enter( cmd.body, &is_procedure )
      visit( cmd.statements )
      on_leave( cmd.body, &is_procedure )

      writer.println

    method on_visit( cmd:SetGlobalProperty )
      writer.print( cmd.info.c_name )
      writer.print( " = " )
      visit( cmd.new_value )

    method on_visit( cmd:SetLocal )
      writer.print( cmd.info.c_name )
      writer.print( " = " )
      visit( cmd.new_value )

    method on_visit( cmd:SetProperty )
      visit( cmd.context )
      if (cmd.context.type.is_reference) writer.print "->"
      else                               writer.print "."
      writer.print( cmd.info.c_name )
      writer.print( " = " )
      visit( cmd.new_value )

    method on_visit( cmd:SetThisProperty )
      writer.print( "THIS->" )
      writer.print( cmd.info.c_name )
      writer.print( " = " )
      visit( cmd.new_value )

    method on_visit( cmd:BitShiftLeft )
      print_parenthesized( cmd.left )
      writer.print " << "
      print_parenthesized( cmd.right )

    method on_visit( cmd:BitShiftRightX )
      print_parenthesized( cmd.left )
      writer.print " >> "
      print_parenthesized( cmd.right )

    method on_visit( cmd:Statements )
      forEach (statement in cmd)
        visit( statement )
        if (statement.needs_semicolon) writer.println( ';' )
      endForEach

    method on_visit( cmd:Subtract )
      print_parenthesized( cmd.left )
      writer.print " - "
      print_parenthesized( cmd.right )

    method on_visit( cmd:This )
      writer.print "THIS"

    method on_visit( cmd:Throw )
      writer.print   "Rogue_exception = "
      visit( cmd.exception )
      writer.println ';'
      writer.println "Rogue_execution_status = ROGUE_EXE_EXCEPTION;"
      if (escape_needs_jump(cmd))
        writer.print "goto "
        writer.print escape_label
      else
        writer.print "return"
        if (this_procedure.return_type) writer.print " 0"
      endIf

    method on_visit( cmd:WideningCast )
      print_with_cast( cmd.operand, cmd.to_type )

    method pop_scope
      visible_locals.discard_from( visible_locals_fp.remove_last )
      control_stack.remove_last

    method push_scope( cmd:ControlStructure )
      control_stack.add( cmd )
      visible_locals_fp.add( visible_locals.count )
      visible_locals.add( forEach in cmd.locals )

    method print_native_code( t:Token, code:String )
      block
        # Replace $<<TypeName>> with C type name
        local i1 = code.locate("$<<")
        while (i1)
          local i2 = code.locate( ">>", i1 )
          if (not i2)
            throw t.error( "Use of unterminated '$<<' variable marker." )
          endIf

          local marker = code.from(i1.value+3,i2.value-1)
          code = code.leftmost(i1.value) + native_replacement(t,marker,&type) + code.from(i2.value+2)
          i1 = code.locate("$<<",i1)
        endWhile
      endBlock

      block
        # Replace $varname with e.g. localname_0 or THIS->property_name
        local i1 = code.locate('$')
        while (i1)
          local i2 = i1.value
          while (i2+1 < code.count)
            local ch = code[i2+1]
            if (not (ch.is_letter or ch.is_number or ch == '_')) escapeWhile
            ++i2
          endWhile

          local marker = code.from(i1.value+1,i2)
          code = code.leftmost(i1.value) + native_replacement(t,marker) + code.from(i2+1)
          i1 = code.locate( '$', i1 )
        endWhile
      endBlock

      writer.print code

    method native_replacement( t:Token, name:String, &type )->String
      forEach (v in visible_locals)
        if (name == v.name)
          if (type) return v.type.c_ref_name
          else      return v.c_name
        endIf
      endForEach

      if (this_type)
        if (this_procedure.is_method)
          if (name == "this")
            if (type) return this_type.c_ref_name
            else      return "THIS"
          endIf

          forEach (p in this_type.properties)
            if (name == p.name)
              if (type) return p.type.c_ref_name
              else      return "THIS->" + p.c_name
            endIf
          endForEach
        endIf

        forEach (p in this_type.global_properties)
          if (name == p.name)
            if (type) return p.type.c_ref_name
            else      return p.c_name
          endIf
        endForEach
      endIf

      throw t.error( "No such variable '$' exists in current scope."(name) )
endClass

# write_print()
augment
  METHODS
    method Cmd.write_print( writer:CWriter )
      throw UnsupportedOperationError("[INTERNAL] $.write_print() [$]"(type_name,this))

    method LiteralInt32.write_print( writer:CWriter )
      writer.print ''printf( "%d", $ )'' (value)

    method LiteralString.write_print( writer:CWriter )
      writer.print ''printf( "$" )'' (value.to_escaped_ascii(''"''))
endAugment

augment
  METHODS
    method Cmd.needs_semicolon->Logical
      return true

    method ControlStructure.needs_semicolon->Logical
      return false

    method Return.needs_semicolon->Logical
      return false

    method ReturnOnException.needs_semicolon->Logical
      return false

    method Module.write_c_routine_header( r:Routine, writer:CWriter )
      if (r.return_type)
        writer.print( r.return_type.c_name )
        if (r.return_type.is_reference) writer.print '*'
      else
        writer.print "void"
      endIf
      writer.print ' '
      writer.print( r.c_name )
      writer.print( "(" )
      forEach (p at i in r.parameters)
        block p = p->(as Local)
          if (i) writer.print ", "
          writer.print( p.type.c_name )
          if (p.type.is_reference) writer.print '*'
          writer.print ' '
          writer.print( p.c_name )
        endBlock
      endForEach
      writer.print( ")" )

    method Module.generate_c_class_structs( writer:CWriter )
      forEach (type in types)
        if (type.is_object or type.is_compound)
          writer.print   "struct "
          writer.print   type.c_name
          writer.println
          writer.println '{'
          writer.indent  += 2
          if (type.is_object)
            writer.println "RogueType* type;"
            writer.println "RogueInt32 refcount;"
          endIf
          forEach (p in type.properties)
            writer.print   p.type.c_name
            if (p.type.is_reference) writer.print '*'
            writer.print   ' '
            writer.print   p.c_name
            writer.println ';'
          endForEach
          writer.println (forEach in type.native_properties)
          writer.indent  -= 2
          writer.println "};"
          writer.println
        endIf
        writer.println( forEach in type.native_header )

        if (type.is_reference or type.contains_reference or type is Program.type_Object)
          writer.print( "void " ).print( type.c_name ).println( "_gc_trace( void* THIS );" )
          writer.println
        endIf

      endForEach

    method Module.generate_c_class_typedefs( writer:CWriter )
      writer.println "typedef struct RogueType RogueType;"

      forEach (type in types)
        if (type.is_object or type.is_compound)
          writer.print   "typedef struct "
          writer.print   type.c_name
          writer.print   ' '
          writer.print   type.c_name
          writer.println ";"
        endIf
      endForEach
      writer.println

      forEach (type in types)
        if (type.is_object or type.is_compound)
          writer.print "extern RogueType Type"
          writer.print type.c_name
          writer.println ";"
        endIf
      endForEach
      writer.println

    method Module.generate_c_header( writer:CWriter )
      if (native_headers.count)
        writer.println forEach in native_headers
        writer.println
      endIf

      forEach (r in routines)
        write_c_routine_header( r, writer )
        writer.println ";"
      endForEach
      writer.println

      (forEach in types).generate_c_header( writer )

    method Module.generate_c_code( writer:CWriter )
      if (native_code.count)
        writer.println forEach in native_code
        writer.println
      endIf

      if (types.count)
        forEach (type in types)
          if (type.is_primitive or type.is_aspect) nextIteration

          if (type.attributes.is_singleton)
            writer.print   type.c_name
            if (type.is_reference) writer.print '*'
            writer.print   ' '
            writer.print   type.c_name
            writer.println "_singleton = 0;"
            writer.println
          endIf

          forEach (p in type.global_properties)
            writer.print p.type.c_ref_name
            writer.print ' '
            writer.print p.c_name
            if (p.type.is_compound) writer.println "= {};"
            else                    writer.println "= 0;"
          endForEach

          writer.print   "RogueType Type"
          writer.print   type.c_name
          writer.print   '' = { "''
          writer.print   type.module_context.name
          writer.print   ''", "''
          writer.print   type.name
          writer.print   ''", ''
          writer.print   "0, " # local_pointer_stack
          writer.print   "0, " # local_pointer_capacity
          writer.print   "0, " # local_pointer_count
          writer.print   type.id
          writer.print   '', sizeof(''
          writer.print   type.c_name
          writer.print   ''), ''

          local m_init_object = type.methods["init_object()"]
          if (m_init_object)
            writer.print   ''(RogueFn_Object)''
            writer.print   m_init_object.c_name
          else
            writer.print   "0"
          endIf
          writer.print ", "

          local default_constructor = type.methods["init()"]
          if (default_constructor)
            writer.print   ''(RogueFn_Object)''
            writer.print   default_constructor.c_name
          else
            writer.print   "0"
          endIf

          # fn_gc_trace
          writer.print ", "
          if (type.is_object)
            writer.print "(RogueFn_Object)"
            if (type.contains_reference) writer.print type.c_name
            else                         writer.print "RogueObject"
            writer.print "_gc_trace"
          else
            writer.print '0'
          endIf

          writer.print ", 0" # fn_on_cleanup

          writer.println '' };''
        endForEach
        writer.println

        forEach (type in types)
          forEach (code in type.native_code)
            writer.println code->String
            writer.println
          endForEach
        endForEach
        writer.println

        (forEach in types).generate_c_code( writer )
      endIf

      CGenerator(writer).visit_routines( this )

    method Module.generate_c_class_initialization( writer:CWriter )
      forEach (type in types)
        if (type.is_aspect) nextIteration
        local m = type.global_methods["init_class()"]
        writer.print( m.c_name ).println( "();" )
      endForEach
      writer.println

    method Module.generate_c_launch_commands( writer:CWriter )
      local r = routines[ "on_launch()" ]
      if (r and r.statements.count)
        writer.print( r.c_name ).println( "();" )
      endIf

    method NativeStatement.needs_semicolon->Logical
      return false

    method Program.generate_c
      apply( CSpecializer() )
      apply( EscapeAnalyzer() )

      local h_writer = CWriter( File("Test.h"), &header )

      h_writer.println ...
        @|//------------------------------------------------------------------------------
         |// Generated
         |//------------------------------------------------------------------------------
      (forEach in modules).generate_c_class_typedefs( h_writer )
      (forEach in modules).generate_c_class_structs( h_writer )
      (forEach in modules).generate_c_header( h_writer )

      local wrote_any = false
      forEach (group in Program.dynamic_methods)
        if (group.count == 1) nextIteration
        write_c_dispatch_method_header( group, h_writer )
        h_writer.println ';'
        wrote_any = true
      endForEach
      if (wrote_any) h_writer.println

      forEach (str in Program.unique_strings)
        h_writer.print   "extern RogueString* "
        h_writer.print   str
        h_writer.println ';'
      endForEach

      h_writer.close

      #-------------------------------------------------------------------------

      local c_writer = CWriter( File("Test.c") )

      (forEach in modules).generate_c_code( c_writer )

      forEach (group in Program.dynamic_methods)
        if (group.count == 1) nextIteration
        write_c_dispatch_method_header( group, c_writer )
        c_writer.println
        c_writer.println '{'
        c_writer.indent += 2
        c_writer.println "switch (((RogueObject*)THIS)->type->id)"
        c_writer.println '{'
        c_writer.indent += 2
        local last_m = group.last
        forEach (m in group)
          if (m is not last_m)
            c_writer.print "case "
            c_writer.print m.type_context.id
          else
            c_writer.print "default"
          endIf
          c_writer.print ": "
          if (m.return_type) c_writer.print "return "
          c_writer.print m.c_name
          c_writer.print "(("
          c_writer.print m.type_context.c_ref_name
          c_writer.print ")THIS"
          forEach (i of m.parameters)
            c_writer.print ",p"
            c_writer.print i
          endForEach
          if (m.return_type) c_writer.println ");"
          else               c_writer.println "); return;"
        endForEach
        c_writer.indent -= 2
        c_writer.println '}'
        c_writer.indent -= 2
        c_writer.println '}'
        c_writer.println
      endForEach

      forEach (str in Program.unique_strings)
        c_writer.print   "RogueString* "
        c_writer.print   str
        c_writer.println ';'
      endForEach

      c_writer.println @|
                        |void Rogue_launch()
                        |{
      c_writer.indent += 2
      Program.generate_c_string_literals( c_writer )
      (forEach in modules).generate_c_class_initialization( c_writer )
      (forEach in modules).generate_c_launch_commands( c_writer )
      c_writer.indent -= 2
      c_writer.println @|}
                        |
                        |int main( int argc, char* argv[] )
                        |{
                        |  Rogue_launch();
                        |  return 0;
      c_writer.println @|}

      c_writer.close

    method Program.generate_c_string_literals( writer:CWriter )
      if (Program.unique_strings.count)
        forEach (entry in Program.unique_strings.entries)
          writer.print   entry.value
          writer.print   " = RogueString_create( "
          writer.print_literal_c_string( entry.key )
          writer.println ", -1, 0 );"
        endForEach
        writer.println
      endIf

    method Program.write_c_dispatch_method_header( group:Method[], writer:CWriter )
      local m = group.first  # any method will do; they all share the same signature
      if (m.return_type)
        writer.print( m.return_type.c_ref_name )
      else
        writer.print "void"
      endIf
      writer.print " Rogue_dispatch_"
      writer.print( m.c_signature )
      writer.print( "( void* THIS" )
      forEach (p at i in m.parameters)
        writer.print ", "
        writer.print( p.type.c_ref_name )
        writer.print ' '
        writer.print "p"
        writer.print i
      endForEach
      writer.print( " )" )

    method Statements.needs_semicolon->Logical
      return false

    method Type.generate_c_header( writer:CWriter )
      if (is_aspect) return

      if (attributes.is_singleton)
        writer.print   "extern "
        writer.print   c_name
        if (is_reference) writer.print '*'
        writer.print   ' '
        writer.print   c_name
        writer.println "_singleton;"
        writer.println
      endIf

      forEach (p in global_properties)
        writer.print "extern "
        writer.print p.type.c_ref_name
        writer.print ' '
        writer.print p.c_name
        writer.println ';'
      endForEach

      forEach (m in global_methods)
        if (m.type_context is this)
          write_c_global_method_header( m, writer )
          writer.println ';'
        endIf
      endForEach

      forEach (m in methods)
        if (m.type_context is this)
          write_c_method_header( m, writer )
          writer.println ';'
        endIf
      endForEach

    method Type.generate_c_code( writer:CWriter )
      if (is_aspect) return

      if (is_reference or contains_reference or this is Program.type_Object)
        writer.print( "void " ).print( c_name ).println( "_gc_trace( void* THIS )" )
        writer.println '{'
        writer.indent += 2

        if (is_reference)
          writer.println "((RogueObject*)THIS)->refcount = ~((RogueObject*)THIS)->refcount;"
        endIf

        contingent
          forEach (p in properties)
            sufficient (p.type.is_reference)
          endForEach

        satisfied
          writer.println
          if (contains_reference) writer.println "RogueObject* ref;"
          forEach (p in properties)
            if (p.type.is_reference)
              writer.print   "if ((ref = (RogueObject*)(("
              writer.print   c_name
              writer.print   "*)THIS)->"
              writer.print   p.c_name
              writer.println ") && ref->refcount >= 0) ref->type->fn_gc_trace(ref);"
            elseIf (p.type.contains_reference)
              use path = WorkList<<String>>
                path.add( "if ((ref = (RogueObject*)((" )
                path.add( c_name )
                path.add( "*)THIS)->" )
                path.add( p.c_name )
                print_gc_checks( path, p, writer )
              endUse
            endIf
          endForEach

          if (attributes.is_reference_list)
            writer.println
            writer.print   "RogueObject** cursor = ((RogueObject**)(("
            writer.print   c_name
            writer.println "*)THIS)->data) - 1;"
            writer.print   "int n = ((int)(("
            writer.print   c_name
            writer.println "*)THIS)->capacity);"
            writer.println @|while (--n >=0)
                            |{
                            |  if ((ref = *(++cursor)) && ref->refcount >= 0) ref->type->fn_gc_trace(ref);
                            |}
          endIf

        endContingent

        writer.indent -= 2
        writer.println '}'
        writer.println
      endIf

      local cgen = CGenerator( writer )
      cgen.visit_global_methods( this )
      cgen.visit_methods( this )

    method Type.print_gc_checks( path:String[], p:Property, writer:CWriter )
      forEach (p2 in p.type.properties)
        if (p2.type.is_reference)
          writer.print( forEach in path )
          writer.print   '.'
          writer.print   p2.c_name
          writer.println ") && ref->refcount >= 0) ref->type->fn_gc_trace(ref);"
        elseIf (p2.type.contains_reference)
          path.add( p2.c_name )
          path.add( '.' )
          print_gc_checks( path, p2, writer )
          path.remove_last
          path.remove_last
        endIf
      endForEach


    method Type.write_c_global_method_header( m:GlobalMethod, writer:CWriter )
      if (m.return_type)
        writer.print( m.return_type.c_name )
        if (m.return_type.is_reference) writer.print '*'
      else
        writer.print "void"
      endIf
      writer.print ' '
      writer.print( m.c_name )
      writer.print( "(" )
      forEach (p at i in m.parameters)
        block p = p->(as Local)
          if (i) writer.print ", "
          writer.print( p.type.c_name )
          if (p.type.is_reference) writer.print '*'
          writer.print ' '
          writer.print( p.c_name )
        endBlock
      endForEach
      writer.print( ")" )

    method Type.write_c_method_header( m:Method, writer:CWriter )
      if (m.return_type)
        writer.print( m.return_type.c_name )
        if (m.return_type.is_reference) writer.print '*'
      else
        writer.print "void"
      endIf
      writer.print ' '
      writer.print( m.c_name )
      writer.print( "( " )
      writer.print m.type_context.c_name
      if (m.type_context.is_reference) writer.print '*'
      writer.print " THIS"
      forEach (p at i in m.parameters)
        block p = p->(as Local)
          writer.print ", "
          writer.print( p.type.c_name )
          if (p.type.is_reference) writer.print '*'
          writer.print ' '
          writer.print( p.c_name )
        endBlock
      endForEach
      writer.print( " )" )

endAugment

