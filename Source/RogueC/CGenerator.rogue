module Rogue

augment Procedure
  PROPERTIES
    c_name : String

  METHODS
    method c_name->String
      throw UnsupportedOperationError()
endAugment

augment Type
  PROPERTIES
    c_name : String   # e.g. RogueString
    c_type : String   # e.g. RogueString*

  METHODS
    method c_type->String
      if (@c_type) return @c_type
      @c_type = c_name
      if (is_reference) @c_type += "*"
      return @c_type

    method c_name->String
      if (@c_name) return @c_name
      @c_name = "$$" (module_context.c_name,name)
      return @c_name

endAugment

augment
  METHODS
    method Cmd.needs_semicolon->Logical
      return true

    method ControlStructure.needs_semicolon->Logical
      return false

    method Module.c_name->String
      return name

    method Module.write_c_routine_header( r:Routine, writer:CWriter )
      if (r.return_type)
        writer.print( r.return_type.c_name )
        if (r.return_type.is_reference) writer.print '*'
      else
        writer.print "void"
      endIf
      writer.print ' '
      writer.print( r.c_name )
      writer.print( "(" )
      forEach (p at i in r.parameters)
        block p = p->(as Local)
          if (i) writer.print ','
          writer.print( p.type.c_name )
          writer.print ' '
          writer.print( p.c_name )
        endBlock
      endForEach
      writer.print( ")" )

    method Module.generate_c_class_structs( writer:CWriter )
      forEach (type in types)
        if (not type.is_primitive)
          writer.print   "struct "
          writer.print   type.c_name
          writer.println
          writer.println '{'
          writer.indent  += 2
          writer.println "RogueType* type;"
          writer.println "RogueInt32 ref_count;"
          forEach (p in type.properties)
            writer.print   p.type.c_name
            writer.print   ' '
            writer.print   p.c_name
            writer.println ';'
          endForEach
          writer.println (forEach in type.native_properties)
          writer.indent  -= 2
          writer.println "};"
          writer.println
        endIf
        writer.println( forEach in type.native_header )
      endForEach

    method Module.generate_c_class_typedefs( writer:CWriter )
      writer.println "typedef struct RogueType RogueType;"

      forEach (type in types)
        if (not type.is_primitive)
          writer.print   "typedef struct "
          writer.print   type.c_name
          writer.print   ' '
          writer.print   type.c_name
          writer.println ";"
        endIf
      endForEach
      writer.println

      forEach (type in types)
        writer.print "extern RogueType Type"
        writer.print type.c_name
        writer.println ";"
      endForEach
      writer.println

    method Module.generate_c_header( writer:CWriter )
      forEach (r in routines)
        write_c_routine_header( r, writer )
        writer.println ";"
      endForEach
      writer.println

    method Module.generate_c_code( writer:CWriter )
      if (types.count)
        forEach (type in types)
          writer.print   "RogueType Type"
          writer.print   type.c_name
          writer.print   '' = { "''
          writer.print   type.module_context.name
          writer.print   ''", "''
          writer.print   type.name
          writer.print   ''", sizeof(''
          writer.print   type.c_name
          writer.println '') };''
        endForEach
        writer.println

        forEach (type in types)
          forEach (code in type.native_code)
            writer.println code->String
            writer.println
          endForEach
        endForEach
        writer.println
      endIf

      forEach (r in routines)
        CGenerator( this, writer ).visit( r )
        writer.println
      endForEach

    method Module.generate_c_launch_commands( writer:CWriter )
      local r = routines[ "on_launch()" ]
      if (r and r.statements.count)
        writer.print( r.c_name ).println( "();" )
      endIf

    method Property.c_name->String
      return name

    method Routine.c_name->String
      if (@c_name) return @c_name
      use builder = StringBuilder.pool
        builder.print( module_context.c_name ).print( "__" ).print( name )
        # TODO: parameter types
        c_name = builder
        return @c_name
      endUse

    method Program.generate_c
      (forEach in modules).specialize_c

      local h_writer = CWriter( File("Test.h"), &header )

      h_writer.println ...
        @|//------------------------------------------------------------------------------
         |// Generated
         |//------------------------------------------------------------------------------
      (forEach in modules).generate_c_class_typedefs( h_writer )
      (forEach in modules).generate_c_class_structs( h_writer )

      (forEach in modules).generate_c_header( h_writer )

      forEach (str in Program.unique_strings)
        h_writer.print   "extern RogueString* "
        h_writer.print   str
        h_writer.println ';'
      endForEach

      h_writer.close

      local c_writer = CWriter( File("Test.c") )

      (forEach in modules).generate_c_code( c_writer )

      forEach (str in Program.unique_strings)
        c_writer.print   "RogueString* "
        c_writer.print   str
        c_writer.println ';'
      endForEach

      c_writer.println @|
                        |void Rogue_launch()
                        |{
      c_writer.indent += 2
      Program.generate_c_string_literals( c_writer )
      (forEach in modules).generate_c_launch_commands( c_writer )
      c_writer.indent -= 2
      c_writer.println @|}
                        |
                        |int main( int argc, char* argv[] )
                        |{
                        |  Rogue_launch();
                        |  return 0;
      c_writer.println @|}

      c_writer.close

    method Program.generate_c_string_literals( writer:CWriter )
      forEach (entry in Program.unique_strings.entries)
        writer.print   entry.value
        writer.print   " = RogueString_create( "
        writer.print_literal_c_string( entry.key )
        writer.println ", -1, 0 );"
      endForEach
      writer.println

endAugment

class CGenerator : Visitor
  PROPERTIES
    writer         : CWriter
    this_module    : Module
    this_type      : Type
    this_procedure : Procedure
    autoname_index = 0

  METHODS
    method init( this_module, writer )

    method autoname( base:String )->String
      local result = "_auto_$_$"(base,autoname_index)
      ++autoname_index
      return result

    method on_visit( cmd:Cmd )
      throw UnsupportedOperationError("CGenerator.on_visit($)"(cmd.type_name))

    method on_visit( cmd:Access )
      #println StackTrace()
      throw cmd.t.error("[INTERNAL] CGenerator: unresolved Access '$'."(cmd.name))

    method on_visit( cmd:CmdList )
      visit_children( cmd )

    method print_parenthesized( cmd:Cmd )
      if (cmd.is_operator)
        writer.print "("
        visit( cmd )
        writer.print ")"
      else
        visit( cmd )
      endIf

    method on_visit( cmd:BitwiseAnd )
      print_parenthesized( cmd.left )
      writer.print " & "
      print_parenthesized( cmd.right )

    method on_visit( cmd:BitwiseNot )
      writer.print "~"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:BitwiseOr )
      print_parenthesized( cmd.left )
      writer.print " | "
      print_parenthesized( cmd.right )

    method on_visit( cmd:BitwiseXor )
      print_parenthesized( cmd.left )
      writer.print " ^ "
      print_parenthesized( cmd.right )

    method on_visit( cmd:Block )
      writer.println '{'
      writer.indent += 2
      visit_children( cmd )
      writer.indent -= 2
      writer.println '}'

    method on_visit( cmd:CallRoutine )
      writer.print( cmd.info.c_name )
      writer.print '('
      if (cmd.args)
        forEach (arg at i in cmd.args)
          if (i) writer.print ','
          visit( arg )
        endForEach
      endIf
      writer.print ')'

    method on_visit( cmd:CastToByte )
      writer.print "(RogueByte)"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:CastToCharacter )
      writer.print "(RogueCharacter)"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:CastToInt32 )
      writer.print "(RogueInt32)"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:CastToInt64 )
      writer.print "(RogueInt64)"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:CastToLogical )
      writer.print "(RogueLogical)"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:CastToReal32 )
      writer.print "(RogueReal32)"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:CastToReal64 )
      writer.print "(RogueReal64)"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:CompareEQ )
      print_parenthesized( cmd.left )
      writer.print " == "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CompareNE )
      print_parenthesized( cmd.left )
      writer.print " != "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CompareLT )
      print_parenthesized( cmd.left )
      writer.print " < "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CompareGT )
      print_parenthesized( cmd.left )
      writer.print " > "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CompareLE )
      print_parenthesized( cmd.left )
      writer.print " <= "
      print_parenthesized( cmd.right )

    method on_visit( cmd:CompareGE )
      print_parenthesized( cmd.left )
      writer.print " >= "
      print_parenthesized( cmd.right )

    method on_enter( cmd:ControlStructure )
      writer.println( "{" )
      writer.indent += 2

      forEach (v in cmd.locals)
        writer.print( v.type.c_type ).print( ' ' )
        writer.print( v.c_name )
        writer.print( " = " )
        writer.print "0"
        #if (v.type.is_reference)     writer.print "0"
        #elseIf (v.type.is_primitive) writer.print "0"
        #else                     throw t.error( "[INTERNAL] Unhandled type $ in C.write_local_declarations()."(v.type) )
        writer.println( ';' )
      endForEach

      visit( cmd.initialization )

    method on_leave( cmd:ControlStructure )
      writer.indent -= 2
      writer.println( "}" )

    method on_visit( cmd:ControlStructure )
      on_enter( cmd )
      visit( cmd.statements )
      on_leave( cmd )

    method on_visit( cmd:DiscardResult )
      writer.print "/* discard */ "
      visit_children( cmd )

    method on_visit( cmd:GetLocal )
      writer.print( cmd.info.c_name )

    method on_visit( cmd:If )
      on_enter( cmd )
      if (cmd.condition)
        writer.print   "if ("
        visit( cmd.condition )
        writer.println ")"
      endIf
      writer.println "{"
      writer.indent += 2
      visit( cmd.statements )
      writer.indent -= 2
      writer.println "}"
      if (cmd.cmd_else)
        writer.println "else "
        visit( cmd.cmd_else )
      endIf
      on_leave( cmd )

    method on_visit( cmd:Iterator )
      on_enter( cmd )
      local control_label = autoname("loop_condition")
      writer.print   "goto "
      writer.print   control_label
      writer.println ";"
      writer.println "do"
      writer.println "{"
      writer.indent += 2
      visit( cmd.statements )
      visit( cmd.upkeep )
      writer.print   control_label
      writer.println ":;"
      visit( cmd.control )
      writer.indent -= 2
      writer.println "}"
      writer.print   "while ("
      visit( cmd.condition )
      writer.println ");"
      on_leave( cmd )

    method on_visit( cmd:LiteralInt32 )
      writer.print( cmd.value )

    method on_visit( cmd:LiteralLogical )
      writer.print which{ cmd.value:1 || 0 }

    method on_visit( cmd:LiteralPi )
      writer.print pi

    method on_visit( cmd:LiteralString )
      writer.print( Program.unique_strings[cmd.value] )

    #method on_visit( cmd:LocalDeclarations )
    #  visit_children( cmd )

    #method on_visit( cmd:LocalDef )

    method on_visit( cmd:LogicalAnd )
      print_parenthesized( cmd.left )
      writer.print " && "
      print_parenthesized( cmd.right )

    method on_visit( cmd:LogicalNot )
      writer.print "!"
      print_parenthesized( cmd.operand )

    method on_visit( cmd:LogicalOr )
      print_parenthesized( cmd.left )
      writer.print " || "
      print_parenthesized( cmd.right )

    method on_visit( cmd:Mod )
      if (cmd.type is Program.type_Real64)    writer.print "Rogue_mod_Real64"
      elseIf (cmd.type is Program.type_Int64) writer.print "Rogue_mod_Int64"
      else                                    writer.print "Rogue_mod_Int32"
      writer.print '('
      visit( cmd.left )
      writer.print ','
      visit( cmd.right )
      writer.print ')'

    method on_visit( cmd:Multiply )
      print_parenthesized( cmd.left )
      writer.print " * "
      print_parenthesized( cmd.right )

    method on_visit( cmd:Negate )
      writer.print '-'
      print_parenthesized( cmd.operand )

    method on_visit( cmd:Preincrement )
      writer.print "++"
      visit( cmd.operand )

    method on_visit( cmd:Return )
      writer.print "return"
      if (cmd.result)
        writer.print ' '
        visit( cmd.result )
      endIf

    method on_visit( cmd:Routine )
      this_procedure = cmd
      autoname_index = 0
      forEach (v at i in cmd.locals) v.c_name = v.name + "_" + i
      this_module.write_c_routine_header( cmd, writer )
      writer.println
      visit( cmd.body )

    method on_visit( cmd:SetLocal )
      if (cmd.info.type.is_reference)
        writer.print "Rogue_set_ref( &"
        writer.print cmd.info.c_name
        writer.print ", "
        visit( cmd.new_value )
        writer.print " )"
      else
        writer.print( cmd.info.c_name )
        writer.print( " = " )
        visit( cmd.new_value )
      endIf

    method on_visit( cmd:Statements )
      forEach (statement in cmd)
        visit( statement )
        if (statement.needs_semicolon) writer.println( ';' )
      endForEach

    method on_visit( cmd:Subtract )
      print_parenthesized( cmd.left )
      writer.print " - "
      print_parenthesized( cmd.right )

    method on_visit( cmd:PrintInt32 )
      writer.print ''printf( "%d", (int)''
      visit( cmd.operand )
      writer.print '' )''

    method on_visit( cmd:PrintLogical )
      writer.print ''printf( "%s", (''
      visit( cmd.operand )
      writer.print '') ? "true" : "false" )''

    method on_visit( cmd:PrintNewline )
      writer.print( ''putchar( '\\n' )'' )

    method on_visit( cmd:PrintReal64 )
      writer.print ''printf( "%lf", ''
      visit( cmd.operand )
      writer.print '' )''

    method on_visit( cmd:PrintString )
      writer.print ''printf( "%s", RogueString_to_c_string(''
      visit( cmd.operand )
      writer.print ") )"
endClass

# write_print()
augment
  METHODS
    method Cmd.write_print( writer:CWriter )
      throw UnsupportedOperationError("$.write_print()"(type_name))

    method LiteralInt32.write_print( writer:CWriter )
      writer.print ''printf( "%d", $ )'' (value)

    method LiteralString.write_print( writer:CWriter )
      writer.print ''printf( "$" )'' (value.to_escaped_ascii(''"''))
endAugment

