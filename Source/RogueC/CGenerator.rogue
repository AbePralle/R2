module R2

augment Procedure
  PROPERTIES
    c_name : String

  METHODS
    method c_name->String
      throw UnsupportedOperationError()
endAugment

augment
  METHODS
    method Block.needs_semicolon->Logical
      return false

    method Cmd.needs_semicolon->Logical
      return true

    method Module.c_name->String
      if (this is Program.default_module) return "Rogue"
      return name

    method Module.write_c_routine_header( r:Routine, writer:CWriter )
      if (r.return_type)
        writer.print( r.return_type.c_name ).print( ' ' )
      else
        writer.print( "void " )
      endIf
      writer.print( r.c_name )
      writer.print( "(" )
      writer.print( ")" )

    method Module.generate_c_class_structs( writer:CWriter )
      forEach (type in types)
        if (not type.is_primitive)
          if (type is Program.type_String)
            writer.println ...
              @|struct RogueString
               |{
               |  RogueType*   type;
               |  RogueInt32   ref_count;
               |  RogueInt32   byte_count;       // in UTF-8 bytes
               |  RogueInt32   character_count;  // in whole characters
               |  RogueInt32   cursor_offset;    // in bytes
               |  RogueInt32   cursor_index;     // in characters
               |  RogueInt32   hash_code;
               |  RogueLogical must_free;
               |  char*        utf8;
               |  char         buffer[78];
               |};
               |
          else
            writer.print   "struct "
            writer.print   type.c_name
            writer.println
            writer.println '{'
            writer.indent  += 2
            writer.println "RogueType* type;"
            writer.println "RogueInt32 ref_count;"
            writer.indent  -= 2
            writer.println "};"
            writer.println
          endIf
        endIf
      endForEach
      writer.println

    method Module.generate_c_class_typedefs( writer:CWriter )
      writer.println "typedef struct RogueType RogueType;"

      forEach (type in types)
        if (not type.is_primitive)
          writer.print   "typedef struct "
          writer.print   type.c_name
          writer.print   ' '
          writer.print   type.c_name
          writer.println ";"
        endIf
      endForEach
      writer.println

    method Module.generate_c_header( writer:CWriter )
      forEach (r in routines)
        write_c_routine_header( r, writer )
        writer.println ";"
      endForEach

    method Module.generate_c_code( writer:CWriter )
      forEach (r in routines)
        CGenerator( this, writer ).visit( r )
      endForEach

    method Module.generate_c_launch_commands( writer:CWriter )
      local r = routines[ "on_launch()" ]
      if (r and r.statements.count)
        writer.print( r.c_name ).println( "();" )
      endIf

    method Routine.c_name->String
      if (@c_name) return @c_name
      use builder = StringBuilder.pool
        builder.print( module_context.c_name ).print( '_' ).print( name )
        # TODO: parameter types
        c_name = builder
        return @c_name
      endUse

    method Program.generate_c
      local h_writer = CWriter( File("Test.h"), &header )

      h_writer.println ...
        @|//------------------------------------------------------------------------------
         |// Classes
         |//------------------------------------------------------------------------------
      (forEach in modules).generate_c_class_typedefs( h_writer )
      (forEach in modules).generate_c_class_structs( h_writer )

      (forEach in modules).generate_c_header( h_writer )
      h_writer.close

      local c_writer = CWriter( File("Test.c") )

      (forEach in modules).generate_c_code( c_writer )
      c_writer.println @|
                        |int main( int argc, char* argv[] )
                        |{
      c_writer.indent += 2

      (forEach in modules).generate_c_launch_commands( c_writer )

      c_writer.println @|return 0;

      c_writer.indent -= 2
      c_writer.println @|}

      c_writer.close

    method Type.c_name->String
      if (@c_name) return @c_name
      @c_name = "$$" (module_context.c_name,name)
      return @c_name

      throw t.error( "[INTERNAL] $.c_name() is undefined." (type_name) )

endAugment

class CGenerator : Visitor
  PROPERTIES
    writer         : CWriter
    this_module    : Module
    this_type      : Type
    this_procedure : Procedure

  METHODS
    method init( this_module, writer )

    method on_visit( cmd:Cmd )
      throw UnsupportedOperationError("CGenerator.on_visit($)"(cmd.type_name))

    method on_visit( cmd:CmdList )
      visit_children( cmd )

    method on_visit( cmd:Block )
      writer.println '{'
      writer.indent += 2
      visit_children( cmd )
      writer.indent -= 2
      writer.println '}'

    method on_visit( cmd:GetLocal )
      writer.print( cmd.info.c_name )

    method on_visit( cmd:LiteralInt32 )
      writer.print( cmd.value )

    method on_visit( cmd:LiteralString )
      writer.print( cmd.value.to_escaped_ascii("\"") )

    #method on_visit( cmd:LocalDeclarations )
    #  visit_children( cmd )

    #method on_visit( cmd:LocalDef )

    method on_visit( cmd:Routine )
      forEach (v at i in cmd.locals) v.c_name = v.name + "_" + i
      this_module.write_c_routine_header( cmd, writer )
      writer.println
      writer.println( "{" )
      writer.indent += 2
      forEach (v in cmd.local_declarations)
        writer.print( v.type.c_name ).print( ' ' )
        writer.print( v.c_name )
        writer.println( ';' )
      endForEach
      visit_children( cmd )
      writer.indent -= 2
      writer.println( "}" )

    method on_visit( cmd:SetLocal )
      writer.print( cmd.info.c_name )
      writer.print( " = " )
      visit( cmd.new_value )

    method on_visit( cmd:Statements )
      forEach (statement in cmd)
        visit( statement )
        if (statement.needs_semicolon) writer.println( ';' )
      endForEach

    method on_visit( cmd:PrintInt32 )
      writer.print ''printf( "%d", (int)''
      visit( cmd.operand )
      writer.print '' )''

    method on_visit( cmd:PrintNewline )
      writer.print( ''putchar( '\\n' )'' )

    method on_visit( cmd:PrintString )
      writer.print ''printf( "''
      visit( cmd.operand )
      writer.print ''" )''
endClass

# write_print()
augment
  METHODS
    method Cmd.write_print( writer:CWriter )
      throw UnsupportedOperationError("$.write_print()"(type_name))

    method LiteralInt32.write_print( writer:CWriter )
      writer.print ''printf( "%d", $ )'' (value)

    method LiteralString.write_print( writer:CWriter )
      writer.print ''printf( "$" )'' (value.to_escaped_ascii(''"''))
endAugment

