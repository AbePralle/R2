module Rogue

class Organizer : Visitor
  PROPERTIES
    current_statements_rewriter : ListRewriter<<Cmd>>
    control_stack               = ControlStructure[]

  METHODS
    method init( this_module )

    method visit( this_type, class_def:Cmd )
      # Called when instantiating a template
      visit( class_def )

    method on_visit( cmd:Class )
      cmd.attributes.flags |= this_type.attributes.flags
      this_type.attributes = cmd.attributes
      if (not this_type.is_primitive and not this_type.is_compound)
        this_type.attributes.is_object = true
      endIf
      visit_children( cmd )

    method on( cmd:ControlStructure )->Cmd
      control_stack.add( cmd )
      visit_content( cmd )
      control_stack.remove_last
      return cmd

    method on( cmd:Definition )->Cmd
      assert this_type
      if (this_type.definitions.contains(cmd.name))
        throw cmd.t.error( "'$.$' is already defined."(this_type,cmd.name) )
      endIf
      this_type.definitions[ cmd.name ] = cmd.value
      return null

    method on( cmd:GlobalMethod )->Cmd
      cmd.module_context = this_module
      cmd.type_context = this_type
      cmd.organize( this )
      return cmd

    method on( cmd:Method )->Cmd
      cmd.module_context = this_module
      cmd.type_context = this_type
      cmd.organize( this )
      return cmd

    method on( cmd:NativeCode )->Cmd
      this_type.native_code.add( cmd )
      return null

    method on( cmd:NativeHeader )->Cmd
      this_type.native_header.add( cmd )
      return null

    method on( cmd:PropertyDeclarations )->Cmd
      local type = cmd.type
      if (type)
        forEach (decl in cmd.declarations)
          local p = decl->(as Property)
          if (p)
            p.type = type
            collect( decl.t, p )
          else
            throw decl.t.error( "Native properties must be on individual lines." )
          endIf
        endForEach
      else
        forEach (decl in cmd.declarations)
          local p = decl->(as Property)
          if (p)
            collect( p.t, p )
          else
            local c_property = decl->(as NativeCProperty)
            if (c_property)
              this_type.native_properties.add( c_property.expression )
            endIf
          endIf
        endForEach
      endIf
      return null

    method on_visit( cmd:This )
      if (not this_procedure.is_method)
        throw cmd.t.error( "'this' can only be referenced in an object method." )
      endIf
      cmd.this_type = this_type

    method collect( t:Token, p:Property )
      assert this_type

      if (not p.type)
        if (p.initial_value)
          p.type = p.initial_value.type
          if (not p.type)
            throw p.t.error(
              ''Cannot implicitly determine type of property "$" from initial value. ''(p.name) +
              ''Add an explicit ': Type' at the end of the line.''
            )
          endIf
        else
          throw p.t.error( ''Property "$" must have an initial assignment or a declared ': Type'.''(p.name) )
        endIf
      endIf

      visit( p )
      if (this_type.properties.contains(p.name))
        throw t.error( ''Type $ already defines a property named "$".''(this_type,p.name) )
      endIf
      this_type.properties[ p.name ] = p

endClass
