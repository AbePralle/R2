module Rogue

class Organizer : Visitor
  PROPERTIES
    current_statements_rewriter : ListRewriter<<Cmd>>
    control_stack               = ControlStructure[]

  METHODS
    method init( this_module )

    method visit( this_type, class_def:Cmd )
      # Called when instantiating a template
      visit( class_def )

    method on_visit( cmd:Class )
      cmd.attributes.flags |= this_type.attributes.flags
      this_type.attributes = cmd.attributes
      if (not this_type.is_primitive and not this_type.is_compound and not this_type.is_aspect)
        this_type.attributes.is_object = true
      endIf

      if (cmd.constructor_properties)
        # Turn parameters into properties and generate a corresponding init() method.
        local m_init = Method( cmd.t, "init" )
        forEach (v in cmd.constructor_properties)
          if (v.type)
            local p = Property( v.t, v.name, v.initial_value, v.type )
            collect( v.t, p )
            v.type = null  # turn into auto-store parameter
          endIf
          m_init.parameters.add( v )
        endForEach
        on( m_init )
      endIf

      forEach (type in cmd.base_types)
        if (type.is_object)
          if (this_type.base_class and this_type.base_class is not type)
            throw cmd.base_types.t.error(
              "Class $ cannot extend both $ and $. Only one base class is allowed."...
              (this_type.name,this_type.base_class,type)
            )
          endIf
          if (not this_type.is_object)
            throw cmd.base_types.t.error( "Compounds, aspects, and primitives cannot extend object classes." )
          endIf
          if (type.instance_of(this_type))
            throw cmd.base_types.t.error( "Circular class extension - $ already extends $." (type,this_type) )
          endIf
          this_type.base_class = type
        elseIf (this_type.is_aspect)
          throw cmd.base_types.t.error( "Aspects cannot extend other aspects or classes." )
        else
          ensure type.aspects
          type.aspects.add( type )
        endIf
      endForEach

      visit_children( cmd )

    method on( cmd:ControlStructure )->Cmd
      control_stack.add( cmd )
      visit_content( cmd )
      control_stack.remove_last
      return cmd

    method on( cmd:Definition )->Cmd
      assert this_type
      if (this_type.definitions.contains(cmd.name))
        throw cmd.t.error( "'$.$' is already defined."(this_type,cmd.name) )
      endIf
      this_type.definitions[ cmd.name ] = cmd.value
      return null

    method on( cmd:GlobalMethod )->Cmd
      cmd.module_context = this_module
      cmd.type_context = this_type
      cmd.organize( this )
      return cmd

    method on( cmd:Method )->Cmd
      cmd.module_context = this_module
      cmd.type_context = this_type
      cmd.organize( this )
      return cmd

    method on( cmd:NativeCode )->Cmd
      this_type.native_code.add( cmd )
      return null

    method on( cmd:NativeHeader )->Cmd
      this_type.native_header.add( cmd )
      return null

    method on( cmd:PropertyDeclarations )->Cmd
      local type = cmd.type
      if (type)
        forEach (decl in cmd.declarations)
          local p = decl->(as Property)
          if (p)
            p.type = type
            collect( decl.t, p )
          else
            throw decl.t.error( "Native properties must be on individual lines." )
          endIf
        endForEach
      else
        forEach (decl in cmd.declarations)
          local p = decl->(as Property)
          if (p)
            collect( p.t, p )
          else
            local c_property = decl->(as NativeCProperty)
            if (c_property)
              this_type.native_properties.add( c_property.expression )
            endIf
          endIf
        endForEach
      endIf
      return null

    method on_visit( cmd:This )
      if (not this_procedure.is_method)
        throw cmd.t.error( "'this' can only be referenced in an object method." )
      endIf
      cmd.this_type = this_type

    method collect( t:Token, p:Property )
      assert this_type

      if (not p.type)
        if (p.initial_value)
          p.type = p.initial_value.type
          if (not p.type)
            throw p.t.error(
              ''Cannot implicitly determine type of property "$" from initial value. ''(p.name) +
              ''Add an explicit ': Type' at the end of the line.''
            )
          endIf
        else
          throw p.t.error( ''Property "$" must have an initial assignment or a declared ': Type'.''(p.name) )
        endIf
      endIf

      visit( p )
      if (this_type.properties.contains(p.name))
        throw t.error( ''Type $ already defines a property named "$".''(this_type,p.name) )
      endIf
      this_type.properties[ p.name ] = p

endClass
