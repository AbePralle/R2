module Rogue

class TypeOrganizer : Visitor
  METHODS
    method init( this_module )

    method visit( this_type, class_def:Cmd )
      # Called when instantiating a template
      visit( class_def )

    method on_visit( cmd:Category )
      if (not this_type.is_enum)
        throw cmd.t.error( "Only enums can have a CATEGORIES section." )
      endIf

      ensure this_type.categories
      this_type.categories.add( cmd )

    method on_visit( cmd:Class )
      cmd.attributes.flags |= this_type.attributes.flags
      this_type.attributes = cmd.attributes
      if (not this_type.is_primitive and not this_type.is_compound and not this_type.is_aspect)
        this_type.attributes.is_object = true
      endIf

      if (this_type.is_enum)
        collect( cmd.t, Property(cmd.t, "value", null, Program.type_Int32) )
        ensure this_type.categories

      elseIf (cmd.constructor_properties)
        if (this_type.is_object)
          # Turn parameters into properties
          forEach (v in cmd.constructor_properties)
            if (v.type)
              local p = Property( v.t, v.name, v.initial_value, v.type )
              collect( v.t, p )
              v.type = null  # turn into auto-store parameter
            endIf
          endForEach

        elseIf (this_type.is_compound)
          # Turn parameters into properties.
          forEach (v in cmd.constructor_properties)
            if (not v.type) throw v.t.error( "Missing ':Type'." )
            local p = Property( v.t, v.name, v.initial_value, v.type )
            collect( v.t, p )
          endForEach

        elseIf (this_type.is_aspect)
          throw cmd.constructor_properties.t.error( "Aspects cannot have constructor properties." )

        else
          throw cmd.constructor_properties.t.error( "Primitives cannot have constructor properties." )

        endIf
      endIf

      forEach (base_type in cmd.base_types)
        base_type.organize_type

        if (base_type.instance_of(this_type))
          throw cmd.base_types.t.error( "Circular class extension - $ already extends $." (base_type,this_type) )
        endIf

        if (base_type.is_primitive)
          throw cmd.base_types.t.error( "Primitive $ cannot be extended."(base_type) )
        elseIf (base_type.is_compound)
          throw cmd.base_types.t.error( "Compound $ cannot be extended."(base_type) )
        elseIf (base_type.is_object)
          if (this_type.base_class and this_type.base_class is not base_type)
            throw cmd.base_types.t.error(
              "Class $ cannot extend both $ and $. Only one base class is allowed."...
              (this_type.name,this_type.base_class,base_type)
            )
          endIf
          if (not this_type.is_object)
            throw cmd.base_types.t.error( "Compounds, aspects, and primitives cannot extend objects." )
          endIf
          this_type.base_class = base_type
        else
          # base_type.is_aspect
          ensure this_type.aspects
          this_type.aspects.add( base_type )
        endIf
      endForEach

      visit_children( cmd )

      if (this_type.is_enum)
        # Create DEFINITIONS for each category
        local class_def = this_type.class_def->(as Class)
        assert class_def
        if (not class_def.constructor_properties) class_def.constructor_properties = Parameters(this_type.t)
        local enum_properties = class_def.constructor_properties

        local ordinal = 0 : Int32?
        local prev_name   : String
        forEach (category in this_type.categories)
          local t = category.t

          if (not category.args) category.args = Args(t)
          local args = category.args
          forEach (p at i in enum_properties)
            if (args.count == i)
              if (p.initial_value)
                args.add( null )
              else
                throw t.error( "Category '$' does not specify value for property '$'."(category.name,p.name) )
              endIf
            endIf
          endForEach

          local value = category.value
          if (value)
            if (value instanceOf LiteralInt32)
              ordinal = value->(as LiteralInt32).value + 1
            else
              ordinal = null
            endIf
          else
            if (ordinal)
              value = LiteralInt32(t,ordinal.value)
              ordinal = ordinal.value + 1
            else
              value = Add( t, ContextAccess(t,TypeContext(t,this_type),prev_name), LiteralInt32(t,1) )
            endIf
          endIf

          local name = category.name
          if (this_type.definitions.contains(name))
            throw t.error( "Duplicate category '$'."(name) )
          endIf
          this_type.definitions[ name ] = EnumValueDef(t,value)
          prev_name = name
        endForEach

        # create global 'categories:EnumType[]'
        block
          local list = LiteralList( this_type.t )
          forEach (category in this_type.categories)
            list.add( Access(category.t,category.name) )
          endForEach
          collect_global( list.t, Property(list.t,"categories",list,Type(list.t,this_type)) )
        endBlock
      endIf

    method on( cmd:Access )->Cmd
      visit_children( cmd )

      # Convert to TypeAccess if applicable.
      local m = this_module
      local name = cmd.name

      if (name.contains("::"))
        local m_name = name.before_last("::")
        m = Program.modules[ m_name ]
        if (not m) throw cmd.t.error( "No such module '$'."(m_name) )
        name .= after_last("::")
      endIf

      local type = m.find_type( name, &extended_search )
      if (type) return TypeAccess( cmd.t, type, cmd.args )
      return cmd

    method on( cmd:Definition )->Cmd
      assert this_type
      if (this_type.definitions.contains(cmd.name))
        throw cmd.t.error( "'$.$' is already defined."(this_type,cmd.name) )
      endIf
      this_type.definitions[ cmd.name ] = cmd.value
      return null

    method on( cmd:GlobalPropertyDeclarations )->Cmd
      local type = cmd.type
      if (type)
        forEach (decl in cmd.declarations)
          local p = decl->(as Property)
          if (p)
            p.type = type
            collect_global( decl.t, p )
          else
            throw decl.t.error( "Global properties cannot be native." )
          endIf
        endForEach
      else
        forEach (decl in cmd.declarations)
          local p = decl->(as Property)
          if (p)
            collect_global( p.t, p )
          else
            local c_property = decl->(as NativeCProperty)
            if (c_property)
              throw c_property.t.error( "Global properties cannot be native." )
            endIf
          endIf
        endForEach
      endIf
      return null

    method on( cmd:NativeCode )->Cmd
      this_type.native_code.add( cmd )
      return null

    method on( cmd:NativeHeader )->Cmd
      this_type.native_header.add( cmd )
      return null

    method on( cmd:PropertyDeclarations )->Cmd
      local type = cmd.type
      if (type)
        forEach (decl in cmd.declarations)
          local p = decl->(as Property)
          if (p)
            p.type = type
            collect( decl.t, p )
          else
            throw decl.t.error( "Native properties must be on individual lines." )
          endIf
        endForEach
      else
        forEach (decl in cmd.declarations)
          local p = decl->(as Property)
          if (p)
            collect( p.t, p )
          else
            local c_property = decl->(as NativeCProperty)
            if (c_property)
              this_type.native_properties.add( c_property.expression )
            endIf
          endIf
        endForEach
      endIf
      return null

    method collect( t:Token, p:Property )
      visit( p )
      assert this_type
      this_type.add_property( p )

    method collect_global( t:Token, p:Property )
      visit( p )

      assert this_type
      p.type_context = this_type
      p.attributes.is_global = true

      if (not p.type)
        if (p.initial_value)
          p.type = p.initial_value.type
          if (not p.type)
            throw p.t.error(
            ''Cannot implicitly determine type of global property "$" from initial value. ''(p.name) +
              ''Add an explicit ': Type' at the end of the line.''
            )
          endIf
        else
          throw p.t.error( ''Global property "$" must have an initial assignment or a declared ': Type'.''(p.name) )
        endIf
      endIf

      p.type.organize_type

      if (p.type.is_reference or (p.type.is_compound and p.type.contains_embedded_reference))
        p.type.attributes.contains_reference = true
      endIf

      local existing_p = this_type.global_properties[p.name]
      if (existing_p and existing_p.type_context is this_type)
        throw t.error( ''Type $ already defines a property called "$".''(this_type,p.name) )
      endIf
      this_type.global_properties[ p.name ] = p

endClass
