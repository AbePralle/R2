module Rogue

class CWriter : BufferedPrintWriter
  PROPERTIES
    is_header : Logical

  METHODS
    method init( file:File, &header )
      prior.init( file.writer )
      is_header = header

      if (is_header)
        println @|#ifndef TEST_H
                 |#define TEST_H
                 |
        println "// Test.h"
        println ...
          @|
           |// Handle Apple's wonky defines which used to ALWAYS be defined as 0 or 1 and
           |// are now only defined if the platform is active.
           |#if defined(__APPLE__)
           |  #if defined(TARGET_IPHONE_SIMULATOR)
           |    #if TARGET_IPHONE_SIMULATOR
           |      #define ROGUE_PLATFORM_IOS 1
           |    #endif
           |  #endif
           |
           |  #if !defined(ROGUE_PLATFORM_IOS)
           |    #if defined(TARGET_OS_IPHONE)
           |      #if TARGET_OS_IPHONE
           |        #define ROGUE_PLATFORM_IOS 1
           |      #endif
           |    #endif
           |  #endif
           |
           |  #if !defined(ROGUE_PLATFORM_IOS)
           |    #define ROGUE_PLATFORM_MACOS 1
           |    #define ROGUE_PLATFORM_UNIX_COMPATIBLE 1
           |  #endif
           |#endif
           |
           |#if !defined(ROGUE_PLATFORM_IOS) && !defined(ROGUE_PLATFORM_MACOS)
           |  #if defined(_WIN32)
           |  #  define ROGUE_PLATFORM_WINDOWS 1
           |  #elif defined(__ANDROID__)
           |  #  define ROGUE_PLATFORM_ANDROID 1
           |  #elif defined(__linux__)
           |  #  define ROGUE_PLATFORM_LINUX 1
           |  #  define ROGUE_PLATFORM_UNIX_COMPATIBLE 1
           |  #elif defined(__CYGWIN__)
           |  #  define ROGUE_PLATFORM_LINUX  1
           |  #  define ROGUE_PLATFORM_CYGWIN 1
           |  #  define ROGUE_PLATFORM_UNIX_COMPATIBLE 1
           |  #elif defined(EMSCRIPTEN)
           |  #  define ROGUE_PLATFORM_WEB 1
           |  #else
           |  #  define ROGUE_PLATFORM_GENERIC 1
           |  #endif
           |#endif
           |
           |#if defined(ROGUE_PLATFORM_WINDOWS)
           |#  define NOGDI
           |#  pragma warning(disable: 4297) /* unexpected throw warnings */
           |#  include <windows.h>
           |#  include <signal.h>
           |#else
           |#  include <stdint.h>
           |#endif
           |
           |#include <math.h>
           |#include <stdlib.h>
           |#include <string.h>
           |
           |//------------------------------------------------------------------------------
           |// Logging
           |//------------------------------------------------------------------------------
           |#ifdef __ANDROID__
           |  #include <android/log.h>
           |  #define ROGUE_LOG(...)       __android_log_print( ANDROID_LOG_INFO,  "Rogue", __VA_ARGS__ )
           |  #define ROGUE_LOG_ERROR(...) __android_log_print( ANDROID_LOG_ERROR, "Rogue", __VA_ARGS__ )
           |#else
           |  #define ROGUE_LOG(...)       printf( __VA_ARGS__ )
           |  #define ROGUE_LOG_ERROR(...) printf( __VA_ARGS__ )
           |#endif
           |
           |//------------------------------------------------------------------------------
           |// Primitive Types
           |//------------------------------------------------------------------------------
           |#if defined(ROGUE_PLATFORM_WINDOWS)
           |  typedef double           RogueReal64;
           |  typedef float            RogueReal32;
           |  typedef __int64          RogueInt64;
           |  typedef __int32          RogueInt32;
           |  typedef __int32          RogueCharacter;
           |  typedef unsigned __int16 RogueWord;
           |  typedef unsigned char    RogueByte;
           |  typedef int              RogueLogical;
           |  typedef unsigned __int64 RogueUInt64;
           |  typedef unsigned __int32 RogueUInt32;
           |#else
           |  typedef double           RogueReal64;
           |  typedef float            RogueReal32;
           |  typedef int64_t          RogueInt64;
           |  typedef int32_t          RogueInt32;
           |  typedef int32_t          RogueCharacter;
           |  typedef uint16_t         RogueWord;
           |  typedef uint8_t          RogueByte;
           |  typedef int              RogueLogical;
           |  typedef uint64_t         RogueUInt64;
           |  typedef uint32_t         RogueUInt32;
           |#endif
           |
           |//------------------------------------------------------------------------------
           |// Classes
           |//------------------------------------------------------------------------------
           |#if !defined(ROGUE_MALLOC)
           |  #define ROGUE_MALLOC malloc
           |#endif
           |
           |#if !defined(ROGUE_FREE)
           |  #define ROGUE_FREE free
           |#endif
           |
           |#define ROGUE_CREATE_OBJECT( TypeName ) \
           |    ((TypeName*)RogueDeadlist_add(Rogue_create_object(&Type##TypeName)))
           |
           |#define ROGUE_SINGLETON( TypeName ) \
           |    ((TypeName*)Rogue_singleton(&Type##TypeName,&TypeName##_singleton))
           |
           |typedef struct RogueType RogueType;
           |
           |struct RogueType
           |{
           |  const char* module_name;
           |  const char* name;
           |  RogueInt32 size;
           |};
           |
           |void* Rogue_create_object( void* type );
           |void  Rogue_delete_object( void* obj );
           |void* Rogue_singleton( void* type, void* singleton_ref );
           |void* Rogue_release( void* obj );
           |void  Rogue_set_ref( void* ref, void* new_obj );
           |void* Rogue_retain( void* obj );
           |
           |void  Rogue_launch();
           |
           |#define ROGUE_STRING_INTERNAL_BUFFER_SIZE 68
           |
           |//------------------------------------------------------------------------------
           |// Runtime
           |//------------------------------------------------------------------------------
           |extern int    Rogue_exception;  // set to 1 on exception; exception handler clears
           |
           |extern int    RogueDeadlist_count;
           |extern int    RogueDeadlist_capacity;
           |extern void** RogueDeadlist_data;
           |
           |void*         RogueDeadlist_add( void* obj );
           |void          RogueDeadlist_purge( int fp );
           |
           |RogueInt32  Rogue_mod_Int32( RogueInt32 a, RogueInt32 b );
           |RogueInt64  Rogue_mod_Int64( RogueInt64 a, RogueInt64 b );
           |RogueReal64 Rogue_mod_Real64( RogueReal64 a, RogueReal64 b );
        println

      else
        # Writing .c file
        println  "// Test.c"
        println
        println ''#include "Test.h"''
        println  "#include <stdio.h>"
        println
        println ...
          @|void* Rogue_create_object( void* _type )
           |{
           |  RogueType*  type = (RogueType*) _type;
           |  RogueObject* obj = (RogueObject*) ROGUE_MALLOC( type->size );
           |  memset( obj, 0, type->size );
           |  obj->type = type;
           |  // Note: ref_count is 0
           |  return obj;
           |}
           |
           |void Rogue_delete_object( void* obj )
           |{
           |  // TODO: dereference properties
           |  printf( "Destroying %s\n", ((RogueObject*)obj)->type->name );
           |  ROGUE_FREE( obj );
           |}
           |
           |void* Rogue_singleton( void* _type, void* singleton_ref )
           |{
           |  if (*((RogueObject**)singleton_ref)) return *((RogueObject**)singleton_ref);
           |  RogueType* type = (RogueType*) _type;
           |  RogueObject* obj = Rogue_create_object( type );
           |  Rogue_set_ref( singleton_ref, obj );
           |  return obj;
           |}
           |
           |void* Rogue_release( void* obj )
           |{
           |  if (obj && ! --((RogueObject*)obj)->ref_count )
           |  {
           |    if ( !(((RogueObject*)obj)->deadlisted) ) RogueDeadlist_add(obj);
           |  }
           |  return 0;
           |}
           |
           |void  Rogue_set_ref( void* ref, void* new_obj )
           |{
           |  RogueObject* old_obj = *((RogueObject**)ref);
           |  if (old_obj && ! --old_obj->ref_count)
           |  {
           |    if ( !(((RogueObject*)old_obj)->deadlisted) ) RogueDeadlist_add(old_obj);
           |  }
           |  if (new_obj) ++((RogueObject*)new_obj)->ref_count;
           |  *((void**)ref) = new_obj;
           |}
           |
           |void* Rogue_retain( void* obj )
           |{
           |  if ( !obj ) return 0;
           |  ++((RogueObject*)obj)->ref_count;
           |  return obj;
           |}
           |
           |//------------------------------------------------------------------------------
           |// Runtime
           |//------------------------------------------------------------------------------
           |int Rogue_exception = 0;
           |
           |int    RogueDeadlist_count = 0;
           |int    RogueDeadlist_capacity = 0;
           |void** RogueDeadlist_data = 0;
           |
           |void* RogueDeadlist_add( void* obj )
           |{
           |  if ( !obj ) return 0;
           |  if (RogueDeadlist_count == RogueDeadlist_capacity)
           |  {
           |    int    double_capacity = RogueDeadlist_capacity ? (RogueDeadlist_capacity*2) : 1024;
           |    void** new_data = ROGUE_MALLOC( sizeof(void*) * double_capacity );
           |    if (RogueDeadlist_data)
           |    {
           |      memcpy( new_data, RogueDeadlist_data, sizeof(void*)*RogueDeadlist_capacity );
           |      ROGUE_FREE( RogueDeadlist_data );
           |    }
           |    RogueDeadlist_data = new_data;
           |    RogueDeadlist_capacity = double_capacity;
           |  }
           |  RogueDeadlist_data[RogueDeadlist_count++] = obj;
           |  ((RogueObject*)obj)->deadlisted = 1; // flag to ensure no duplicates get added
           |  return obj;
           |}
           |
           |void RogueDeadlist_purge( int fp )
           |{
           |  int n = RogueDeadlist_count - fp;
           |  if ( !n ) return;
           |
           |  RogueDeadlist_count = fp;
           |
           |  // Rewrite deadlist frame to remove survivors
           |  int read_i, write_i;
           |  for ( read_i=write_i=0; read_i<n; ++read_i )
           |  {
           |    RogueObject* obj = (RogueObject*) RogueDeadlist_data[fp+read_i];
           |    if ( !obj->ref_count )
           |    {
           |      RogueDeadlist_data[fp + write_i++] = obj;
           |    }
           |  }
           |  n = write_i;
           |
           |  // Delete remaining objects
           |  while (--n >= 0)
           |  {
           |    Rogue_delete_object( RogueDeadlist_data[fp+n] );
           |  }
           |}
           |
           |RogueInt32 Rogue_mod_Int32( RogueInt32 a, RogueInt32 b )
           |{
           |  if ((!a && !b) || b == 1) return 0;
           |
           |  RogueInt32 r = a % b;
           |  if ((a ^ b) >= 0) return r;
           |  if (r) return r + b;
           |  return 0;
           |}
           |
           |RogueInt64 Rogue_mod_Int64( RogueInt64 a, RogueInt64 b )
           |{
           |  if ((!a && !b) || b == 1) return 0;
           |
           |  RogueInt64 r = a % b;
           |  if ((a ^ b) >= 0) return r;
           |  if (r) return r + b;
           |  return 0;
           |}
           |
           |RogueReal64 Rogue_mod_Real64( RogueReal64 a, RogueReal64 b )
           |{
           |  RogueReal64 q = a / b;
           |  return a - (floor(q) * b);
           |}
        println

      endIf

    method close if (is_header) println @|#endif // TEST_H
      prior.close

    method print_hex_pair( value:Int32 )
      print "\\x"
      print ((value :>>>: 4).to_digit)
      print ((value & 15).to_digit)

    method print_literal_c_character( ch:Character, in_string:Logical )
      if (ch >= 32 and ch <= 126)
        which (ch)
          case '"'
            if (in_string) print( "\\\"" )
            else           print( "\"" )
          case '\''
            if (in_string) print( "'" )
            else           print( "\\'" )
          case '\\'
            print( "\\\\" )
          others
            print( ch )
        endWhich
      else
        which (ch)
          case 10
            print "\\n"
          others
            # Must print as separate string to avoid C \x ambiguity.  For instance,
            # "This is \x9CCool" is interpreeted as "This is \x9CC" followed by "ool",
            # so we have to generate "This is ""\x9C""Cool".
            print( "\"\"" )  # end of string so far and beginning of hex escape string
            if (ch <= 0x7F)
              print_hex_pair( ch )
            elseIf (ch <= 0x7FF)
              print_hex_pair(0xC0 | ((ch :>>>: 6) & 0x1F))
              print_hex_pair(0x80 | (ch & 0x3F))
            elseIf (ch <= 0xFFFF)
              print_hex_pair( 0xE0 | ((ch :>>>: 12) & 0xF) )
              print_hex_pair( 0x80 | ((ch :>>>: 6) & 0x3F) )
              print_hex_pair( 0x80 | (ch & 0x3F) )
            else
              print_hex_pair( 0xF0 | ((ch :>>>: 18) & 0x7) )
              print_hex_pair( 0x80 | ((ch :>>>: 12) & 0x3F) )
              print_hex_pair( 0x80 | ((ch :>>>: 6) & 0x3F) )
              print_hex_pair( 0x80 | (ch & 0x3F) )
            endIf
            print( "\"\"" )  # end of hex escape string and continuation of original string
        endWhich
      endIf

    method print_literal_c_string( st:String, &omit_quotes )
      if (st is null)
        print( "0" )
        return
      endIf

      if (not omit_quotes) print '"'

      local stage = 0
      # 0: \ -> 1 ignore next
      #    ? -> 2 first question mark
      # 1: -> 0
      # 2: ? -> print \ -> 0
      #    else  0

      local next_split = buffer.count + 16000
      forEach (ch in st)
        which (stage)
          case 0
            if (buffer.count >= next_split)
              if (not omit_quotes) println( "\"" ); print( "\"" )
              next_split = buffer.count + 16000
            endIf

            if (ch == '\\')    stage = 1
            elseIf (ch == '?') stage = 2
          case 1
            stage = 0
          case 2
            if (ch == '?') print( '\\' )  # Escape the second question mark in a row to avoid accidental trigraphs
            stage = 0
        endWhich
        print_literal_c_character( ch, true )
      endForEach

      if (not omit_quotes) print '"'

endClass

