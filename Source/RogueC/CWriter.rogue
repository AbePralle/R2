module Rogue

class CWriter : BufferedPrintWriter
  PROPERTIES
    is_header : Logical

  METHODS
    method init( file:File, &header )
      prior.init( file.writer )
      is_header = header

      if (is_header)
        println @|#ifndef TEST_H
                 |#define TEST_H
                 |
        println "// Test.h"
        println ...
          @|
           |// Handle Apple's wonky defines which used to ALWAYS be defined as 0 or 1 and
           |// are now only defined if the platform is active.
           |#if defined(__APPLE__)
           |  #if defined(TARGET_IPHONE_SIMULATOR)
           |    #if TARGET_IPHONE_SIMULATOR
           |      #define ROGUE_PLATFORM_IOS 1
           |    #endif
           |  #endif
           |
           |  #if !defined(ROGUE_PLATFORM_IOS)
           |    #if defined(TARGET_OS_IPHONE)
           |      #if TARGET_OS_IPHONE
           |        #define ROGUE_PLATFORM_IOS 1
           |      #endif
           |    #endif
           |  #endif
           |
           |  #if !defined(ROGUE_PLATFORM_IOS)
           |    #define ROGUE_PLATFORM_MACOS 1
           |    #define ROGUE_PLATFORM_UNIX_COMPATIBLE 1
           |  #endif
           |#endif
           |
           |#if !defined(ROGUE_PLATFORM_IOS) && !defined(ROGUE_PLATFORM_MACOS)
           |  #if defined(_WIN32)
           |  #  define ROGUE_PLATFORM_WINDOWS 1
           |  #elif defined(__ANDROID__)
           |  #  define ROGUE_PLATFORM_ANDROID 1
           |  #elif defined(__linux__)
           |  #  define ROGUE_PLATFORM_LINUX 1
           |  #  define ROGUE_PLATFORM_UNIX_COMPATIBLE 1
           |  #elif defined(__CYGWIN__)
           |  #  define ROGUE_PLATFORM_LINUX  1
           |  #  define ROGUE_PLATFORM_CYGWIN 1
           |  #  define ROGUE_PLATFORM_UNIX_COMPATIBLE 1
           |  #elif defined(EMSCRIPTEN)
           |  #  define ROGUE_PLATFORM_WEB 1
           |  #else
           |  #  define ROGUE_PLATFORM_GENERIC 1
           |  #endif
           |#endif
           |
           |#if defined(ROGUE_PLATFORM_WINDOWS)
           |#  define NOGDI
           |#  pragma warning(disable: 4297) /* unexpected throw warnings */
           |#  include <windows.h>
           |#  include <signal.h>
           |#else
           |#  include <stdint.h>
           |#endif
           |
           |#include <math.h>
           |#include <stdlib.h>
           |#include <string.h>
           |
           |//------------------------------------------------------------------------------
           |// Logging
           |//------------------------------------------------------------------------------
           |#ifdef __ANDROID__
           |  #include <android/log.h>
           |  #define ROGUE_LOG(...)       __android_log_print( ANDROID_LOG_INFO,  "Rogue", __VA_ARGS__ )
           |  #define ROGUE_LOG_ERROR(...) __android_log_print( ANDROID_LOG_ERROR, "Rogue", __VA_ARGS__ )
           |#else
           |  #define ROGUE_LOG(...)       printf( __VA_ARGS__ )
           |  #define ROGUE_LOG_ERROR(...) printf( __VA_ARGS__ )
           |#endif
           |
           |//------------------------------------------------------------------------------
           |// Primitive Types
           |//------------------------------------------------------------------------------
           |#if defined(ROGUE_PLATFORM_WINDOWS)
           |  typedef double           RogueReal64;
           |  typedef float            RogueReal32;
           |  typedef __int64          RogueInt64;
           |  typedef __int32          RogueInt32;
           |  typedef __int32          RogueCharacter;
           |  typedef unsigned __int16 RogueWord;
           |  typedef unsigned char    RogueByte;
           |  typedef int              RogueLogical;
           |  typedef unsigned __int64 RogueUInt64;
           |  typedef unsigned __int32 RogueUInt32;
           |#else
           |  typedef double           RogueReal64;
           |  typedef float            RogueReal32;
           |  typedef int64_t          RogueInt64;
           |  typedef int32_t          RogueInt32;
           |  typedef int32_t          RogueCharacter;
           |  typedef uint16_t         RogueWord;
           |  typedef uint8_t          RogueByte;
           |  typedef int              RogueLogical;
           |  typedef uint64_t         RogueUInt64;
           |  typedef uint32_t         RogueUInt32;
           |#endif
           |
           |//------------------------------------------------------------------------------
           |// Classes
           |//------------------------------------------------------------------------------
           |#if !defined(ROGUE_MALLOC)
           |  #define ROGUE_MALLOC malloc
           |#endif
           |
           |#if !defined(ROGUE_FREE)
           |  #define ROGUE_FREE free
           |#endif
           |
           |#if !defined(ROGUE_CREATE_OBJECT)
           |  #define ROGUE_CREATE_OBJECT( TypeName ) \
           |      ((TypeName*)Rogue_create_object(&Type##TypeName))
           |#endif
           |
           |#if !defined(ROGUE_SINGLETON)
           |  #define ROGUE_SINGLETON( TypeName ) \
           |      ((TypeName*)Rogue_singleton(&Type##TypeName,&TypeName##_singleton))
           |#endif
           |
           |#if !defined(ROGUE_RELEASE)
           |  // Allow 'obj' to be GC'd if there are no other references to it.
           |  #define ROGUE_RELEASE( obj )  Rogue_release( obj )
           |#endif
           |
           |#if !defined(ROGUE_RETAIN)
           |  // Prevent 'obj' from being GC'd if there are no other references to it.
           |  #define ROGUE_RETAIN( obj )   Rogue_retain( obj )
           |#endif
           |
           |typedef struct RogueType RogueType;
           |typedef void (*RogueFn_Object)(void*);
           |
           |struct RogueType
           |{
           |  const char*    module_name;
           |  const char*    name;
           |  void**         local_pointer_stack; // Objects + compounds with embedded refs
           |  RogueInt32     local_pointer_capacity;
           |  RogueInt32     local_pointer_count;
           |  RogueInt32     id;
           |  RogueInt32     size;
           |  RogueFn_Object fn_init_object;
           |  RogueFn_Object fn_init;
           |  RogueFn_Object fn_gc_trace;
           |  RogueFn_Object fn_on_cleanup;
           |};
           |
           |//------------------------------------------------------------------------------
           |// Runtime
           |//------------------------------------------------------------------------------
           |void* Rogue_create_object( void* type );
           |void  Rogue_destroy_object( void* obj );
           |void* Rogue_singleton( void* type, void* singleton_ref );
           |
           |void* Rogue_release( void* obj );
           |void* Rogue_retain( void* obj );
           |
           |void  RogueType_local_pointer_stack_add( RogueType* type, void* local_pointer );
           |
           |void  Rogue_launch();
           |
           |#define ROGUE_EXE_CONTINUE  0
           |#define ROGUE_EXE_RETURN    1
           |#define ROGUE_EXE_EXCEPTION 2
           |
           |struct RogueObject;
           |
           |extern int                 Rogue_execution_status; // 1=return, 2=exception
           |extern struct RogueObject* Rogue_exception;
           |
           |RogueInt32  Rogue_mod_Int32( RogueInt32 a, RogueInt32 b );
           |RogueInt64  Rogue_mod_Int64( RogueInt64 a, RogueInt64 b );
           |RogueReal32 Rogue_mod_Real32( RogueReal32 a, RogueReal32 b );
           |RogueReal64 Rogue_mod_Real64( RogueReal64 a, RogueReal64 b );
        println

      else
        # Writing .c file
        println  "// Test.c"
        println
        println ''#include "Test.h"''
        println  "#include <stdio.h>"
        println
        println ...
          @|//------------------------------------------------------------------------------
           |// Runtime
           |//------------------------------------------------------------------------------
           |void* Rogue_create_object( void* _type )
           |{
           |  RogueType*  type = (RogueType*) _type;
           |  RogueObject* obj = (RogueObject*) ROGUE_MALLOC( type->size );
           |  memset( obj, 0, type->size );
           |  obj->type = type;
           |  if (type->fn_init_object) type->fn_init_object( obj );
           |  // refcount starts at 0
           |  return obj;
           |}
           |
           |void Rogue_destroy_object( void* obj )
           |{
           |  printf( "Destroy object %s\n", ((RogueObject*)obj)->type->name );
           |  ROGUE_FREE( obj );
           |}
           |
           |void* Rogue_singleton( void* _type, void* singleton_ref )
           |{
           |  if (*((RogueObject**)singleton_ref)) return *((RogueObject**)singleton_ref);
           |  RogueType* type = (RogueType*) _type;
           |  RogueObject* obj = Rogue_create_object( type );
           |  if (type->fn_init) type->fn_init(obj);  // call init() if it exists
           |  return obj;
           |}
           |
           |void* Rogue_release( void* obj )
           |{
           |  if (obj) --(((RogueObject*)obj)->refcount);
           |  return 0;
           |}
           |
           |void* Rogue_retain( void* obj )
           |{
           |  if (obj) ++(((RogueObject*)obj)->refcount);
           |  return obj;
           |}
           |
           |void RogueType_local_pointer_stack_add( RogueType* type, void* local_pointer )
           |{
           |  if (type->local_pointer_count == type->local_pointer_capacity)
           |  {
           |    int required_capacity = type->local_pointer_capacity << 1;
           |    if (required_capacity < 32) required_capacity = 32;
           |
           |    void** new_data = (void**) ROGUE_MALLOC( sizeof(void*) * required_capacity );
           |    if (type->local_pointer_stack)
           |    {
           |      memcpy( new_data, type->local_pointer_stack, sizeof(void*)*type->local_pointer_count );
           |      ROGUE_FREE( type->local_pointer_stack );
           |    }
           |    type->local_pointer_stack = new_data;
           |    type->local_pointer_capacity = required_capacity;
           |  }
           |  type->local_pointer_stack[ type->local_pointer_count++ ] = local_pointer;
           |}
           |
           |int          Rogue_execution_status = 0;
           |RogueObject* Rogue_exception = 0;
           |
           |RogueInt32 Rogue_mod_Int32( RogueInt32 a, RogueInt32 b )
           |{
           |  if ((!a && !b) || b == 1) return 0;
           |
           |  RogueInt32 r = a % b;
           |  if ((a ^ b) >= 0) return r;
           |  if (r) return r + b;
           |  return 0;
           |}
           |
           |RogueInt64 Rogue_mod_Int64( RogueInt64 a, RogueInt64 b )
           |{
           |  if ((!a && !b) || b == 1) return 0;
           |
           |  RogueInt64 r = a % b;
           |  if ((a ^ b) >= 0) return r;
           |  if (r) return r + b;
           |  return 0;
           |}
           |
           |RogueReal32 Rogue_mod_Real32( RogueReal32 a, RogueReal32 b )
           |{
           |  RogueReal32 q = a / b;
           |  return a - (floorf(q) * b);
           |}
           |
           |RogueReal64 Rogue_mod_Real64( RogueReal64 a, RogueReal64 b )
           |{
           |  RogueReal64 q = a / b;
           |  return a - (floor(q) * b);
           |}
           |
           |RogueLogical Rogue_instance_of( void* obj, RogueType* ancestor_type )
           |{
           |  if ( !obj ) return 0;
           |  printf("TODO: Rogue_instance_of()\n");
           |  return 0;
           |}
           |
           |RogueLogical Rogue_is_type( void* obj, RogueType* type )
           |{
           |  if ( !obj ) return 0;
           |  return ((RogueObject*)obj)->type == type;
           |}
        println

      endIf

    method close if (is_header) println @|#endif // TEST_H
      prior.close

    method print_hex_pair( value:Int32 )
      print "\\x"
      print ((value :>>>: 4).to_digit)
      print ((value & 15).to_digit)

    method print_literal_c_character( ch:Character, in_string:Logical )
      if (ch >= 32 and ch <= 126)
        which (ch)
          case '"'
            if (in_string) print( "\\\"" )
            else           print( "\"" )
          case '\''
            if (in_string) print( "'" )
            else           print( "\\'" )
          case '\\'
            print( "\\\\" )
          others
            print( ch )
        endWhich
      else
        which (ch)
          case 10
            print "\\n"
          others
            # Must print as separate string to avoid C \x ambiguity.  For instance,
            # "This is \x9CCool" is interpreeted as "This is \x9CC" followed by "ool",
            # so we have to generate "This is ""\x9C""Cool".
            print( "\"\"" )  # end of string so far and beginning of hex escape string
            if (ch <= 0x7F)
              print_hex_pair( ch )
            elseIf (ch <= 0x7FF)
              print_hex_pair(0xC0 | ((ch :>>>: 6) & 0x1F))
              print_hex_pair(0x80 | (ch & 0x3F))
            elseIf (ch <= 0xFFFF)
              print_hex_pair( 0xE0 | ((ch :>>>: 12) & 0xF) )
              print_hex_pair( 0x80 | ((ch :>>>: 6) & 0x3F) )
              print_hex_pair( 0x80 | (ch & 0x3F) )
            else
              print_hex_pair( 0xF0 | ((ch :>>>: 18) & 0x7) )
              print_hex_pair( 0x80 | ((ch :>>>: 12) & 0x3F) )
              print_hex_pair( 0x80 | ((ch :>>>: 6) & 0x3F) )
              print_hex_pair( 0x80 | (ch & 0x3F) )
            endIf
            print( "\"\"" )  # end of hex escape string and continuation of original string
        endWhich
      endIf

    method print_literal_c_string( st:String, &omit_quotes )
      if (st is null)
        print( "0" )
        return
      endIf

      if (not omit_quotes) print '"'

      local stage = 0
      # 0: \ -> 1 ignore next
      #    ? -> 2 first question mark
      # 1: -> 0
      # 2: ? -> print \ -> 0
      #    else  0

      local next_split = buffer.count + 16000
      forEach (ch in st)
        which (stage)
          case 0
            if (buffer.count >= next_split)
              if (not omit_quotes) println( "\"" ); print( "\"" )
              next_split = buffer.count + 16000
            endIf

            if (ch == '\\')    stage = 1
            elseIf (ch == '?') stage = 2
          case 1
            stage = 0
          case 2
            if (ch == '?') print( '\\' )  # Escape the second question mark in a row to avoid accidental trigraphs
            stage = 0
        endWhich
        print_literal_c_character( ch, true )
      endForEach

      if (not omit_quotes) print '"'

    method print_with_cast( cmd:String, from_type:Type, to_type:Type )
      if (from_type is to_type)
        print cmd
      else
        print "(("
        print to_type.c_ref_name
        print ")"
        print cmd
        print ")"
      endIf
endClass

