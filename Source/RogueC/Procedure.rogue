module Rogue

class Procedure : Cmd
  PROPERTIES
    module_context : Module
    name           : String
    signature      : String
    parameters     : Parameters
    return_type    : Type
    attributes     : Attributes
    body           : LocalScope   # LocalScope(statements)
    statements     : Cmd   # the Statements contained in the body's LocalScope

    is_organized   = false
    is_resolved    = false

    min_args       : Int32

    locals         = Local[]

    throws         : Type
    # Most general type of exception that this procedure throws (or null)

  METHODS
    method init( t:Token, name:String, parameters=null:Parameters, return_type=null:Type,
        attributes=null:Attributes, body=null:LocalScope )
      init( t, null, name, parameters, return_type, attributes, body )

    method init( t, module_context, name, parameters=null, return_type=null,
        attributes=null, body=null )
      if (not parameters) parameters = Parameters(t)
      if (not attributes) attributes = Attributes( t )
      if (not body)       body = LocalScope(t)
      statements = body.statements

    method init( existing:Procedure )
      prior.init( existing )
      name = existing.name
      if (existing.parameters)  parameters  = existing.parameters.cloned
      if (existing.return_type) return_type = existing.return_type.cloned
      if (existing.attributes)  attributes  = existing.attributes.cloned
      if (existing.body)        body  = existing.body.cloned
      if (body) statements = body.statements
      module_context = existing.module_context
      signature = existing.signature
      is_organized = existing.is_organized
      is_resolved  = existing.is_resolved
      min_args     = existing.min_args
      locals.add( (forEach in existing.locals).cloned )
      throws       = existing.throws

    method accepts_arg_count( n:Int32 )->Logical
      return n >= min_args and n <= parameters.count

    method context_signature->String
      return "$::$"(module_context,signature)

    method description->String
      return which{ signature || name }

    method is_method->Logical
      return attributes.is_method

    method organize( organizer=null:Organizer )
      if (is_organized) return
      is_organized = true

      if (not module_context) module_context = Program.current_module

      if (not signature)
        use builder = StringBuilder.pool
          builder.print name
          builder.print '('
          forEach (p at i in parameters)
            block p = p->(as Local)
              assert p
              if (i) builder.print ','
              if (not p.type)
                if (this instanceOf Method)
                  local prop = this->(as Method).type_context.properties[p.name]
                  if (prop)
                    p.name = "_auto_store_" + p.name
                    p.type = prop.type
                    statements.insert( Assign(p.t,Access(p.t,prop.name),Access(p.t,p.name)) )
                  else
                    throw p.t.error( "No corresponding property for auto-store parameter '$'."(p.name) )
                  endIf
                else
                  throw p.t.error( "Missing parameter type (e.g. $:SomeType)."(p.name) )
                endIf
              endIf
              assert p.type
              builder.print( p.type.name )
            endBlock
          endForEach
          builder.print ')'
          signature = builder->String
        endUse

        min_args = 0
        forEach (p in parameters)
          block p = p->(as Local)
            if (p.initial_value) escapeForEach
            ++min_args
          endBlock
        endForEach
        forEach (p in parameters from min_args)
          block p = p->(as Local)
            if (not p.initial_value)
              throw p.t.error( "Missing default value. Once one parameter has a default value, all successive parameters must supply default values as well." )
            endIf
          endBlock
        endForEach
      endIf

      temporarily organizer.this_procedure = this
        organizer.visit_children( this )
      endTemporarily

    method resolve( resolver=null:Resolver )
      if (not is_organized) organize

      if (is_resolved) return
      is_resolved = true
      ensure resolver

      resolver.visit( module_context, this )

    method type_context->Type
      throw UnsupportedOperationError()

endClass

