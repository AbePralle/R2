module R2

class Program [singleton]
  PROPERTIES
    t              : Token

    is_configured  = false

    type_Logical   : Type
    type_Character : Type
    type_Int32     : Type
    type_Real64    : Type
    type_String    : Type
    type_Value     : Type

    type_Object    : Type
    type_Global    : Type
    type_XY        : Type

    parsed_files   = StringTable<<AST>>()
    definitions    = StringTable<<Token[]>>()

    default_module  : Module
    global_module   : Module
    current_module  : Module
    all_modules     = Module[]
    modules_by_name = StringTable<<Module>>()

  METHODS
    method init
      Program = this # update singleton reference

      t = Token( TokenType.EOI, "R2" )

      default_module = Module( t, "Default" )
      global_module  = Module( t, "Global" )
      default_module.uses_module( global_module )

      current_module = global_module
      type_Logical   = TypeLogical(t)
      type_Character = TypeCharacter(t)
      type_Int32     = TypeInt32(t)
      type_Real64    = TypeReal64(t)
      type_String    = TypeString(t)
      type_Value     = TypeValue(t)
      type_Object    = Type( t, "Object" )
      type_Global    = Type( t, "Global" )
      type_XY        = Type( t, "XY" ).[ is_built_in=true ]

      current_module = default_module

    method get_module( name:String )->Module
      return modules_by_name[ name ]

    method get_module( t:Token, name:String )->Module
      if (name is null)
        return default_module
      elseIf (modules_by_name.contains(name))
        return modules_by_name[ name ]
      else
        return Module( t, name )  # Module adds itself to lookup tables.
      endIf

    method find_type( name:String )->Type
      if (name.contains("::"))
        local m = get_module( name.before_first("::") )
        return m.find_type( name.after_first("::") )
      else
        local type = default_module.find_type( name, &extended_search )
        if (type) return type
        return null
      endIf

    method include( filepath:String )
      include( t, filepath )

    method include( t:Token, filepath:String )
      filepath = File.abs( filepath.with_trailing( ".r2" ) )
      if (not File.exists(filepath))
        throw t.error( "No such file '$'."(filepath) )
      endIf

      if (parsed_files.contains(filepath)) return
      parsed_files[filepath] = null # placeholder to prevent recursive inclusion

      temporarily current_module = Program.default_module
        local tokens = Scanner( File(filepath) ).tokenize
        Parser( tokens ).preprocess
        local ast = Parser(tokens).parse->(as AST)
        parsed_files[ filepath ] = ast
        if (ast)
          Collector().visit( ast )
        endIf
      endTemporarily

    #method launch
      #resolve
      #{
      forEach (m in all_modules)
        m.execute
        if (execution_status == EXE_ERROR)
          if (not execution_error) execution_error = t.error( "[INTERNAL] Unknown error." )
          throw execution_error
        endIf
      endForEach
      require stack.is_empty
      require fp == 0
      }#

    method resolve
      (forEach in all_modules).organize

      local r_on_launch = default_module.find_routine( "on_launch()" )
      if (not r_on_launch)
        r_on_launch = Routine( t, default_module, "on_launch", Statements(t) )
        default_module.add_routine( r_on_launch )
      endIf
      (forEach in all_modules).collect_global_statements( r_on_launch.statements )
      r_on_launch.is_organized = false
      r_on_launch.organize

      (forEach in all_modules).resolve


    method generate_c
      local h_writer = CWriter( File("Test.h") )
      h_writer.println "// Test.h"
      h_writer.println ...
        @|
         |// Handle Apple's wonky defines which used to ALWAYS be defined as 0 or 1 and
         |// are now only defined if the platform is active.
         |#if defined(__APPLE__)
         |  #if defined(TARGET_IPHONE_SIMULATOR)
         |    #if TARGET_IPHONE_SIMULATOR
         |      #define ROGUE_PLATFORM_IOS 1
         |    #endif
         |  #endif
         |
         |  #if !defined(ROGUE_PLATFORM_IOS)
         |    #if defined(TARGET_OS_IPHONE)
         |      #if TARGET_OS_IPHONE
         |        #define ROGUE_PLATFORM_IOS 1
         |      #endif
         |    #endif
         |  #endif
         |
         |  #if !defined(ROGUE_PLATFORM_IOS)
         |    #define ROGUE_PLATFORM_MACOS 1
         |    #define ROGUE_PLATFORM_UNIX_COMPATIBLE 1
         |  #endif
         |#endif
         |
         |#if !defined(ROGUE_PLATFORM_IOS) && !defined(ROGUE_PLATFORM_MACOS)
         |  #if defined(_WIN32)
         |  #  define ROGUE_PLATFORM_WINDOWS 1
         |  #elif defined(__ANDROID__)
         |  #  define ROGUE_PLATFORM_ANDROID 1
         |  #elif defined(__linux__)
         |  #  define ROGUE_PLATFORM_UNIX_COMPATIBLE 1
         |  #elif defined(__CYGWIN__)
         |  #  define ROGUE_PLATFORM_UNIX_COMPATIBLE 1
         |  #else
         |  #  define ROGUE_PLATFORM_GENERIC 1
         |  #endif
         |#endif
         |
         |#if defined(ROGUE_PLATFORM_WINDOWS)
         |#  define NOGDI
         |#  pragma warning(disable: 4297) /* unexpected throw warnings */
         |#  include <windows.h>
         |#  include <signal.h>
         |#else
         |#  include <stdint.h>
         |#endif
         |
         |//#include <stdlib.h>
         |//#include <string.h>
         |
         |//-----------------------------------------------------------------------------
         |//  Logging
         |//-----------------------------------------------------------------------------
         |#ifdef __ANDROID__
         |  #include <android/log.h>
         |  #define ROGUE_LOG(...)       __android_log_print( ANDROID_LOG_INFO,  "Rogue", __VA_ARGS__ )
         |  #define ROGUE_LOG_ERROR(...) __android_log_print( ANDROID_LOG_ERROR, "Rogue", __VA_ARGS__ )
         |#else
         |  #define ROGUE_LOG(...)       printf( __VA_ARGS__ )
         |  #define ROGUE_LOG_ERROR(...) printf( __VA_ARGS__ )
         |#endif
         |
         |//-----------------------------------------------------------------------------
         |//  Primitive Types
         |//-----------------------------------------------------------------------------
         |#if defined(ROGUE_PLATFORM_WINDOWS)
         |  typedef double           RogueReal64;
         |  typedef float            RogueReal32;
         |  typedef __int64          RogueInt64;
         |  typedef __int32          RogueInt32;
         |  typedef __int32          RogueCharacter;
         |  typedef unsigned __int16 RogueWord;
         |  typedef unsigned char    RogueByte;
         |  typedef int              RogueLogical;
         |  typedef unsigned __int64 RogueUInt64;
         |  typedef unsigned __int32 RogueUInt32;
         |#else
         |  typedef double           RogueReal64;
         |  typedef float            RogueReal32;
         |  typedef int64_t          RogueInt64;
         |  typedef int32_t          RogueInt32;
         |  typedef int32_t          RogueCharacter;
         |  typedef uint16_t         RogueWord;
         |  typedef uint8_t          RogueByte;
         |  typedef int              RogueLogical;
         |  typedef uint64_t         RogueUInt64;
         |  typedef uint32_t         RogueUInt32;
         |#endif
         |

      (forEach in all_modules).write_c_header( h_writer )
      h_writer.close


      local c_writer = CWriter( File("Test.c") )
      c_writer.println  "// Test.c"
      c_writer.println ''#include "Test.h"''
      c_writer.println  "#include <stdio.h>"
      c_writer.println

      (forEach in all_modules).write_c_code( c_writer )
      c_writer.println @|
                        |int main( int argc, char* argv[] )
                        |{
      c_writer.indent += 2

      c_writer.println @|on_launch();
                        |return 0;

      c_writer.indent -= 2
      c_writer.println @|}

      c_writer.close

    method set_current_module( @current_module )

    method set_current_module( t:Token, name:String )
      if (name is null)
        @current_module = default_module
      elseIf (modules_by_name.contains(name))
        @current_module = modules_by_name[ name ]
      else
        @current_module = Module( t, name )
      endIf

    method type( name:String )->Type
      if (name.contains("::"))
        local m = get_module( name.before_first("::") )
        return m.type( name.after_first("::") )
      else
        return default_module.type( name )
      endIf

endClass

